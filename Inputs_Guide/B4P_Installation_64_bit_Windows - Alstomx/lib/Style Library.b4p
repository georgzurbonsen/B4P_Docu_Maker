

/*
	Style Library.txt
	____________________________________________________________________________________________________________


	Add some color, style, comments and lots of beautiful elements into your tables !!!

	____________________________________________________________________________________________________________


	Author:			Georg zur Bonsen
				Copyright (C) 2017-2022 by Georg zur Bonsen, All Rights Reserved

	Contents:

	This library contains a set of table style and formatting features which can be defined and
	will then be applied when the tables are saved into files using 'table save' or 'table save as'
	functions.  These two functions will automatically detect the data structures built up and use the
	contents to add formatting information.

	The style and formatting info is supported for the target file formats HTML and EXCEL (an XML format for Excel).
	Saving files with CSV format will not include any formatting.

	This library is entirely written with B4P.  Experience the virtuous power of this programming language.

	If you want to use this library, then you need to specify following function call:   include ( "Style Library.txt" )
	If the library is not in the same directory, then specfiy an appropriate directory path.


	Revision History:
	____________________________________________________________________________________________________________

	Library	BP		Date		Features

	1.00	5.00				First Release, lots of features, supports HTML and EXCEL XML file formats
	1.01	5.01				updated, some performance enhancements
	1.02	5.08		2019-05-03	Better exception handling (error messages), additional functions like freezing panes
	1.03	6.01		2019-09-01	Corrected bug on table freeze rows / columns. Before only both rows + cols worked properly.
	1.10	7.01		2020-07-04	Misc. updates
	2.00	8.00		2020-08-08	Transition to B4P
	2.01	8.00		2020-10-30	Correction (bodface in HTML did not work)
	2.02	8.00		2020-11-13	Version info moved to system variable
	2.11	8.00		2021-01-03	Supports new Excel (2013+) format
	2.12	8.01		2021-02-03	Added 'table style auto width'
	2.13	8.01		2020-01-24	Ensure that 'table style description'[] defined is always a global variable
	2.20	8.01		2020-02-21	Added 'table style theme' and 'table style auto width'
	2.21	8.01		2020-06-13	Bugfix in 'table style auto width' where it asserted exception in columns without any contents

*/


once
{

	//
	// Version verification
	// _________________________________________________________________________________________________________
	//

	libraries[style library,version info] = "2.21";
	if (runtime settings[verbose] != quiet) echo("Included: ", "Style Library", "  ", libraries[style library,version info] );


	if (numeral( left( version info[], ' ')) < 8.01)
	{
	    echo("Version Mismatch. Prerequisite for using this file 'Style Library.txt' is B4P Release 8.01 or newer.");
	    echo("Please obtain and install latest available release.");
	    stop;
	}

	

	//
	// Basic color specification functions
	// _________________________________________________________________________________________________________
	//




	libraries[style library,hex] = 0; // System variable
	array( libraries[style library,hex], { '0'..'9', A..F } );


	// Function:	rgb
	//
	// Description:	Converts a color specification into a parameter set of 3 numerals
	//
	// Parameters:	{ red, green, blue } or color name or  #RRGGBB
	//		Returned as qualified { red, green, blue } parameter set
	//
	// Return val:	Blank = OK, otherwise error message


	define function( rgb, {{ color, literal or parameters, reference }} )
	{
	    if (type(color[])==parameter set)
	    {
		if (color[]{} != 3) return( "Parameter set for a color must contain 3 elements {red, green, blue}.");

		unless (is numeric(color[]{0})) return("1st color (red) is not a number.");
		unless (is numeric(color[]{1})) return("2nd color (green) is not a number.");
		unless (is numeric(color[]{2})) return("3rd color (blue) is not a number.");

		color[] = deep( min, { deep( max, { deep( round, { color[] }), 0 }), 255 }); // Ensure 0..255 range enforced

	    }
	    else: if(type(color[])==literal)
	    {
		if ( color[]{}==7 & color[]{0}=='#' ) // Hexadecimal
		{
		    color[] = { hex to decimal( color[], 1, 2 ), hex to decimal( color[], 3, 2 ), hex to decimal( color[], 5, 2 ) };
		}
		else // Color name
		{
		    local() row[] = [global color table:Color Name, color[]];
		    if (row[] > 0)
			with table ( global color table, row[] ) color[] = { [Red], [Green], [Blue] };
		    else
			return( compose("Specified color name '", color[],"' is unknown") );
		}
	    }
	    else: return( "Variable provided to function 'rgb' is neither of type 'literal' nor 'parameter set'");
	    return('');
	}



	define function ( check and translate color, { { generic attribute value, literal or parameters, reference }, { rgb out, boolean } }, 1, 2 )
	{
	    if (!existing(rgb out[])) rgb out[] = false;

	    if ( type(generic attribute value[]) == 'parameter set' )
	    {
		if (generic attribute value[]{} != 3) return( "Parameter set for a color must contain 3 elements {red, green, blue}.");

		unless (is numeric(generic attribute value[]{0})) return("First color (red) is not a number.");
		unless (is numeric(generic attribute value[]{1})) return("Second color (green) is not a number.");
		unless (is numeric(generic attribute value[]{2})) return("Third color (blue) is not a number.");

		generic attribute value[] = deep( round, { generic attribute value[] } );
		generic attribute value[] = deep( max, { generic attribute value[], 0 } );
		generic attribute value[] = deep( min, { generic attribute value[], 255 } );
		if (!rgb out[]) generic attribute value[] = rgb to html code( generic attribute value[]{0}, generic attribute value[]{1}, generic attribute value[]{2});
	    }
	    else: if ( type(generic attribute value[]) == 'literal' )
	    {
		if (rgb out[])
		{
			color code looked up[] = { [global color table:Color Name,generic attribute value[],Red],
						   [global color table:Color Name,generic attribute value[],Green],
						   [global color table:Color Name,generic attribute value[],Blue] };

			if (color code looked up[]{0}!="Red") // Misses result to referring to header row name
			{
				generic attribute value[] = color code looked up[];
			}
			else:
			{
			    return( "If color is specified with a literal, use a valid color name." );
			}

		}
		else
		{
			color code looked up[] = [global color table:Color Name,generic attribute value[],HTML Color];
			if (color code looked up[]!="HTML Color") // Misses result to referring to header row name
			{
				generic attribute value[] = color code looked up[];
			}
			else: if ( ( generic attribute value[]{0}!="#") | (length(generic attribute value[])!=7) )  // HTML Code
			{
			    return( "If color is specified with a literal, use a valid color name or hexadecimal format #RRGGBB (7 symbols)" );
			}
		    }
		}
	    else : return( "Provided wrong type to specify a color: '", type(generic attribute value[]), "'. Literal or parameter set expected." );
	    return (""); // OK
	}







	// Function:	rgb to html code
	//
	// Description:	Converts RGB values into a HTML / XML compatible color specification '#RRGGBB' containing
	//		two hexadecimal digits for every color.
	//
	// Parameters:	red		Red color component, 0 .. 255
	//		green		Greeen "
	//		blue		Blue
	//
	// Return val:	literal		HTML compatible color specification #RRGGBB


	define function ( rgb to html code, {{ red, numeral}, {green, numeral}, {blue,numeral}} )
	{
		hex[] =^ libraries[style library,hex];

		if (red  [] >255) red  []=255;
		if (green[] >255) green[]=255;
		if (blue [] >255) blue []=255;

		red 0[]   = mod( red[], 16);
		red  []   = round down(red[] / 16);

		green 0[] = mod( green[], 16);
		green  [] = round down(green[] / 16);

		blue 0[]  = mod( blue[], 16);
		blue  []  = round down(blue[] / 16);

		return( '#' + hex[red[]] + hex[red 0[]] + hex[green[]] + hex[green 0[]] + hex[blue[]] + hex[blue 0[]] );
	}





	table initialize( global color table,
	{
		{ Color Name,		Cat 1,		Cat 2,		Red,	Green,	Blue,	HTML Color 	},

		// Around the color circle

		{ red,			standard,	primary,	255,	  0,	  0			},
		{ scarlet,		standard,	saturated,	255,	 64,	  0			},
		{ mandarin,		standard,	saturated,	255,	128,	  0			},
		{ orange,		standard,	saturated,	255,	192,	  0			},

		{ mango,		standard,	saturated,	255,	224,	  0			},
		{ chrome,		standard,	saturated,	255,	240,	  0			},
		{ yellow,		standard,	primary,	255,	255,	  0			},
		{ lemon,		standard,	saturated,	224,	255,	  0			},

		{ granny,		standard,	saturated,	192,	255,	  0			},
		{ chartreuse,		standard,	saturated,	128,	255,	  0			},
		{ green,		standard,	primary,	  0,	255,	  0			},
		{ spring green,		standard,	saturated,	  0,	255,	128			},

		{ turquoise,		standard,	saturated,	  0,	255,	192			},
		{ cyan,			standard,	primary,	  0,	255,	255			},
		{ sky blue,		standard,	saturated,	  0,	224,	255			},
		{ aquamarine,		standard,	saturated,	  0,	192,	255			},

		{ azur,			standard,	saturated,	  0,	160,	255			},
		{ ocean,		standard,	saturated,	  0,	128,	255			},
		{ sapphire,		standard,	saturated,	  0,	 96,	255			},
		{ lapis,		standard,	saturated,	  0,	 64,	255			},

		{ royal blue,		standard,	saturated,	  0,	 32,	255			},
		{ blue,			standard,	primary,	  0,	  0,	255			},
		{ admiral,		standard,	saturated,	 64,	  0,	255			},
		{ ultramarine,		standard,	saturated,	 96,	  0,	255			},

		{ violet,		standard,	saturated,	128,	  0,	255			},
		{ purple,		standard,	saturated,	160,	  0,	255			},
		{ electric,		standard,	saturated,	192,	  0,	255			},
		{ phlox,		standard,	saturated,	224,	  0,	255			},

		{ magenta,		standard,	primary,	255,	  0,	255			},
		{ pink,			standard,	saturated,	255,	  0,	192			},
		{ carmine,		standard,	saturated,	255,	  0,	128			},
		{ cold red,		standard,	saturated,	255,	  0,	 64			},

		// Shades of gray

		{ black,		standard,	gray scale,	  0,	  0,	  0			},
		{ gray 1,		standard,	gray scale,	 16,	 16,	 16			},
		{ gray 2,		standard,	gray scale,	 32,	 32,	 32			},
		{ gray 3,		standard,	gray scale,	 48,	 48,	 48			},
		{ gray 4,		standard,	gray scale,	 64,	 64,	 64			},
		{ gray 5,		standard,	gray scale,	 80,	 80,	 80			},
		{ gray 6,		standard,	gray scale,	 96,	 96,	 96			},
		{ gray 7,		standard,	gray scale,	112,	112,	112			},
		{ gray 8,		standard,	gray scale,	128,	128,	128			},
		{ gray 9,		standard,	gray scale,	144,	144,	144			},
		{ gray 10,		standard,	gray scale,	160,	160,	160			},
		{ gray 11,		standard,	gray scale,	176,	176,	176			},
		{ gray 12,		standard,	gray scale,	192,	192,	192			},
		{ gray 13,		standard,	gray scale,	208,	208,	208			},
		{ gray 14,		standard,	gray scale,	224,	224,	224			},
		{ gray 15,		standard,	gray scale,	240,	240,	240			},
		{ white,		standard,	gray scale,	255,	255,	255			},

		{ warm gray,		standard,	gray tones,	136,	128,    120			},
		{ cold gray,		standard,	gray tones,	120,	128,    136			},

		// Excel color palette

		{ excel light green,	standard,	excel color,	146,	208,	 80			},
		{ excel green,		standard,	excel color,	  0,	176,	 80			},
		{ excel light blue,	standard,	excel color,	  0,	176,	240			},
		{ excel blue,		standard,	excel color,	  0,	112,	192			},
		{ excel dark blue,	standard,	excel color,	  0,	 32,	 96			},
		{ excel violet,		standard,	excel color,	112,	 48,	160			},


		// Shades of red

		{ coral,		standard,	red tones,	248,	131,	121			},
		{ pigment red,		standard,	red tones,	237,	 28,	 36			},
		{ imperial red,		standard,	red tones,	237,	 41,	 57			},
		{ indian red,		standard,	red tones,	205,	 92,	 92			},
		{ ruby,			standard,	red tones,	224,	 17,	 95			},
		{ raspberry,		standard,	red tones,	227,	 11,	 92			},
		{ crimson,		standard,	red tones,	220,	 20,	 60			},
		{ fire brick,		standard,	red tones,	178,	 34,	 34			},
		{ redwood,		standard,	red tones,	164,	 90,	 82			},
		{ maroon,		standard,	red tones,	128,	  0,	  0			},
		{ barn red,		standard,	red tones,	124,	 10,	  2			},
		{ burgundy,		standard,	red tones,	144,	  0,	 32			},
		{ turkey red,		standard,	red tones,	169,	 17,	  1			},
		{ indian red,		standard,	red tones,	205,	 92,	 92			},
		{ terra cotta,		standard,	red tones,	226,	114,	 91			},

		// Shades of yellow

		{ pigment yellow,	standard,	yellow tones,	255,	239,	  0			},
		{ pastel yellow,	standard,	yellow tones,	253,	253,	150			},
		{ dandelion,		standard,	yellow tones,	240,	225,	 48			},
		{ aureolin,		standard,	yellow tones,	255,	238,	  0			},
		{ gold,			standard,	yellow tones,	255,	215,	  0			},
		{ mustard,		standard,	yellow tones,	255,	219,	 88			},
		{ saffron,		standard,	yellow tones,	244,	196,	 48			},
		{ ocre,			standard,	yellow tones,	218,	165,	 32			},
		{ royal yellow,		standard,	yellow tones,	250,	218,	 94			},
		{ mellow yellow,	standard,	yellow tones,	248,	222,	126			},
		{ straw,		standard,	yellow tones,	228,	217,	111			},
		{ lemon chiffon,	standard,	yellow tones,	255,	250,	205			},
		{ khaki,		standard,	yellow tones,	240,	230,	140			},
		{ vanilla,		standard,	yellow tones,	243,	229,	171			},

		// Shades of green

		{ shamrock,		standard,	green tones,	  0,	158,	 96			},	
		{ go transit green,	standard,	green tones,	  0,	171,	102			},
		{ jade,			standard,	green tones,	  0,	168,	107			},
		{ artichoke,		standard,	green tones,	143,	151,	121			},
		{ artichoke green,	standard,	green tones,	 75,	111,	 68			},
		{ asparagus,		standard,	green tones,	135,	169,	106			},
		{ avocado,		standard,	green tones,	 86,	130,	  3			},
		{ olive,		standard,	green tones,	128,	128,	  0			},
		{ fern green,		standard,	green tones,	 79,	121,	 66			},
		{ fern,			standard,	green tones,	113,	188,	120			},
		{ forest,		standard,	green tones,	 34,	139,	 34			},
		{ hookers green,	standard,	green tones,	 73,	121,	107			},		
		{ jungle green,		standard,	green tones,	 41,	171,	135			},		
		{ paris green,		standard,	green tones,	 80,	200,	120			},
		{ laurel,		standard,	green tones,	169,	186,	157			},		
		{ mantis,		standard,	green tones,	166,	195,	101			},		
		{ moss,			standard,	green tones,	138,	154,	 91			},		
		{ myrtle,		standard,	green tones,	 49,	120,	115			},	
		{ mint,			standard,	green tones,	152,	251,	152			},		
		{ tea green,		standard,	green tones,	208,	240,	192			},	
		{ pine,			standard,	green tones,	  1,	121,	111			},	
		{ pigment green,	standard,	green tones,	  0,	165,	 80			},	
		{ sea green,		standard,	green tones,	 46,	139,	 87			},
		{ malachite,		standard,	green tones,	 11,	218,	 81			},
		{ emerald,		standard,	green tones,	 80,	220,	100			},
		{ midnight green,	standard,	green tones,	  0,	 73,	 83			},
		{ persian green,	standard,	green tones,	  0,	166,	147			},

		// Shades of blue

		{ baby blue,		standard,	blue tones,	137,	207,	240			},
		{ steel blue,		standard,	blue tones,	176,	196,	222			},
		{ periwinkle,		standard,	blue tones,	204,	204,	255			},
		{ powder blue,		standard,	blue tones,	176,	224,	230			},
		{ teal,			standard,	blue tones,	  0,	128,	128			},
		{ teal blue,		standard,	blue tones,	 54,	117,	136			},
		{ cadet blue,		standard,	blue tones,	 95,	158,	160			},
		{ slate blue,		standard,	blue tones,	106,	 90,	205			},
		{ liberty blue,		standard,	blue tones,	 84,	 90,	167			},
		{ morning blue,		standard,	blue tones,	141,	163,	153			},
		{ pigment blue,		standard,	blue tones,	 51,	 51,	153			},
		{ spanish blue,		standard,	blue tones,	  0,	112,	184			},
		{ navy,			standard,	blue tones,	  0,	  0,	128			},
		{ midnight blue,	standard,	blue tones,	 25,	 25,	112			},
		{ indigo,		standard,	blue tones,	 75,	  0,	130			},

		// Shades of purple

		{ royal purple,		standard,	purple tones,	120,	 81,	169			},
		{ thistle,		standard,	purple tones,	216,	191,	216			},
		{ plum,			standard,	purple tones,	221,	160,	221			},
		{ orchid,		standard,	purple tones,	218,	112,	214			},
		{ pansy purple,		standard,	purple tones,	120,	 24,	 74			}, 

		// Shades of pink

		{ champagne,		standard,	pink tones,	241,	221,	207			},
		{ mimi pink,		standard,	pink tones,	255,	218,	233			},	
		{ baby pink,		standard,	pink tones,	244,	194,	194			},
		{ orchid pink,		standard,	pink tones,	242,	189,	205			},
		{ charm pink,		standard,	pink tones,	230,	143,	172			},
		{ china pink,		standard,	pink tones,	222,	111,	161			},	
		{ tango pink,		standard,	pink tones,	255,	113,	122			},	
		{ salmon,		standard,	pink tones,	255,	145,	164			},
		{ silver pink,		standard,	pink tones,	196,	174,	173			},	
		{ queen pink,		standard,	pink tones,	232,	204,	215			},	
		{ lavender,		standard,	pink tones,	219,	178,	209			},	

		// Shades of brown

		{ brown,		standard,	brown tones,	150,	 75,	 0			},
		{ tan,			standard,	brown tones,	210,	180,	140			},
		{ mahogany,		standard,	brown tones,	192,	 64,	 0			},
		{ beaver,		standard,	brown tones,	159,	129,	112			},
		{ beige,		standard,	brown tones,	245,	245,	220			},
		{ burnt umber,		standard,	brown tones,	138,	 51,	 36			},
		{ chestnut,		standard,	brown tones,	149,	 69,	 53			},
		{ chocolate,		standard,	brown tones,	210,	105,	 30			},
		{ cocoa,		standard,	brown tones,	210,	105,	 30			},
		{ desert sand,		standard,	brown tones,	237,	201,	175			},
		{ raw umber,		standard,	brown tones,	130,	102,	 68			},	
		{ rosy brown,		standard,	brown tones,	188,	143,	143			},
		{ tan,			standard,	brown tones,	210,	180,	140			},
		{ taupe,		standard,	brown tones,	 72,	 60,	 50			},
		{ peru,			standard,	brown tones,	205,	133,	 63			},
		{ wood brown,		standard,	brown tones,	193,	143,	107			},
		{ ecru,			standard,	brown tones,	238,	231,	187			},
		{ sand,			standard,	brown tones,	194,	178,	128			},
		{ sienna,		standard,	brown tones,	136,	 82,	 45			},
		{ sepia,		standard,	brown tones,	112,	 66,	 20			},
		{ auburn,		standard,	brown tones,	164,	 42,	 42			},
		{ tawny,		standard,	brown tones,	205,	 87,	  0			},
		{ rust,			standard,	brown tones,	183,	 65,	 14			}


	} );


	table process( global color table, [HTML Color]=rgb to html code( [Red],[Green],[Blue] ) );
	table configure( global color table, row not found, header row );



	define function ( lighten color, { { color in, literal or parameters }, { factor, numeral } } )
	{
	    if (factor[] < 1) factor[] = 1;
	    local() ret val[] = rgb( color in[] );
	    if (ret val[] != '')
	    {
		exception( stop, compose("Function 'lighten color':", new line, 1, ". parameter: ", ret val[]), 1);
	    }
	    return (
	    {
		min( 256 - round down ((256 - color in[]{0}) / factor[]), 255),
		min( 256 - round down ((256 - color in[]{1}) / factor[]), 255),
		min( 256 - round down ((256 - color in[]{2}) / factor[]), 255)
	    } );
	}


	define procedure ( lighten colors, { { row numbers, numerals }, { suffix, to literal }, { factor, numeral } } )
	{
	    if (factor[] < 1) factor[] = 1;
	    local() for all parameters (row numbers[], y[])
	    {
		with table( global color table, y[] )
		{
			color name[] = "light " + [Color Name];
			if (suffix[]!="") color name[] += " " + suffix[]; // e.g. red -> light red 1, blue -> light blue 1
			red  [] = select if ([Red  ]<255, 256 - round down ((256 - [Red  ]) / factor[]), 255);
			green[] = select if ([Green]<255, 256 - round down ((256 - [Green]) / factor[]), 255);
			blue [] = select if ([Blue ]<255, 256 - round down ((256 - [Blue ]) / factor[]), 255);

			table append( global color table, { { color name[], "lightened", [Cat 2], red[], green[], blue[], rgb to html code( red[],green[],blue[] ) } } );
		}
	    }
	}


	define function ( darken color, { { color in, literal or parameters }, { factor, numeral } } )
	{
	    if (factor[] < 1) factor[] = 1;
	    local() ret val[] = rgb( color in[] );
	    if (ret val[] != '')
	    {
		exception( stop, compose("Function 'darken color':", new line, 1, ". parameter: ", ret val[]), 1);
	    }
	    return ( { round up(color in[]{0}/ factor[]), round up(color in[]{1}/ factor[]), round up(color in[]{2}/ factor[]) } );
	}


	define procedure ( darken colors, { { row numbers, numerals }, { suffix, to literal }, { factor, numeral } } )
	{
	    if (factor[] < 1) factor[] = 1;
	    local() for all parameters (row numbers[], y[])
	    {
		with table( global color table, y[] )
		{
			color name[] = "dark " + [Color Name];
			if (suffix[]!="") color name[] += " " + suffix[]; // e.g. red -> dark red 1, blue -> dark blue 1
			red  [] = round up([Red  ] / factor[]);
			green[] = round up([Green] / factor[]);
			blue [] = round up([Blue ] / factor[]);

			table append( global color table, { { color name[], "darkened", [Cat 2], red[], green[], blue[], rgb to html code( red[],green[],blue[] ) } } );

		}
	    }
	}


	define function ( weaken color, { { color in, literal or parameters }, { factor, numeral } } )
	{
	    if (factor[] < 1) factor[] = 1;
	    local() ret val[] = rgb( color in[] );
	    if (ret val[] != '')
	    {
		exception( stop, compose("Function 'weaken color':", new line, 1, ". parameter: ", ret val[]), 1);
	    }
	    else
	    {
		local() luminance[] = (0.299*color in[]{0}+0.587*color in[]{1}+0.114*color in[]{2}); // RGB to luminance value
	        return (
	        {
		    round up(color in[]{0} * (1/ factor[]) + luminance[] * (1-(1 / factor[])) ),
		    round up(color in[]{1} * (1/ factor[]) + luminance[] * (1-(1 / factor[])) ),
		    round up(color in[]{2} * (1/ factor[]) + luminance[] * (1-(1 / factor[])) )
	        } );
	    }
	}



	define procedure ( weaken colors, { { row numbers, numerals }, { suffix, to literal }, { factor, numeral } } )
	{
	    if (factor[] < 1) factor[] = 1;
	    local() for all parameters (row numbers[], y[])
	    {
		with table( global color table, y[] )
		{
			color name[] = "weak " + [Color Name];
			if (suffix[]!="") color name[] += " " + suffix[]; // e.g. red -> dark red 1, blue -> dark blue 1

			luminance[] = (0.299*[Red]+0.587*[Green]+0.114*[Blue]); // RGB to Luminance 

			red  [] = round up([Red  ] * (1/ factor[]) + luminance[] * (1-(1 / factor[])) );
			green[] = round up([Green] * (1/ factor[]) + luminance[] * (1-(1 / factor[])) );
			blue [] = round up([Blue ] * (1/ factor[]) + luminance[] * (1-(1 / factor[])) );

			table append( global color table, { { color name[], "weakened", [Cat 2], red[], green[], blue[], rgb to html code( red[],green[],blue[] ) } } );

		}
	    }
	}


	define procedure ( add color, { { color name, literal }, { category 2, literal }, { color in, literal or parameters } } )
	{
	    local() 
	    {
		if ( [global color table:Color Name,color name[]]>0 )
		{
		    exception( stop, compose("Function 'add color':", new line, "1. parameter: color name = '", color name[],"' is already existing."), 1);
		}

		ret val[] = rgb( color in[] );
	        if (ret val[] != '')
		{
		    exception( stop, compose("Function 'add color':", new line, 3, ". parameter: ", ret val[]), 1);
		}
		else
		{
		    table append( global color table, { { color name[], "user defined", category 2[], color in[]{0}, color in[]{1}, color in[]{2}, rgb to html code( color in[]{0}, color in[]{1}, color in[]{2} ) } } );
		}
	    }
	}

	//
	// Dedicated building blocks to add comments in HTML files (exception: XML files)
	// _________________________________________________________________________________________________________
	//


	libraries[style library,table style html comments] = 0; // Declare as available

	    libraries[style library,table style html comments,building block 1] =	// Building Bock 1: Add once to end of table
		"    <div style='mso-element:comment-list'>"	+ new line +
		"        <div style='mso-element:comment'>"	+ new line +
		"            <!--[if gte mso 9]>"		+ new line +
		"            <xml>"				+ new line +
		'             <v:shapetype id="_x0000_t202" coordsize="21600,21600" o:spt="202" path="m,l,21600r21600,l21600,xe">' + new line +
		'              <v:stroke joinstyle="miter"/>'	+ new line +
		'              <v:path gradientshapeok="t" o:connecttype="rect"/>' + new line +
		"             </v:shapetype>"			+ new line ;

	    libraries[style library,table style html comments,building block 2] =	// Building Bock 1: // Add for each registered comment
		'             <v:shape id="$1" type="#_x0000_t202"'					+ new line + // $1 for comment id
		"                    style='width:96pt;height:55.5pt;z-index:1;visibility:hidden'"	+ new line + 
		'                    fillcolor="infoBackground [80]" o:insetmode="auto">'		+ new line +
		"              <v:textbox style='mso-direction-alt:auto'/>"				+ new line +
		'              <x:ClientData ObjectType="Note">'					+ new line +
		"               <x:Row>$2</x:Row>"							+ new line + // $2 for row number
		"               <x:Column>$3</x:Column>"						+ new line + // $3 for column number
		"              </x:ClientData>"								+ new line +
		"             </v:shape>" 								+ new line;

	    libraries[style library,table style html comments,building block 3] =	// Building Bock 3: Add once
		"            </xml>"				+ new line +
		"            <![endif]-->" 			+ new line;

	    libraries[style library,table style html comments,building block 4] =  	// Add for each registered comment
		'            <div v:shape="$4" >$5</div>' 	+ new line;	// $4 for comment id, $5 for comment text

	    libraries[style library,table style html comments,building block 5] =  // Add once
		"        </div>" 				+ new line +
		"    </div>" 					+ new line;



	//
	// Define the generic attributes, allowed values and scope (whole table, row, column or individual cell)
	//


	libraries[style library,table style rules] = 0; // Declare as available
	table style rules[] =^ libraries[style library,table style rules];


	// Choices: Distinguishing between colors, boolean, choices, literal, numeral 1 or bigger, and integer 2 or bigger


	table style rules[text   color 	   , choices ] = { colors };
	table style rules[text   color 	   , XML tags] = { Style, Font };
	table style rules[text   color 	   , XML attr] = { 'ss:Color="$"' }; // Dollar symbol denotes value placeholder
	table style rules[text   color 	   ,HTML tags] = { Style, Text Color };
	table style rules[text   color 	   ,HTML attr] = { 'color:$' }; // Dollar symbol denotes value placeholder


	table style rules[fill   color 	   , choices ] = { colors };
	table style rules[fill   color 	   , XML tags] = { Style, Interior };
	table style rules[fill   color 	   , XML attr] = { 'ss:Color = "$" ss:Pattern="Solid"' };
	table style rules[fill   color 	   ,HTML tags] = { Style, Fill Color };
	table style rules[fill   color 	   ,HTML attr] = { 'background-color:$' };


	table style rules[top border       , choices ] = { border spec, { hairline, thin, medium, thick} };
	table style rules[top border       , XML tags] = { Style, Border, Top };
	table style rules[top border       , XML attr] = { '<Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="@" ss:Color="$" />', { '0','1','2','3'} };
	table style rules[top border       ,HTML tags] = { Style, Top Border };
	table style rules[top border       ,HTML attr] = { 'border-top-style:solid; border-top-color:$; border-top-width:@', { '0.25pt','0.5pt','1pt','2pt'} };


	table style rules[bottom border    , choices ] = { border spec, { hairline, thin, medium, thick} };
	table style rules[bottom border    , XML tags] = { Style, Border, Bottom };
	table style rules[bottom border    , XML attr] = { '<Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="@" ss:Color="$" />', { '0','1','2','3'} };
	table style rules[bottom border    ,HTML tags] = { Style, Bottom Border };
	table style rules[bottom border    ,HTML attr] = { 'border-bottom-style:solid;border-bottom-color:$;border-bottom-width:@', { '0.25pt','0.5pt','1pt','2pt'} };


	table style rules[left border      , choices ] = { border spec, { hairline, thin, medium, thick} };
	table style rules[left border      , XML tags] = { Style, Border, Left };
	table style rules[left border      , XML attr] = { '<Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="@" ss:Color="$" />', { '0','1','2','3'} };
	table style rules[left border      ,HTML tags] = { Style, Left Border };
	table style rules[left border      ,HTML attr] = { 'border-left-style:solid;border-left-color:$;border-left-width:@', { '0.25pt','0.5pt','1pt','2pt'} };


	table style rules[right border     , choices ] = { border spec, { hairline, thin, medium, thick} };
	table style rules[right border     , XML tags] = { Style, Border, Right };
	table style rules[right border     , XML attr] = { '<Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="@" ss:Color="$" />', { '0','1','2','3'} };
	table style rules[right border     ,HTML tags] = { Style, Right Border };
	table style rules[right border     ,HTML attr] = { 'border-right-style:solid;border-right-color:$;border-right-width:@', { '0.25pt','0.5pt','1pt','2pt'} };


	table style rules[borders          , choices ] = { border spec, { hairline, thin, medium, thick} };
	table style rules[borders          , XML tags] = { Style, Border, Right };
	table style rules[borders          , XML attr] = { '<Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="@" ss:Color="$" />', { '0','1','2','3'} };
	table style rules[borders          ,HTML tags] = { Style, Right Border };
	table style rules[borders          ,HTML attr] = { 'border-right-style:solid;border-right-color:$;border-right-width:@', { '0.25pt','0.5pt','1pt','2pt'} };


	table style rules[underscore   	   , choices ] = { boolean };
	table style rules[underscore 	   , XML tags] = { Style, Font };
	table style rules[underscore   	   , XML attr] = { 'ss:Underline="$"', {  None , Single } };  // 1st value stands for false, 2nd for true
	table style rules[underscore 	   ,HTML tags] = { Style, Underscore };
	table style rules[underscore       ,HTML attr] = { 'text-decoration:$', { none, underline } };


	table style rules[boldface     	   , choices ] = { boolean };
	table style rules[boldface     	   , XML tags] = { Style, Font };
	table style rules[boldface     	   , XML attr] = { 'ss:Bold="$"', { '0','1' } };
	table style rules[boldface 	   ,HTML tags] = { Style, Boldface };
	table style rules[boldface         ,HTML attr] = { 'font-weight:$', { normal, bold } };


	table style rules[italic       	   , choices ] = { boolean };
	table style rules[italic     	   , XML tags] = { Style, Font };
	table style rules[italic       	   , XML attr] = { 'ss:Italic="$"', { '0','1' } };
	table style rules[italic 	   ,HTML tags] = { Style, Italic };
	table style rules[italic           ,HTML attr] = { 'font-style:$', { normal, italic } };


	table style rules[wrap text    	   , choices ] = { boolean };
	table style rules[wrap text 	   , XML tags] = { Style, Alignment };
	table style rules[wrap text    	   , XML attr] = { 'ss:WrapText="$"', { '0','1' } };
	table style rules[wrap text 	   ,HTML tags] = { Style, Wrap Text };
	table style rules[wrap text        ,HTML attr] = { 'white-space:$', { nowrap, wrap} };

	table style rules[comment          , choices ] = { literal };
	table style rules[comment	   , XML tags] = { Comment };
	table style rules[comment    	   , XML attr] = { '<Comment><ss:Data>$</ss:Data></Comment>' };
	table style rules[comment 	   ,HTML tags] = { Comment };
	table style rules[comment          ,HTML attr] = { '' }; // Special handling hardcoded further below

	table style rules[freeze rows      , choices ] = { integer 0 or bigger };
	table style rules[freeze rows	   , XML tags] = { Freeze, Rows };
	table style rules[freeze rows      , XML attr] = { '$' }; // Special handling hardcoded further below
	table style rules[freeze rows 	   ,HTML tags] = { Freeze, Rows };
	table style rules[freeze rows      ,HTML attr] = { '$' }; // Special handling hardcoded further below

	table style rules[freeze columns   , choices ] = { integer 0 or bigger };
	table style rules[freeze columns   , XML tags] = { Freeze, Columns };
	table style rules[freeze columns   , XML attr] = { '$' }; // Special handling hardcoded further below
	table style rules[freeze columns   ,HTML tags] = { Freeze, Columns };
	table style rules[freeze columns   ,HTML attr] = { '$' }; // Special handling hardcoded further below

	// Comments are not supported yet in HTML


	table style rules[font name    	   , choices ] = { literal };
	table style rules[font name	   , XML tags] = { Style, Font };
	table style rules[font name    	   , XML attr] = { 'ss:FontName="$"' };
	table style rules[font name 	   ,HTML tags] = { Style, Font Name };
	table style rules[font name 	   ,HTML attr] = { 'font-family:$' }; // Dollar symbol denotes value placeholder


	table style rules[font size    	   , choices ] = { numeral 1 or bigger, 1};
	table style rules[font size	   , XML tags] = { Style, Font };
	table style rules[font size    	   , XML attr] = { 'ss:Size="$"' };
	table style rules[font size 	   ,HTML tags] = { Style, Font Size };
	table style rules[font size 	   ,HTML attr] = { 'font-size:$pt' }; // Dollar symbol denotes value placeholder
	
	table style rules[number format	   , choices ] = { literal };
	table style rules[number format	   , XML tags] = { Style, NumberFormat };
	table style rules[number format	   , XML attr] = { 'ss:Format = "$"' };
	table style rules[number format    ,HTML tags] = { Style, Number Format };
	table style rules[number format	   ,HTML attr] = { 'vnd.ms-excel.numberformat:$' }; // Dollar symbol denotes value placeholder


	table style rules[type             , choices ] = { choices, { default, literal, numeral, boolean } };
	table style rules[type             , XML tags] = { Data };
	table style rules[type             , XML attr] = { '$', { '', 'ss:Type="String"', 'ss:Type="Number"', 'ss:Type="Boolean"' } };
	table style rules[type             ,HTML tags] = { Style, Number Format };
	table style rules[type		   ,HTML attr] = { 'vnd.ms-excel.numberformat:$', { "", "@", "", "" } }; 


	table style rules[horizontal align , choices ] = { choices, { automatic, left, middle, right  } };	
	table style rules[horizontal align , XML tags] = { Style, Alignment };
	table style rules[horizontal align , XML attr] = { 'ss:Horizontal="$"', { Automatic, Left, Center, Right }   };
	table style rules[horizontal align ,HTML tags] = { Style, Horizontal Align };
	table style rules[horizontal align ,HTML attr] = { 'text-align:$', { initial, left, center, right } }; // Dollar symbol denotes value placeholder


	table style rules[vertical   align , choices ] = { choices, { automatic, top, center, bottom } };
	table style rules[vertical   align , XML tags] = { Style, Alignment };
	table style rules[vertical   align , XML attr] = { 'ss:Vertical="$"', { Automatic, Top, Center, Bottom }   };
	table style rules[vertical   align ,HTML tags] = { Style, Vertical Align };
	table style rules[vertical   align ,HTML attr] = { 'vertical-align:$', { baseline, top, middle, bottom } }; // Dollar symbol denotes value placeholder


	table style rules[column width     , choices ] = { column width }; // Takes numbers >= 1 or 'automatic'
	table style rules[column width     , XML tags] = { Column };
	table style rules[column width     , XML attr] = { 'ss:Width="$" ss:AutoFitWidth="@"' };
	table style rules[column width     ,HTML tags] = { Column, Width };
	table style rules[column width     ,HTML attr] = { 'width="$"' };


	table style rules[row height       , choices ] = { numeral 1 or bigger, 1 };
	table style rules[row height       , XML tags] = { Row };
	table style rules[row height       , XML attr] = { 'ss:Height="$"' };
	table style rules[row height       ,HTML tags] = { Row, Height };
	table style rules[row height       ,HTML attr] = { 'height="$"' };


	table style rules[hidden row	   , choices ] = { boolean };
	table style rules[hidden row	   , XML tags] = { Row };				// Will be replaced to "Row" or "Column" in 'table style row' / 'table style column' accordingly
	table style rules[hidden row	   , XML attr] = { 'ss:Hidden="$"', { '0','1' } };	// Dollar symbol denotes value placeholder
	table style rules[hidden row	   ,HTML tags] = { Row, Height };
	table style rules[hidden row	   ,HTML attr] = { '$',{ '', 'height="0"' } }; 		// Not active yet.

	table style rules[hidden column	   , choices ] = { boolean };
	table style rules[hidden column	   , XML tags] = { Column };				// Will be replaced to "Row" or "Column" in 'table style row' / 'table style column' accordingly
	table style rules[hidden column	   , XML attr] = { 'ss:Hidden="$"', { '0','1' } };	// Dollar symbol denotes value placeholder
	table style rules[hidden column	   ,HTML tags] = { Column, Width };
	table style rules[hidden column	   ,HTML attr] = { '$',{ '', 'width="0"' } }; 		// Not active yet.


	table style rules[autofilter       , choices]  = { autofilter row position };
	table style rules[autofilter       , XML tags] = { AutoFilter };
	table style rules[autofilter       , XML attr] = { 'x:Range="$"' };
	table style rules[autofilter       ,HTML tags] = { Autofilter, Autofilter };
	table style rules[autofilter       ,HTML attr] = { 'filter=all' };

	table style rules[gridlines 	   , choices ] = { boolean excel only }; // Only supported for Excel 2013+ (Modern format) only
	table style rules[gridlines	   , XML tags] = { Grid };
	table style rules[gridlines  	   , XML attr] = {  };
	table style rules[gridlines	   ,HTML tags] = { Grid };
	table style rules[gridlines        ,HTML attr] = {  };


//	table style rules[horizontal merge , choices] = { integer 2 or bigger };
//	table style rules[vertical   merge , choices] = { integer 2 or bigger };


	for all parameters ( { 	text color, fill color, underscore, boldface, italic, strikeout, wrap text,
				font name, font size, number format, type, horizontal align, vertical align, 
				top border, bottom border, left border, right border, borders }, par[] )
	{
		table style rules[ par[], scopes] = { table, row, column, cell };
	}
	delete (par[]);

	table style rules[ column width    , scopes] = { table, column };
	table style rules[ row height      , scopes] = { table, row };
	table style rules[ comment         , scopes] = { cell  };
	table style rules[ autofilter      , scopes] = { table  };
	table style rules[ gridlines	   , scopes] = { table  };
	table style rules[ freeze rows     , scopes] = { table  };
	table style rules[ freeze columns  , scopes] = { table  };
	table style rules[ hidden          , scopes] = { row, column  };
	table style rules[ hidden row      , scopes] = { row  };
	table style rules[ hidden column   , scopes] = { column  };

//	table style rules[ horizontal merge, scopes] = { cell  };
//	table style rules[ vertical merge  , scopes] = { cell  };


	// 
	// Definition of global variable 'table style descriptions'
	// 
	// Will be handled as a multi-level structure.
	//
	// table style descriptions = global style counter (numeral)
	//
	// Step 0:	Create space for a particular table
	// table name
	//
	//	Step 1: The items below contain the generic descriptions
	//	
	//      'table' ->
	//      'row'
	//        '0','1','2',.. ->
	//      'column'
	//          '0','1','2',.. ->
        //      'cell'
	//        '0','1','2',..	(rows)
	//          '0','1','2',.. ->	(columns)
        //          
	//          ->  generic attribute name		= generic attribute value
        //          
	//
	//      Step 2: The procedure 'translate style attributes for excel xml 2003' generates following structure with XML tags:
	//
        //	'HTML'          
	//	    'table' ->
	//	    'row'
	//            '0','1','2',.. ->
	//	    'column'
	//              '0','1','2',.. ->
	//	    'cell'
	//            '0','1','2',..
	//              '0','1','2',.. ->
	//
	//		->  Row		= Final reference, e.g. style="text-color:#00FF00"
	//			Width
	//			Autofilter
	//		    Column 	= Final reference, e.g. style="width:123pt"
	//			Height
	//		    Style	= Final reference, e.g. style="text-color:#00FF00"
	//			Text Color, Fill Color, Bolface, etc.blanks
	//		    Autofilter	= Activate autofilter for this cell
	//		    Comment	= Comment text
	//		    
	//			    
	//
	//	    'comment'  (HTML to Excel requires a dedicated comment management)
	//		'Comment0000', 'Comment0001', ... -> { Row number, Column Number, Text } // Parameter Set
	//		
	//
        //	'XML'          
	//	    'table' ->
	//	    'row'
	//            '0','1','2',.. ->
	//	    'column'
	//              '0','1','2',.. ->
	//	    'cell'
	//            '0','1','2',..
	//              '0','1','2',.. ->
	//
	//		->  Row		= Final reference, e.g. Height="10"
	//		    Column
	//		    Style	= Final reference, e.g. ss:ID="St3"
	//			Font		= All font related attributes, alphabetic order, separated by blanks
	//			Alignment	= All alignment related attributes, ", "
	//			Numberformat	= All numberformat related attributes, ", "
	//			Interior	= All cell interior related attributes, ", "
	//			Border		= All cell border related attributes
	//		    Comment		= All references to comments
	//		    Data		= All references to data (is string, number, date)
 	//		    Freeze
	//			Row		Row number
	//			Column		Column number
	//			    
	//	    'styles'	= Final style string, (Step 3), in format of <Styles> ... </Styles>,  ready for direct insertion
	//		...	= St1		Var name is <Style ... /> (The ... contents)
	//		...	= St1		Var name is <Style ... /> (The ... contents)	//
	//
	//


	release( table style rules[]);
	delete ( table style rules[]);

	global() table style descriptions[] = 0; // Initialize as global variable.   Value is global style counter (for <Styles> ... )







	define procedure( __ verify generic attributes __, { { target, literal}, {parameter number, numeral}, { generic attribute name, literal }, 
			 { generic attribute value, valid, io }} ) 
	{
	    table style rules[] =^ libraries[style library,table style rules];

	    if ( identify( table style rules[ generic attribute name[] ] ) == 'not found')
	    {
		exception( stop, compose(parameter number[], ". Parameter (Attribute Name) = '",generic attribute name[], "' is invalid." ), 2);
	    }

	    generic attribute choice specifier[] = table style rules[ generic attribute name[], choices] {0};


	    switch( generic attribute choice specifier[] )			
	    {

		case (boolean, boolean excel only) 
		{
		    if ( type(generic attribute value[]) != 'boolean' )
		    {
			exception( stop, compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid. A Boolean 'true' or 'false' expected." ), 2);
		    }					
		}

		case (literal)
		{
		    if ( type(generic attribute value[]) != 'literal' )
		    {
			exception( stop, compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid. A literal value is expected." ), 2);
		    }					
		}

		case (choices)
		{
		    if ( find( table style rules[ generic attribute name[], choices] {1}, generic attribute value[]) < 0)
		    {
			exception( stop, compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid.", new line,
				   "Following choices are valid: ", table style rules[generic attribute name[], choices] {1} ), 2);
		    }
		}


		case (border spec)
		{
		    message[] = compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid. ", new line,
				"A parameter set containing 2 elements {border thickness and color} is expected");

		    if (type(generic attribute value[]) != parameter set)	exception( stop, message[], 2);
		    if (generic attribute value[]{} != 2)			exception( stop, message[], 2);


		    if ( find( table style rules[ generic attribute name[], choices] {1}, generic attribute value[]{0}) < 0)
		    {
			exception( stop, compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid. ", new line,
					 "The 1st value in tuple must be one of ", table style rules[generic attribute name[], choices] {1} ), 2);
		    }

		    a[] = generic attribute value[]{1}; msg[] = check and translate color( a[] ); generic attribute value[]{1} = a[]; 

		    if (msg[] != "")
		    {
			exception( stop, compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid. ", new line,
					 "The 2nd value (color) is invalid. ", new line, msg[] ), 2);
		    }
		}

		case (colors)
		{
		    msg[] = check and translate color( generic attribute value[] );
		    if (msg[] != "")
		    {
			exception( stop, compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid. ", new line,
					 "The 2nd value (color) is invalid. ", new line, msg[] ), 2);
		    }
		}

		case (numeral 1 or bigger, column width)
		{
		    message[] = compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid. A numeral bigger than 1 or 'automatic' is expected." );
		    if ( type(generic attribute value[]) != 'numeral' )
		    {
			if (generic attribute value[] != 'automatic')		exception( stop, message[], 2);
		    }					
		    if ( generic attribute value[] < 1 )			exception( stop, message[], 2);
		}

		case (integer 0 or bigger, integer 2 or bigger)
		{
		    minimum[] = clean numeral(	generic attribute choice specifier[] );
		    message[] = compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid. An integer bigger than ", minimum[], " is expected." );
		    if ( type(generic attribute value[]) != 'numeral' )					exception( stop, message[], 2);
		    if ( (generic attribute value[] < minimum[]) | !whole(generic attribute value[]) )	exception( stop, message[], 2);
		}

		case (autofilter row position)
		{
		    message[] = compose(parameter number[]+1, ". Parameter (Attribute Value) = '",generic attribute value[], "' is invalid. A positive integer is expected." );
		    if ( type(generic attribute value[]) != 'numeral' )					exception( stop, message[], 2);
		    if ( (generic attribute value[] < 0) | !whole(generic attribute value[]) )		exception( stop, message[], 2);
		}
	    }	
	}


	define procedure( __ verify scope __, { { target, literal}, {parameter number, numeral}, { generic attribute name, literal } } ) 
	{
	    table style rules[] =^ libraries[style library,table style rules];
	    if ( find( table style rules[ generic attribute name[], scopes], target[]) < 0)
	    {
		names[] = join("table style " +^ table style rules[ generic attribute name[], scopes], ", ");
		substitute( names[], row, rows);  // Make plural because function names use plural terms.
		substitute( names[], column, columns);
		exception( stop, compose(parameter number[], ". Parameter (Attribute Name) = '",generic attribute name[], "' is invalid for this function call.", new line,
		  	   "This attribute is allowed for following functions only: ", names[] ), 2);
	    }					

	}


	// Function:	table style table
	//
	// Description:	Supply style related information applicable to the entire table
	//		Before doing this, the parameter conents are checked for correctness first.
	//
	// Parameters:	table name	Name of table to apply stylish formatting
	//		coverage	sheet	  = style apples across entire sheet (incl. beyond end of table)
	//				table     = style applies until last table column acc. to headers
	//				body	  = style applies to entire table except the header row.
	//		parameter 3	Generic Attribute Name (applies to following even numbererd parameters)
	//		parameter 4	Generic Attribute Value Blue (applies to following odd numbererd parameters)
	//
	// Return val:	not applicable


	define procedure( table style table, { { table name, literal }, { coverage, literal }, { parameter 3, literal }, { parameter 4, valid } }, 4, unlimited, 2 )
	{
	    table style rules[] =^ libraries[style library,table style rules];
	    global() table style descriptions[ table name[] ] = 0; // Introduce the new table name if not yet existing.
	    my table[] =^ table style descriptions[ table name[] ]; // Create a reference

	    if ( find( { sheet, table, body }, coverage[] ) < 0)
	    {
		exception( stop, compose( "2. Parameter (Coverage) = '",coverage[], "' is invalid.  Valid choices: sheet, table, body" ), 1);
	    }

	    for (i[] = 3, i[] <= parameter count[], i[]+=2)
	    {

		// Verify that a correct generic attribute name has been chosen

		generic attribute name[] = ('parameter ' + literal(i[]))[];
		generic attribute value[] = ('parameter ' + literal(i[]+1))[];

		__ verify generic attributes __( table, i[], generic attribute name[], generic attribute value[] );
		__ verify scope __( table, i[], generic attribute name[] );

		if (generic attribute name[] = borders) // Special case: Border around all 4 sides
		{
		    table style table( table name[], coverage[],
			top    border, generic attribute value[], 
			bottom border, generic attribute value[], 
			left   border, generic attribute value[], 
			right  border, generic attribute value[] );
		    continue loop;
		}


		process cells individually[] = table style rules[ generic attribute name[], XML tags]{0} = Data;
		process cells collectively[] = table style rules[ generic attribute name[], XML tags]{0} = AutoFilter;

		process cols individually[]  = table style rules[ generic attribute name[], XML tags]{0} = Column;
		process rows individually[]  = table style rules[ generic attribute name[], XML tags]{0} = Row;

		if (generic attribute name[] = 'row height','column width') // Special case needed for Excel
		{
			 my table[ table, generic attribute name[] ] = generic attribute value[];
		}

		if (process cols individually[])
		{
		    col count[] = table max width( table name[] );
		    for (c[] = 0, c[] < col count[], c[]++)
		    {
			my table[ column, literal(c[],"00000000"), generic attribute name[] ] = generic attribute value[];
		    }
		    continue loop;
		}

		if (process rows individually[])
		{
		    row count[] = table length( table name[] );
		    for (r[] = abs(coverage[]=body), r[] < row count[], r[]++)
		    {
			my table[ row, literal(r[],"00000000"), generic attribute name[] ] = generic attribute value[];
		    }
		    continue loop;
		}


		if ( ( (coverage[] == sheet ) | process cells collectively[] ) & !process cells individually[])
		{
		    my table[ table, generic attribute name[] ] = generic attribute value[];
		}
		else
		{
		    col count[] = table max width( table name[] );
		    row count[] = table length( table name[] );

		    for (r[] = abs(coverage[]=body), r[] < row count[], r[]++)
			for (c[] = 0, c[] < col count[], c[]++)
			{
			    my table[ cell, literal(r[],"00000000"), literal(c[],"00000000"), generic attribute name[] ] = generic attribute value[];
			}
		}


	    }
	}


	// Function:	table style rows
	//
	// Description:	Supply style related information applicable 1 or more selected rows
	//		Before doing this, the parameter conents are checked for correctness first.
	//
	// Parameters:	table name	Name of table to apply stylish formatting
	//		rows		Row number(s)
	//		columns		Column number(s) or column header names
	//		coverage	sheet	  = style apples across entire row in entire sheet(incl. beyond end of table)
	//				table     = style applies until last table column acc. to headers
	//				body	  = style applies until last table column in current row
	//		parameter 4	Generic Attribute Name (applies to following odd numbererd parameters)
	//		parameter 5	Generic Attribute Value Blue (applies to following even numbererd parameters)
	//
	// Return val:	not applicable


	define procedure( table style rows, { { table name, literal }, { rows, numerals }, { coverage, literal }, { parameter 4, literal }, { parameter 5, valid } }, 5, unlimited, 2 )
	{
	    table style rules[] =^ libraries[style library,table style rules];
	    global() table style descriptions[ table name[] ] = 0; // Introduce the new table name if not yet existing
	    my table[] =^ table style descriptions[ table name[] ]; // Create a reference

	    if ( find( { sheet, table, body }, coverage[] ) < 0)
	    {
		exception( stop, compose( "3. Parameter (Coverage) = '",coverage[], "' is invalid.  Valid choices: sheet, table, body" ), 1);
	    }

	    for (i[] = 4, i[] <= parameter count[], i[]+=2)
	    {

		// Verify that a correct generic attribute name has been chosen

		generic attribute name[] = ('parameter ' + literal(i[]))[];
		generic attribute value[] = ('parameter ' + literal(i[]+1))[];

		if (generic attribute name[] = hidden) generic attribute name[] = hidden row;	// Exception

		__ verify generic attributes __( row, i[], generic attribute name[], generic attribute value[] );
		__ verify scope __( row, i[], generic attribute name[] );

		if (generic attribute name[] = borders) // Special case: Border around all 4 sides
		{
		    table style rows( table name[], rows[], coverage[],
			top    border, generic attribute value[], 
			bottom border, generic attribute value[], 
			left   border, generic attribute value[], 
			right  border, generic attribute value[] );
		    continue loop;
		}


		process cells individually[] = table style rules[ generic attribute name[], XML tags]{0} = Data;

		if ( ( (coverage[]==sheet) | ( find(table style rules[ generic attribute name[], scopes],cell)<0) ) & !process cells individually[] ) // 2nd term catches row height format
		{
		    for all parameters(rows[], row[])
		    {
			my table[ row, literal(row[],"00000000"), generic attribute name[] ] = generic attribute value[];
			// Literal formatting with leading blanks enforces numbers in order of increasing numbers
		    }
		}
		else
		{
		    for all parameters(rows[], row[])
		    {
		        col count[] = table row width( table name[], select if( coverage[]==body, row[], 0 ) );
			for (column[]=0, column[]<col count[], column[]++)
			{
			    my table[ cell, literal(row[],"00000000"), literal(column[],"00000000"), generic attribute name[] ] = generic attribute value[];
			}
		    }

		}

	    }

	}


	// Function:	table style columns
	//
	// Description:	Supply style related information applicable 1 or more selected columns
	//		Before doing this, the parameter conents are checked for correctness first.
	//
	// Parameters:	table name	Name of table to apply stylish formatting
	//		columns		Column number(s) or column header names
	//		coverage	sheet     = style apples across entire column (incl. beyond end of table)
	//				table     = style applies until last table row
	//				body	  = style applies to all rows except 0 (headers)
	//		parameter 3	Generic Attribute Name (applies to following odd numbererd parameters)
	//		parameter 4	Generic Attribute Value Blue (applies to following even numbererd parameters)
	//
	// Return val:	not applicable


	define procedure( table style columns, { { table name, literal }, { columns, columns }, 
		{ coverage, literal }, { parameter 4, literal }, { parameter 5, valid } }, 5, unlimited, 2 )
	{
	    table style rules[] =^ libraries[style library,table style rules];
	    global() table style descriptions[ table name[] ] = 0; // Introduce the new table name if not yet existing.
	    my table[] =^ table style descriptions[ table name[] ]; // Create a reference


	    if ( find( { sheet, table, body}, coverage[] ) < 0)
	    {
		exception( stop, compose( "3. Parameter (Coverage) = '",coverage[], "' is invalid.  Valid choices: sheet, table, body" ), 1);
	    }


	    for (i[] = 0, i[] < columns[]{}, i[]++)
	    {
		header[] = columns[]{i[]};
		columns[]{i[]} = table column number( table name[], columns[]{i[]} );
		if (columns[]{i[]} < 0)
		{
		    exception( stop, compose( "2. Parameter (Columns):  Header name '", header[], "' is invalid or not existing." ), 1);
		}
	    }


	    for (i[] = 4, i[] <= parameter count[], i[]+=2)
	    {

		// Verify that a correct generic attribute name has been chosen

		generic attribute name[] = ('parameter ' + literal(i[]))[];
		generic attribute value[] = ('parameter ' + literal(i[]+1))[];


		if (generic attribute name[] = hidden) generic attribute name[] = hidden column;	// Exception


		__ verify generic attributes __( column, i[], generic attribute name[], generic attribute value[] );
		__ verify scope __( column, i[], generic attribute name[] );


		if (generic attribute name[] = borders) // Special case: Border around all 4 sides
		{
		    table style columns( table name[], columns[], coverage[],
			top    border, generic attribute value[], 
			bottom border, generic attribute value[], 
			left   border, generic attribute value[], 
			right  border, generic attribute value[] );
		    continue loop;
		}


		process cells individually[] = table style rules[ generic attribute name[], XML tags]{0} = Data;

		if ( ( (coverage[]==sheet) | ( find(table style rules[ generic attribute name[], scopes],cell)<0) ) & !process cells individually[] ) // 2nd term catches column width format
		{
		    for all parameters(columns[], column[])
		    {
			my table[ column, literal(column[],"00000000"), generic attribute name[] ] = generic attribute value[];
			// Literal formatting with leading blanks enforces numbers in order of increasing numbers
		    }
		}
		else
		{
		    row count[] = table length( table name[] );
		    for all parameters(columns[], column[])
		    {
			for (row[]=abs( coverage[]=body ), row[]<row count[], row[]++)
			{
			    my table[ cell, literal(row[],"00000000"), literal(column[],"00000000"), generic attribute name[] ] = generic attribute value[];
			}
		    }

		}
	    }
	}


	// Function:	table style cells
	//
	// Description:	Supply style related information applicable 1 or more selected rows intersecting with 1 or more selected columns
	//		Before doing this, the parameter conents are checked for correctness first.
	//
	// Parameters:	table name	Name of table to apply stylish formatting
	//		columns		Column number(s) or column header names
	//		rows		Row number(s)
	//		coverage	single	= Single locations to be formatted
	//				matrix  = Formats all intersections of specified rows and columns
	//				field   = Pairs of two X and Y constitute fields.  2nd coordinate must be bigger
	//				If true:  Contains set of (rows,columns) coordinate to address individual cells
	//		parameter 5	Generic Attribute Name (applies to following odd numbererd parameters)
	//		parameter 6	Generic Attribute Value Blue (applies to following even numbererd parameters)
	//
	// Return val:	not applicable


	define procedure( table style cells, { { table name, literal }, { columns, columns }, { rows, numerals }, { coverage, literal },
			{ parameter 5, literal }, { parameter 6, valid } }, 4, unlimited, 2 )
	{
	    table style rules[] =^ libraries[style library,table style rules];
	    global() table style descriptions[ table name[] ] = 0; // Introduce the new table name if not yet existing.
	    my table[] =^ table style descriptions[ table name[] ]; // Create a reference


	    if ( find( { single, matrix, field }, coverage[] ) < 0)
	    {
		exception( stop, compose( "4. Parameter (Coverage) = '",coverage[], "' is invalid.  Valid choices: single, matrix, field" ), 1);
	    }

	    if ( coverage[] == single )
	    {
		if  ( rows[]{} <> columns[]{} )
		{
		    exception( stop, compose( "2. Parameter (Columns) contains ", columns[]{}, " columns and 3. Parameter (Rows) contains ", rows[]{}, " rows", new line,
				"When using 'single' in the 4. Parameter, mumber of rows and columns specified must be equal"), 1 );
		}
	    }


	    if ( coverage[] == field )
	    {
		if  ( odd(columns[]{}) )
		{
		    exception( stop, compose( "2. Parameter (Columns) contains ", columns[]{}, " columns which is an odd number", new line,
				"When using 'field' in the 4. Parameter, number of columns (and rows) must be even and equal." ), 1);
		}
		if  ( odd(rows[]{}) )
		{
		    exception( stop, compose( "3. Parameter (Rows) contains ", rows[]{}, " rows which is an odd number", new line,
				"When using 'field' in the 4. Parameter, number of rows (and columns) must be even and equal." ), 1);
		}
		if  ( rows[]{} <> columns[]{} )
		{
		    exception( stop, compose( "2. Parameter (Columns) contains ", columns[]{}, " columns and 3. Parameter (Rows) contains ", rows[]{}, " rows", new line,
				"When using 'field' in the 4. Parameter, mumber of rows and columns specified must be equal"), 1 );
		}

	    }


	    for (i[] = 0, i[] < columns[]{}, i[]++)
	    {
		header[] = columns[]{i[]};
		columns[]{i[]} = table column number( table name[], columns[]{i[]} );
		if (columns[]{i[]} < 0)
		{
		    exception( stop, compose( "2. Parameter (Columns):  Header name '", header[], "' is invalid or not existing." ), 1);
		}
	    }

	    for (i[] = 0, i[] < rows[]{}, i[]++)
	    {
		if (rows[]{i[]} < 0) 
		{
		    rows[]{i[]} += table length(table name[]);
		}
	    }

	    for (i[] = 5, i[] <= parameter count[], i[]+=2)
	    {

		// Verify that a correct generic attribute name has been chosen

		generic attribute name[] = ('parameter ' + literal(i[]))[];
		generic attribute value[] = ('parameter ' + literal(i[]+1))[];

		__ verify generic attributes __( cell, i[], generic attribute name[], generic attribute value[] );
		__ verify scope __( cell, i[], generic attribute name[] );

		if (generic attribute name[] = borders) // Special case: Border around all 4 sides
		{
		    table style cells( table name[], columns[], rows[], coverage[],
			top    border, generic attribute value[], 
			bottom border, generic attribute value[], 
			left   border, generic attribute value[], 
			right  border, generic attribute value[] );
		    continue loop;
		}

		if (coverage[]==matrix)
		{
		    for all parameters(rows[], row[])
		    {
			for all parameters(columns[], column[])
			{
			    my table[ cell, literal(row[],"00000000"), literal(column[],"00000000"), generic attribute name[] ] = generic attribute value[];
			    // Literal formatting with leading blanks enforces numbers in order of increasing numbers
			}
		    }
		}
		else : if (coverage[]==single)
		{
		    for all parameters( rows[], row[], j[] )
		    {
			column[] = columns[]{j[]};
			my table[ cell, literal(row[],"00000000"), literal(column[],"00000000"), generic attribute name[] ] = generic attribute value[];
		    }
		}
		else
		{
		    {
			for (j[] = 0, j[] < rows[]{}, j[] ++ ++ )
			{
			    for (r[] =  rows[]{j[]}, r[] <= rows[]{j[]+1}, r[]++)
			    {
				for (c[] = columns[]{j[]}, c[] <= columns[]{j[]+1}, c[]++)
				    my table[ cell, literal(r[],"00000000"), literal(c[],"00000000"), generic attribute name[] ] = generic attribute value[];

			    }
			} 
		    }
		}
	    }

	}





	// Function:	table deploy row and column styles to cells html
	//
	//		
	// Description:	For HTML:
	//		Step 1:	Apply the row formats on every cell (if not yet done)
	//		Step 2: Apply the column formats on every cell (if not yet done)
	//		Step 3: Apply row, column and background format on every cell if not yet done so.
	//		Ruling is: Cell overlays row, then column
	//
	// Parameters:	table name	Name of table to apply stylish formatting
	//
	// Return val:	not applicable


	define procedure( __ table deploy row and column styles to cells for html __, { { table name, literal } } )
	{

	    my table[] =^ table style descriptions[ table name[] ];
	    my html table[] =^ my table[HTML];

	    // Step 1: Apply row formats on every cell

	    for all variables if existing( my table[ column], placeholder1[], column[], given column number[] )
	    {
		l[] = table length( table name[] );
		for (row[] = 0, row[] < l[], row[]++ )
		{
		    given row number[] = literal( row[],"00000000" );

 		    if (existing( my table[ row, given row number[]])) // Row formatting supercedes column formatting
		    {
			my table[ cell, given row number[], given column number[] ] +<== my table[ row, given row number[] ];
		    }
		    my table[ cell, given row number[], given column number[] ] +<== my table[ column, column[] ];
		}
	    }

	    // Step 2: Apply autofilter on every cell in corresponding row

	    if (existing( my table[ table, autofilter ] ) )
	    {
		given row number[] = literal( my table[ table, autofilter ] ,"00000000" ); // Autofilter row number

		w[] = table max width( table name[] );
		for ( column[] = 0, column[] < w[], column[]++)
		{
		    given column number[] = literal( column[],"00000000" );
		    my table[ cell, given row number[], given column number[], autofilter ] = true;
		}
	    }

	    // Step 3: Collect all comments and store them separately

	    comment counter[] = 0;
	    for all variables if existing( my table[ cell], placeholder1[], row[], given row number[] )
	    {
	        for all variables if existing( my table[ cell, row[]], placeholder2[], column[], given column number[] )
		{
		    if (existing( my table[ cell, row[], column[], comment ] ) ) // Register the comment
		    {
			comment counter[]++;
			comment id[] = "Comment" + literal(comment counter[], "0000");
			my html table[ comment, comment id[] ] =
			  { numeral(given row number[]), numeral(given column number[]), my table[ cell, row[], column[], comment ] };

		    }
		}
	    }

	    if (existing(my html table[ comment] ) )
	    {
		my html table[ comment] = libraries[style library,table style html comments,building block 1];

	        for all variables if existing( my html table[ comment], placeholder1[], comment index[], comment id[]) // Build the comment block
		{
		    temp[] = libraries[style library,table style html comments,building block 2];
		    substitute ( temp[], '$1', comment id[] ); // Comment ID
		    substitute ( temp[], '$2', literal( my html table[ comment, comment index[]]{0} ) ); // Column Number
		    substitute ( temp[], '$3', literal( my html table[ comment, comment index[]]{1} ) ); // Row    Number
		    my html table [ comment] += temp[];
		}

		my html table[ comment] += libraries[style library,table style html comments,building block 3];

	        for all variables if existing( my html table[ comment], placeholder1[], comment index[], comment id[]) // Build the comment block
		{
		    temp[] = libraries[style library,table style html comments,building block 4];
		    substitute ( temp[], '$4', comment id[] ); // Comment ID
		    substitute ( temp[], '$5', encode entities(my html table[ comment, comment index[]]{2},true) ); // Comment text
		    my html table[ comment] += temp[];
		}

		my html table[ comment] += libraries[style library,table style html comments,building block 5]; // Closing
	    }

	}




	// Function:	table deploy row and column styles to cells for excel
	//
	//		
	// Description:	For modern Excel (Excel 2013 +)
	//		Step 1:	Apply the table background formats on existing row and column formats if not already specified
	//		Step 2: Apply dedicated format on intersection rows and columns (require separate formatting)
	//		Step 3: Apply row, column and background format on every cell if not yet done so.
	//		Ruling is: Cell overlays row, then column
	//
	// Special cases:
	//		Autofilter and Freeze defined at table level will not be replicated over cells because it's meaningless.
	//
	// Parameters:	table name	Name of table to apply stylish formatting
	//
	// Return val:	not applicable


	define procedure( __ table deploy row and column styles to cells for excel __, { { table name, literal } } )
	{
	    my table[] =^ table style descriptions[ table name[] ];
	    no deploy across rows[]    = { column width, freeze rows, freeze columns, autofilter, gridlines };
	    no deploy across columns[] = { row height,   freeze rows, freeze columns, autofilter, gridlines };

	    w[] = table max width( table name[] );
	    l[] = table length( table name[] );

	    // Step 1: Sheet background to be applied on rows and columns

	    if (existing( my table[ table ] ) )
	    {
		temp my table for rows[]    <== my table[ table ]; // Duplicate table contents and delete unnecessary members
		temp my table for columns[] <== my table[ table ]; // Duplicate table contents and delete unnecessary members
		for all parameters( no deploy across rows[],    a[] ) if (existing( temp my table for rows   [a[]] )) delete ( temp my table for rows   [a[]] );
		for all parameters( no deploy across columns[], a[] ) if (existing( temp my table for columns[a[]] )) delete ( temp my table for columns[a[]] );

		for (c[] = 0, c[] < w[], c[]++)		my table[ column, literal(c[],"00000000") ] +<== temp my table for columns[];
		for (r[] = 0, r[] < l[], r[]++)		my table[ row,    literal(r[],"00000000") ] +<== temp my table for rows[];
	    }

	    // Step 2: Intersecting rows and columns impacting cells


	    // Known issue: Row format not fully covering entire row inside table body _______________________________________________________________________________
	    // Create table with different row widths
	    // Do 'table style row' with background color
	    // Ensure row style supersedes column style

	    for all variables if existing( my table[ row], placeholder2[], row[], given row number[] )
	    {
//		echo("Row: ", row[], "   given row number: ", given row number[] );
		for( col[] = 0, col[] < w[], col[]++ )
		{
		    my table[ cell, given row number[], literal(col[],"00000000") ] +<== my table[ row, row[] ];
		}
	    }


	    for all variables if existing( my table[ column], placeholder2[], col[], given col number[] )
	    if (member count( my table[ column, col[] ]) > 0 )
	    {
//		echo("Column: ", col[], "   given col number: ", given col number[] );
		for( row[] = 0, row[] < l[], row[]++ )
		{
		    my table[ cell, literal(row[],"00000000"), given col number[] ] +<== my table[ column, col[] ];
		}
	    }


	    // Take care of the remaining columns beyond end of table

	    if (existing( my table[ table ])) my table[ column, literal(w[],"00000000") ] +<== temp my table for columns[];

	    // Step 3 not needed as needed for Excel 2003 XML
	}





	// Function:	table deploy row and column styles to cells for excel 2003 xml
	//
	//		
	// Description:	For XML for Excel:
	//		Step 1:	Apply the table background formats on existing row and column formats if not already specified
	//		Step 2: Apply dedicated format on intersection rows and columns (require separate formatting)
	//		Step 3: Apply row, column and background format on every cell if not yet done so.
	//		Ruling is: Cell overlays row, then column
	//
	// Special cases:
	//		Autofilter and Freeze defined at table level will not be replicated over cells because it's meaningless.
	//
	// Parameters:	table name	Name of table to apply stylish formatting
	//
	// Return val:	not applicable


	define procedure( __ table deploy row and column styles to cells for excel 2003 xml __, { { table name, literal } } )
	{

	    my table[] =^ table style descriptions[ table name[] ];
	    no deploy[] = { freeze rows, freeze columns, autofilter };


	    // Step 1: Sheet background to be applied on rows and columns


	    if (existing( my table[ table ] ) )
	    {
		temp my table[] <== my table[ table ]; // Duplicate table contents and delete unnecessary members
		for all parameters( no deploy[], a[] ) if (existing( temp my table[a[]] )) delete ( temp my table[a[]] );

	    	for all variables if existing( my table[ column], placeholder[], column[], given column number[] )
		    my table[ column, column[] ] +<== temp my table[];

		for all variables if existing( my table[ row], placeholder[], row[], given row number[] )
		    my table[ row, row[] ] +<== temp my table[];
	    }

	    // Step 2: Intersecting rows and columns impacting cells


	    for all variables if existing( my table[ column], placeholder1[], column[], given column number[] )
		for all variables if existing( my table[ row], placeholder2[], row[], given row number[] )
		{
		    my table[ cell, given row number[], given column number[] ] +<== my table[ row, row[] ];
		    my table[ cell, given row number[], given column number[] ] +<== my table[ column, column[] ];
		}


	    // Step 3: All the formatted cells also need to be under-drawn


	    // Bug identified: Sticks at row number 0.


	    for all variables if existing( my table[ cell ], placeholder1[], row[], given row number[] )
		for all variables if existing( my table[ cell, row[]], placeholder2[], column[], given column number[] )
		{
		    if (existing(my table[ row, given row number[] ]))
		    {
		    	my table[ cell, given row number[], given column number[] ] +<== my table[ row, given row number[] ];
		    }
		    if (existing(my table[ column, given column number[] ]))
		    {
		    	my table[ cell, given row number[], given column number[] ] +<== my table[ column, given column number[] ];
		    }
		    if (existing(my table[ table ]))
		    {
		    	my table[ cell, given row number[], given column number[] ] +<== temp my table[];
		    }
		}
	}


	// Function:	translate one attribute to html
	//
	// Description:	This function translates generic style attributes into single HTML specific assignments.
	//		
	//
	// Parameters:	table name	Name of table
	//
	// Return val:	not applicable


	define procedure( translate one attribute to html, { { table name, literal }, 
			{ generic attribute name, literal }, { generic attribute value, valid }, { html attribute element, literal, io } } )
	{

	    table style rules[] =^ libraries[style library,table style rules];
	    html attribute element[] = table style rules[ generic attribute name[], HTML attr ] {0};


	    switch( table style rules[ generic attribute name[], choices ] {0} )
	    {

		case( choices )
		{
		    new attribute value[] = table style rules[ generic attribute name[], HTML attr ] {1} { 
				find( table style rules[ generic attribute name[], choices] {1}, generic attribute value[] ) };
		    substitute all( html attribute element[], '$', new attribute value[] );
		}

		case( boolean )
		{
		    new attribute value[] = table style rules[ generic attribute name[], HTML attr ] {1} {abs(generic attribute value[])};
		    substitute all( html attribute element[], '$', new attribute value[] );
		}

		case( colors, literal )
		{
		    substitute all( html attribute element[], '$', generic attribute value[] );
		}

		case( numeral 1 or bigger, integer 2 or bigger, integer 0 or bigger )
		{
		    if (generic attribute name[] == "row height")
		    {
			generic attribute value[] *= 1.33333333 * 1.01; // Still 1% inaccurate from Excel but oK
		    }

		    substitute all( html attribute element[], '$', literal(generic attribute value[]) );
		}
		case (column width)
		{
		    if (generic attribute value[] == automatic)
		    {
			html attribute element[] = ""; // Remove all prior specifications.  Default is automatic.
		    }
		    else
		    {
		        if (generic attribute value[]>255) generic attribute value[] = 255;
			substitute all( html attribute element[], '$', literal( (generic attribute value[] + 0.7380112 ) * 7 ) );
		    }
		}
		case( autofilter row position ) // E.g. table with 5 columns, row 0 translates to R1C1:R1C5
		{
		    null;
		    // No action.  Already taken care in function 'table deploy row and column styles to cells for html'
		    // html attribute element already contains final value

		}
		case (border spec)
		{
		    new attribute value[] = table style rules[ generic attribute name[], HTML attr ] {1} { 
				find( table style rules[ generic attribute name[], choices] {1}, generic attribute value[]{0} ) };

		    substitute all( html attribute element[], '@', new attribute value[] );
		    substitute all( html attribute element[], '$', generic attribute value[]{1} );
		}
	        case ( boolean excel only )
		{
		    html attribute element[] = '';
		    null; // Not supprted in HTML
		}
		else // Not supported
		{
		    null;
//		    exception( stop, compose( "Table style attribute '",generic attribute name[],"' is not supported for HTML."), 2 );
		}

	    }
	}


	// Function:	translate one attribute to xml
	//
	// Description:	This function translates generic style attributes into single XML specific assignments.
	//		
	//
	// Parameters:	table name	Name of table
	//
	// Return val:	not applicable

	define procedure( translate one attribute to xml, { { table name, literal }, 
			{ generic attribute name, literal }, { generic attribute value, valid }, { xml attribute element, literal, io } } )
	{
	    table style rules[] =^ libraries[style library,table style rules];

	    xml attribute element[] = table style rules[ generic attribute name[], XML attr ] {0};
	    switch( table style rules[ generic attribute name[], choices ] {0} )
	    {

		case( choices )
		{
		    new attribute value[] = table style rules[ generic attribute name[], XML attr ] {1} { 
				find( table style rules[ generic attribute name[], choices] {1}, generic attribute value[] ) };
		    substitute all( xml attribute element[], '$', new attribute value[] );
		}

		case( boolean )
		{
		    new attribute value[] = table style rules[ generic attribute name[], XML attr ] {1} {abs(generic attribute value[])};
		    substitute all( xml attribute element[], '$', new attribute value[] );
		}

		case( colors, literal )
		{
		    temp[] = select if (generic attribute name[]==comment, encode entities( generic attribute value[], false ), generic attribute value[] );
		    substitute all( xml attribute element[], '$', temp[] );
		}

		case( numeral 1 or bigger, integer 2 or bigger, integer 0 or bigger )
		{
		    substitute all( xml attribute element[], '$', literal(generic attribute value[]) );
		}
		case (column width)
		{

		    if (generic attribute value[] != automatic)
		    {
			if (generic attribute value[]>255) generic attribute value[] = 255;

			factor[] = compare select( generic attribute value[], 9.08863424477337,
				>= 246,	5.26378013509236,	>=202,	  5.26677578232372,	// A very strange and non-linear relationship between Excel column widths
				>=166,	5.27042602296493,	>=137,	  5.27487096057466,	// and column widths to supply in the XML.
				>=112,	5.28026133965846,	>=92,	  5.28686166633303,
				>=75,	5.29500783222877,	>=62,	  5.30504440272040,
				>=51,	5.31724792254263,	>=42,	  5.33217802100143,
				>=34,	5.35044784290403,	>=28,	  5.37324342105396,
				>=23,	5.40124990202744,	>=19,	  5.43584162143658,
				>=15,	5.47845180211973,	>=12,	  5.53378969911084,
				>=10,	5.60512768786549,	>= 8,	  5.69369629692883,
				>= 7,	5.80989418053962,	>= 6,	  5.84845048760082,
				>= 5,	6.01692436995969,	>= 4,	  6.23515478752299,
				>= 3,	6.54037215474440,	>= 2,	  7.14911969693873,
				>= 0,	9.08863424477337 );

			substitute all( xml attribute element[], '$', literal(generic attribute value[]*factor[]) );
			substitute all( xml attribute element[], '@', '0' ); // Column width not automatic
		    }
		    else
		    {
			substitute all( xml attribute element[], '$', '9.08863424477337' ); // Minimum 1
			substitute all( xml attribute element[], '@', '1' ); // Column width automatic
		    }
		}
		case( autofilter row position ) // E.g. table with 5 columns, row 0 translates to R1C1:R1C5
		{
		    generic attribute value[] = literal(generic attribute value[]+1);
		    new attribute value[] = R + generic attribute value[] + "C1:R" + generic attribute value[] + C + literal(table max width( table name[] ));
		    substitute all( xml attribute element[], '$', new attribute value[] );

		}
		case (border spec)
		{
		    new attribute value[] = table style rules[ generic attribute name[], XML attr ] {1} { 
				find( table style rules[ generic attribute name[], choices] {1}, generic attribute value[]{0} ) };

		    substitute all( xml attribute element[], '@', new attribute value[] );
		    substitute all( xml attribute element[], '$', generic attribute value[]{1} );
		}
	        case ( boolean excel only )
		{
		    xml attribute element[] = '';
		    null; // Not supprted in HTML
		}
		else // Not supported
		{
		    exception( stop, compose( "Table style attribute '",generic attribute name[],"' is not supported for EXCEL XML-2003."), 2 );
		}

	    }
	}


	// Function:	xml register style
	//
	// Description:	This function checks if the style is already registered.  If yes, the reference value is returned.	
	//		Otherwise it will be registered.
	//		
	//
	// Parameters:	xml style tage contents
	//
	// Return val:	Style reference (St1, St2, ... )


	define function( __ xml register style __, { { table name, literal }, { xml style tag contents, literal } } )
	{
	    if ( existing( table style descriptions[ table name[], XML, styles, xml style tag contents[]] ) )
	    {
		style reference[] = table style descriptions[ table name[], XML, styles, xml style tag contents[]];
	    }
	    else // It's a new style
	    {
		style reference[] = "St" + literal( ++table style descriptions[] ); 
		table style descriptions[ table name[], XML, styles, xml style tag contents[]] = style reference[];
	    }
	    return ( style reference[] );
	}



	// Function:	translate style attributes for html
	//
	// Description:	This function translates generic style attributes into single HTML resp. HTML  specific assignments.
	//		
	//
	// Parameters:	table name	Name of table
	//
	// Return val:	not applicable


	// In contrast to XML, cell formatting in HTML are overlapping.

	// Step 1: 	Deploy all row formats on every cell if corresponding format is not yet specified
	// Step 2:	Deploy all column formats on every cell if corresponding format is not yet specified




	define procedure ( translate style attributes for html, { { table name, literal } } )
	{
	    table style rules[] =^ libraries[style library,table style rules];

	    unless( existing(table style descriptions[ table name[] ] ) ) return;  // Nothing formatted.

	    if (existing(table style descriptions[table name[], HTML])) global() delete members( table style descriptions[table name[], HTML] );

	    my table[] =^ table style descriptions[ table name[] ];
	    my table[HTML] = ''; // Create HTML branch
	    my html table[] =^ my table[HTML];


	    __ table deploy row and column styles to cells for html __( table name[] );


	    html attribute element[] = ""; // Initialize variable

	    for all variables if existing( my table[ table ], generic attribute value[], i[], generic attribute name[] ) 
	    {
//		echo("  translate in table: name = ", generic attribute name[], "  value = ", generic attribute value[] );

		translate one attribute to html( table name[], generic attribute name[], generic attribute value[], html attribute element[] );
		html tag[] = table style rules[ generic attribute name[], HTML tags ];

		if (html tag[]{0}==Style)
		{
		    my html table[ table, Style ] += html attribute element[] + "; "; // Introduce the new table name if not yet existing.
		}
	    }	
	    if (existing(my html table[ table, Style]))
	    {
		my html table[ table ] = ' style="' + table style descriptions[ table name[], HTML, table, Style] +'"';
	    }

	    for all variables if existing( my table[ row ], placeholder[], row[], given row number[] ) 
	    {
		for all variables( my table[ row, row[] ], generic attribute value[], i[], generic attribute name[] ) 
		{
//		    echo("  translate in row ", trim(given row number[]), ": name = ", generic attribute name[], "  value = ", generic attribute value[] );

		    translate one attribute to html( table name[], generic attribute name[], generic attribute value[], html attribute element[] );
		    html tag[] = table style rules[ generic attribute name[], HTML tags ];

		    if (html tag[]{0}=Style)
		    {
			my html table[ row, given row number[], Style ] += html attribute element[]  + "; ";
		    }
		    else : if (html tag[]{0}==Row)
		    {
 			my html table[ row, given row number[], Row ] += html attribute element[]  + " ";
		    }
		}
		if (existing(my html table[ row, given row number[],Style]))
		{
		    my html table[ row, given row number[]] = ' style="' + my html table[ row, given row number[],Style] +'" ';
		}
		if (existing(my html table[ row, given row number[],Row]))
		{
		    my html table[ row, given row number[]] += my html table[ row, given row number[],Row] +' ';
		}
	    }

	    for all variables if existing( my table[ column ], placeholder[], column[], given column number[] ) 
	    {	
		for all variables( my table[ column, column[] ], generic attribute value[], i[], generic attribute name[] ) 
		{
//		    echo("  translate in column ", trim(given column number[]), ": name = ", generic attribute name[], "  value = ", generic attribute value[] );

		    translate one attribute to html ( table name[], generic attribute name[], generic attribute value[], html attribute element[] );
		    html tag[] = table style rules[ generic attribute name[], HTML tags ];

		    // The style attribute will not be compared for columns.

		    if (html tag[]{0}==Column)
		    {
 			my html table[ column, given column number[], Column ] += html attribute element[]  + " ";
		    }
		}
		if (existing(my html table[ column, given column number[],Column]))
		{
		    my html table[ column, given column number[]] += my html table[ column, given column number[],Column] +' ';
		}
	    }

	    for all variables if existing( my table[ cell], placeholder[], row[], given row number[] ) 
	    {
		for all variables if existing( my table[ cell, row[] ], placeholder[], column[], given column number[] ) 
		{
		    for all variables( my table[ cell, row[], column[] ], generic attribute value[], i[], generic attribute name[] ) 
		    {
//			echo("  translate in cell ", trim(given row number[]), ", ", trim(given column number[]), ": name = ", generic attribute name[], "  value = ", generic attribute value[] );

			translate one attribute to html ( table name[], generic attribute name[], generic attribute value[], html attribute element[] );
			html tag[] = table style rules[ generic attribute name[], HTML tags ];
			if (html tag[]{0}==Style)
			{
			    my html table[ cell, given row number[], given column number[], Style ] += html attribute element[]  + "; "; // Introduce the new table name if not yet existing.
			}
			else : if (html tag[]{0}==Autofilter)
			{
 			    my html table[ cell, given row number[], given column number[], Autofilter ] += html attribute element[]  + " ";
		        }

		    }
		    if (existing(my html table[ cell, given row number[], given column number[], Style]))
		    {
			my html table[ cell, given row number[], given column number[]] = ' style="' + my html table[ cell, given row number[], given column number[], Style] +'" ';
		    }
		    if (existing(my html table[ cell, given row number[], given column number[], Autofilter]))
		    {
			my html table[ cell, given row number[], given column number[]] += my html table[ cell, given row number[], given column number[], Autofilter] +' ';
		    }
		}
	    }

	}



	// Function:	translate style attributes for excel xml 2003
	//
	// Description:	This function translates generic style attributes into single HTML resp. Excel XML specific assignments.
	//		
	//
	// Parameters:	table name	Name of table
	//
	// Return val:	not applicable


	// For every style related to particular table, row, column or cell:
	// 1.  Create a style string <styles Style ID > ***these contents here*** </stlyes>
	// 2.  Check the styles library to see if the string is already available.  If yes, pick the style number.  If no, store it and assign new style jumber
	//	


	define procedure ( translate style attributes for excel xml 2003, { { table name, literal } } )
	{
	    table style rules[] =^ libraries[style library,table style rules];

	    unless( existing(table style descriptions[ table name[] ] ) ) return;  // Nothing formatted.

	    if (existing(table style descriptions[table name[], XML])) global() delete members( table style descriptions[table name[], XML] );

	    my table[] =^ table style descriptions[ table name[] ];
	    my table[XML] = ''; // Create XML branch
	    my xml table[] =^ my table[XML];

	    __ table deploy row and column styles to cells for excel 2003 xml __( table name[] );


	    xml attribute element[] = ""; // Initialize variable

	    for all variables if existing( my table[ table ], generic attribute value[], i[], generic attribute name[] ) 
	    {
//		echo("  translate in table: name = ", generic attribute name[], "  value = ", generic attribute value[] );

		translate one attribute to xml ( table name[], generic attribute name[], generic attribute value[], xml attribute element[] );
		xml tag[] = table style rules[ generic attribute name[], XML tags ];
		my xml table[ table, xml tag[] ] += xml attribute element[] + " "; // Introduce the new table name if not yet existing.
	    }

	    for all variables if existing( my table[ row], placeholder[], row[], given row number[] ) 
	    {
		for all variables( my table[ row, row[] ], generic attribute value[], i[], generic attribute name[] ) 
		{
//		    echo("  translate in row ", trim(given row number[]), ": name = ", generic attribute name[], "  value = ", generic attribute value[] );

		    translate one attribute to xml ( table name[], generic attribute name[], generic attribute value[], xml attribute element[] );
		    xml tag[] = table style rules[ generic attribute name[], XML tags ];
		    my xml table[ row, given row number[], xml tag[] ] += xml attribute element[] + " "; // Introduce the new table name if not yet existing.

		}
	    }

	    for all variables if existing( my table[ column], placeholder[], column[], given column number[] ) 
	    {	
		for all variables( my table[ column, column[] ], generic attribute value[], i[], generic attribute name[] ) 
		{
//		    echo("  translate in column ", trim(given column number[]), ": name = ", generic attribute name[], "  value = ", generic attribute value[] );

		    translate one attribute to xml ( table name[], generic attribute name[], generic attribute value[], xml attribute element[] );
		    xml tag[] = table style rules[ generic attribute name[], XML tags ];
		    my xml table[ column, given column number[], xml tag[] ] += xml attribute element[] + " "; // Introduce the new table name if not yet existing.

		}
	    }

	    for all variables if existing( my table[ cell], placeholder[], row[], given row number[] ) 
	    {
		for all variables if existing( my table[ cell, row[] ], placeholder[], column[], given column number[] ) 
		{
		    for all variables( my table[ cell, row[], column[] ], generic attribute value[], i[], generic attribute name[] ) 
		    {
//			echo("  translate in cell ", trim(given row number[]), ", ", trim(given column number[]), ": name = ", generic attribute name[], "  value = ", generic attribute value[] );

			translate one attribute to xml ( table name[], generic attribute name[], generic attribute value[], xml attribute element[] );
			xml tag[] = table style rules[ generic attribute name[], XML tags ];
			my xml table [ cell, given row number[], given column number[], xml tag[] ] += xml attribute element[] + " "; // Introduce the new table name if not yet existing.
		    }
		}
	    }



	    // Consolidate the style descriptions

	    // On tables:

	    border detected[] = false;
	    xml style tag contents [] = "";
	    for all variables if existing( my xml table[ table, Style ], style tag value[], placeholder1[], style tag name[] )
	    {	
		if (style tag name[] != Border)
		{
		    xml style tag contents [] += "<" + style tag name[] + " " + style tag value[] + "/>";
		}
		else: border detected[] = true;
	    }
	    if (border detected[]) for all variables if existing( my xml table[ table, Style ], style tag value[], placeholder1[], style tag name[] )
	    {
		if (style tag name[] == Border)
		{
		    xml style tag contents[] += "<Borders>" + new line;
		    for all variables if existing( my xml table[ table, Style, Border ], style tag value 2[]  )
		    {
			xml style tag contents [] += style tag value 2[]; // Complete border spec inside
		    }
		    xml style tag contents[] += "</Borders>" + new line;
		}
	    }
//	    echo("xml style tag contents[] = ", xml style tag contents [] );
	    if (xml style tag contents [] <> "") my xml table[ table, Style ] = 'ss:StyleID="' + __ xml register style __( table name[], xml style tag contents[] ) + '"';


	    
	    // On rows:

	    for all variables if existing( my xml table[ row], placeholder[], row[] ) 
	    {
		my xml row[] =^ my xml table[ row, row[] ];

		border detected[] = false;
		xml style tag contents [] = "";
		for all variables if existing( my xml row[ Style ], style tag value[], placeholder1[], style tag name[] )
		{	
		    if (style tag name[] != Border)
		    {
			xml style tag contents [] += "<" + style tag name[] + " " + style tag value[] + "/>";
		    }
		    else: border detected[] = true;
		}
		if (border detected[]) for all variables if existing( my xml row[ Style ], style tag value[], placeholder1[], style tag name[] )
		{
		    if (style tag name[] == Border)
		    {
			xml style tag contents[] += "<Borders>" + new line;
			for all variables if existing( my xml row[ Style, Border ], style tag value 2[]  )
			{
			    xml style tag contents [] += style tag value 2[]; // Complete border spec inside
			}
			xml style tag contents[] += "</Borders>" + new line;
		    }
		}

//		echo("xml style tag contents[] = ", xml style tag contents [] );
		if (xml style tag contents [] <> "")  my xml row [ Style ] = 'ss:StyleID="' + __ xml register style __( table name[], xml style tag contents[] ) + '"';
	    }



	    for all variables if existing( my xml table[ column], placeholder[], column[] ) 
	    {
		my xml column[] =^ my xml table[ column, column[] ];

		border detected[] = false;
		xml style tag contents [] = "";
		for all variables if existing( my xml column[ Style ], style tag value[], placeholder1[], style tag name[] )
		{	
		    if (style tag name[] != Border)
		    {
			xml style tag contents [] += "<" + style tag name[] + " " + style tag value[] + "/>";
		    }
		    else: border detected[] = true;

		}

		if (border detected[]) for all variables if existing( my xml column[ Style ], style tag value[], placeholder1[], style tag name[] )
		{
		    if (style tag name[] == Border)
		    {
			xml style tag contents[] += "<Borders>" + new line;
			for all variables if existing( my xml column[ Style, Border ], style tag value 2[]  )
			{
			    xml style tag contents [] += style tag value 2[]; // Complete border spec inside
			}
		    	xml style tag contents[] += "</Borders>" + new line;
		    }
		}
//		echo("xml style tag contents[] = ", xml style tag contents [] );
		if (xml style tag contents [] <> "") my xml column[ Style ] = 'ss:StyleID="' + __ xml register style __( table name[], xml style tag contents[] ) + '"';
	    }


	    // On cells:

	    for all variables if existing( my xml table[ cell], placeholder2[], row[] ) 
	    {
		for all variables if existing( my xml table[ cell, row[] ], placeholder[], column[] ) 
		{
		    my xml cell[] =^ my xml table[ cell, row[], column[] ];

		    border detected[] = false;
		    xml style tag contents [] = "";
		    for all variables if existing( my xml cell[ Style ], style tag value[], placeholder1[], style tag name[] )
		    {	
			if (style tag name[] != Border)
			{
			    xml style tag contents [] += "<" + style tag name[] + " " + style tag value[] + "/>";
			}
			else: border detected[] = true;
		    }
		    if (border detected[]) for all variables if existing( my xml cell[ Style ], style tag value[], placeholder1[], style tag name[] )
		    {
			if (style tag name[] == Border)
			{
			    xml style tag contents[] += "<Borders>" + new line;
			    for all variables if existing( my xml cell[ Style, Border ], style tag value 2[]  )
			    {
				xml style tag contents [] += style tag value 2[]; // Complete border spec inside
			    }
			    xml style tag contents[] += "</Borders>" + new line;
			}
		    }
//		    echo("xml style tag contents[] = ", xml style tag contents [] );
		    if (xml style tag contents [] <> "") my xml cell[ Style ] = 'ss:StyleID="' + __ xml register style __( table name[], xml style tag contents[] ) + '"';
		}
	    }

	    // Put together the <Style> ... </Styles> string


	    my xml table[ styles ] = "";
	    for all variables if existing( my xml table [ styles ], style reference[], placeholder[], xml style tag contents[] )
	    {
		my xml table[ styles ]  += '<Style ss:ID="' + style reference[] + '"> ' + xml style tag contents[] + '</Style>' + new line;
	    }
	    my xml table[ styles ]  += new line;


	    // Put together freeze panes info

	    my xml table[ worksheetoptions ] = "";

	    if ( existing( my xml table[table, Freeze] ))
	    {

		my xml table[ worksheetoptions ] += "<FreezePanes/><FrozenNoSplit/>" + new line;
		active pane[] = 0;

		if ( existing( my xml table[table, Freeze, Rows] ))
		{
		    active pane[] = 2;
		    row[] = my xml table[table, Freeze, Rows]; // Row number in literal format
		    if (numeral(row[])>0)
		    {
			my xml table[ worksheetoptions ] += "<SplitHorizontal>"+row[]+"</SplitHorizontal><TopRowBottomPane>"+row[]+"</TopRowBottomPane>" + new line;
		    }
		}

		if ( existing( my xml table[table, Freeze, Columns] ))
		{
		    active pane[] = select if( active pane[]==2, 0, 1 );
		    col[] = my xml table[table, Freeze, Columns]; // Row number in literal format
		    if (numeral(col[])>0)
		    {
			my xml table[ worksheetoptions ] += "<SplitVertical>"+col[]+"</SplitVertical><LeftColumnRightPane>"+col[]+"</LeftColumnRightPane>" + new line;
		    }
		}

		my xml table[ worksheetoptions ] += "<ActivePane>" + literal(active pane[]) + "</ActivePane>" + new line;

	    }
	
	    if (my xml table[ worksheetoptions ] != "") // Add prefix and suffix
	    {
		my xml table[ worksheetoptions ] = 
			'<WorksheetOptions xmlns="urn:schemas-microsoft-com:office:excel">' + new line +
			my xml table[ worksheetoptions ] +
			"</WorksheetOptions>" + new line;
	    }
	} 


	// Function:	table style reset
	//
	// Description:	This function resets all style descriptions.
	//		
	//
	// Parameters:	0,1,,...	table name	Name of table (0 parameters= All)
	//
	// Return val:	not applicable


	define procedure( table style reset, { { parameter 1, literal } }, 0, unlimited, 1  )
	{

	    if (parameter count[] = 0) // No parameters? Deleta ll of them.
	    {
		global() delete members( table style descriptions[] );
	    }
	    else: for (i[] = 1, i[] <= parameter count[], i[]++)
	    {
		table name[] = ('parameter ' + literal(i[]))[];
		if ( existing( table style descriptions[ table name[] ] ))
		{
		    global() delete ( table style descriptions[ table name[] ] );
		}
	    }
	}




	// Function:	translate style attributes for excel
	//
	// Description:	This function translates generic style attributes for Excel Open Office format.
	//		
	//
	// Parameters:	table name	Name of table
	//
	// Return val:	not applicable


	// For every style related to particular table, row, column or cell:
	// 1.  Create a style string <styles Style ID > ***these contents here*** </stlyes>
	// 2.  Check the styles library to see if the string is already available.  If yes, pick the style number.  If no, store it and assign new style jumber
	//	


	define procedure ( translate style attributes for excel, { { table name, literal } } )
	{

	    table style descriptions[table name[]] = 0; // Excel files will always be saved with attributions.

	    // Do additional formatting needed for the number formats

	    my table[]  =^ table style descriptions[ table name[] ];
	    __ xl save precheck contents __ ( table name[], my table[] );

/* Put into comments because this code block is replaced by higher performing function call, see above

	    table process all cells( table name[],

		val[] = best type([.]);
		if (val[]=='') continue;
	        abs val[] = abs( val[] );

		if (existing(table style descriptions[table name[],cell,literal(row(),"00000000"),literal(col(),"00000000"),type]))
		{
		    style cell[] =^ table style descriptions[table name[],cell,literal(row(),"00000000"),literal(col(),"00000000")];
		}


		switch( type(val[]) )
		{
		    case(date) // Date
		    {
		        table style cells( table name[], col(), row(), single, number format, 
				select ifs( "yyyy-mm-dd hh:mm:ss", (abs val[]<1), "hh:mm:ss", (whole(abs val[])), "yyyy-mm-dd" ) );
		    }
		    case(numeral) // Numbers
		    {
			if (existing(style cell[]))
			{
			    if (style cell[type]=literal)
			    {
		                table style cells( table name[], col(), row(), single, number format, "@" );
			    }
			}
			else
			{
			    if (literal(val[])='*E*') // Scientific notation
			    {
				table style cells( table name[], col(), row(), single, number format, "0.00E+00" );
			    }
			}
		    }
		    case(literal) // Strings
		    {
			if ( find( val[], new line ) >= 0 )
			{
		            table style cells( table name[], col(), row(), single, wrap text, true );
			}
		    }

		} // switch ...		

		if (existing(style cell[])) 
		{
			release( style cell[] );
			delete(  style cell[] );
		}

	    ); // for all table cells
*/
	    unless( existing(table style descriptions[ table name[] ] ) ) return;  // Nothing formatted.

	    if (existing(table style descriptions[table name[], EXCEL])) global() delete members( table style descriptions[table name[], EXCEL] );

	    my table[] 			=^ table style descriptions[ table name[] ];
	    my table[EXCEL] 		= 1; // Create EXCEL branch
//	    my excel table[] 		=^ my table[EXCEL];

	    __ table deploy row and column styles to cells for excel __( table name[] );

	    // All other actions take place in 'table save excel file'.

	} 



    define procedure ( table style auto width, {{ table name, literal }, { attribute name, literal }, {attribute value, numeral or literal }}, 1, unlimited, 2 )
    {
 
	//
	// Step 1: Validation of all function parameters
	//

	if (!table existing( table name[] ))
		exception( stop, compose("Function 'table style auto width':", new line, "1st parameter: table '", table name[], "' does not exist"), 1);
	if (table length( table name[] )= 0) return; // Empty table
	max width[] = table max width( table name[] );


	valid attribute names[]  = { min,     max,     factor,  quantile, wrap text, starting row, stopping row, starting column, stopping column };
	attribute value types[]  = { numeral, numeral, numeral, numeral,  literal,   numeral,      numeral,      numeral,         numeral         };
	lower attribute values[] = { 1,   1,   0.1,    0 };
	upper attribute values[] = { 255, 255, 20,     1 };
	wrap text values[]       = { headers, table, body, none };

	structure( settings[], { min, max, factor, quantile, wrap text, starting row, stopping row, starting column, stopping column }, { 4, 255, 1.2, 1.0, headers, 0, 50, 0, max width[]-1 } );

 
	for ( i[] = 2, i[] < parameter count[], i[]+=2)
	{
	    if (i[] > 2)
	    {
		attribute name[]   = ('parameter ' + literal(i[]  ))[];
		attribute value[]  = ('parameter ' + literal(i[]+1))[];
	    }
	    attribute nr[] = find( valid attribute names[], attribute name[] );
	    if ( attribute nr[] < 0)	
	    {
		exception( stop, compose("Function 'table style auto width':", new line, i[], ". parameter: attribute name = '", attribute name[], "' is invalid."), 1);
	    }

	    if (type(attribute value[]) != attribute value types[]{attribute nr[]})
	    {
		exception( stop, compose("Function 'table style auto width':", new line, i[]+1, ". parameter: type of attribute value = '", type(attribute value[]), "' is invalid. '", attribute value types[]{attribute nr[]}, "' expected."), 1);
	    }

	    if ( (attribute nr[] < lower attribute values[]{}) & ((attribute value[] < lower attribute values[]{attribute nr[]}) | (attribute value[] > upper attribute values[]{attribute nr[]})) )
	    {
		exception( stop, compose("Function 'table style auto width':", new line, i[]+1, ". parameter: ", attribute name[], " value = ", attribute value[], " lies outside range of ",
				lower attribute values[]{attribute nr[]}, "..", upper attribute values[]{attribute nr[]} ), 1);
	    }

	    switch( attribute name[] )
	    {
		case( wrap text )
		{
		    if (find( wrap text values[], attribute value[] ) < 0)
		    {
			exception( stop, compose("Function 'table style auto width':", new line, i[]+1, ". parameter: attribute value = '", attribute value[], "' is invalid."), 1);
		    }
		}
		case( starting row, stopping row)
		{
		    if (attribute value[] < 0) attribute value[] += table length( table name[] );
		    if (attribute value[] >=table length(table name[])) attribute value[] = table length(table name[])-1;
		    if (attribute value[] < 0) attribute value[] = 0;
		}
		case( starting column, stopping column)
		{
		    if (attribute value[] < 0) attribute value[] += max width[];
		    if (attribute value[] >=max width[]) attribute value[] = max width[]-1;
		    if (attribute value[] < 0) attribute value[] = 0;
		}
	    }
	    settings[attribute name[]] = attribute value[];
	}


	//
	// Step 2: Identify the column widths
	//

	for (x[] = settings[starting column], x[] <= settings[stopping column], x[]++)
	{
	    widths[] = {};
	    for (y[] = settings[starting row], y[] <= settings[stopping row], y[]++)
	    {
		l[] = width([table name[]: x[], y[]]);
		if (l[]>0) widths[] += {l[]};
	    }
	    if (widths[]=={}) widths[] = {1}; // Handles columns without any contents at all
	    w[x[]] = select if (widths[]{}>0, round up( max 123(min 123( quantile( settings[quantile], widths[] )* settings[factor], settings[max]), settings[min])), settings[min] );
	}


	//
	// Step 3: Apply the formats
	//

	for (x[] = settings[starting column], x[] <= settings[stopping column], x[]++)
	{
	    table style columns( table name[], x[], sheet, column width, w[x[]] );
	    if (settings[wrap text]=table,body)
	    {
		table style columns( table name[], x[], settings[wrap text], wrap text, true );
	    }
	    else: if (settings[wrap text]=headers)
	    {
		table style cells( table name[], x[], 0, single, wrap text, true );
	    }
	}
    }


global() style themes headers[] 	= { name, border color, fill color, pattern, sheet, table, frame, rule 0..rule 9, style 0..style 9 };


define procedure( load themes list, {{ file name, literal }}, 0, 1) // Hidden function
{
	if (parameter count[]==0)
	{
	    local() file name[] = system info[user app data directory b4p] + system info[directory separator] + "B4P Style Themes.xlsx";
	}

	if ( !table existing( __ style themes __ ) | parameter count[]!= 0) local // First call: Load the table
	{
	    table load excel file		( __ style themes __, file name[], Themes );
	    table check headers 		( __ style themes __, style themes headers[], full match );
	    table fill vertically		( __ style themes __, style themes headers[] - {name}, '"' );

	    continue[] = false;

	    do // Repeat lookup procedure due to possibly nested references
	    {
		count[] = 0;
		table process cells( __ style themes __, if ([.] = 'like *')
		{
		    row[] = [ name, [.] - 'like ' - ' >>' ];
		    if (row[] <= 0) exception( stop, compose("Function 'table style theme', regading B4P Style Themes table: ", new line, "Theme name: '", [.,0], "': Cannot resolve '", [.],"'."), -1 );
		    continue[] = [.] = '* >>';
		    [.] = [name, row[], [.,0] ] -  ' >>';	// Remove any continuation statements from original statement
		    if (continue[]) [.]         += ' >>';	// Re-insert because applicable here
		    count[]++;
		} );
	    } while (count[] > 0);
	}
}


define procedure and function ( list themes )
{
	load themes list;
	table process( __ style themes __, echo( [name] ) );
	return( [__ style themes __:name,..] );
}


define procedure ( table style theme, {{table name, literal}, { theme name, literal }, { attribute name, literal }, {attribute value, numeral or literal }}, 2, unlimited, 2 )
{
    local
    {
	load themes list;

	if (!table existing( table name[] ))
		exception( stop, compose("Function 'table style theme':", new line, "1st parameter: table '", table name[], "' does not exist"), 1);
	if (table length( table name[] )= 0) return; // Empty table
	max width[] = table max width( table name[] );

	row[] = [ __ style themes __: name,theme name[] ];
	if (row[] <= 0)
	{
	    exception( stop, compose("Function 'table style theme':", new line, "2nd parameter: theme name='", theme name[], "' has not been found."), 1 );
	}

	chosen theme 1[] <== [ __ style themes __: .., row[] ];


	for ( i[] = 3, i[] < parameter count[], i[]+=2)
	{
	    if (i[] > 3)
	    {
		attribute name[]   = ('parameter ' + literal(i[]  ))[];
		attribute value[]  = ('parameter ' + literal(i[]+1))[];
	    }
	    attribute nr[] = find( style themes headers[]-{name}, attribute name[] );
	    if ( attribute nr[] < 0)	
	    {
		exception( stop, compose("Function 'table style theme':", new line, i[], ". parameter: attribute name = '", attribute name[], "' is invalid."), 1);
	    }

	    if ( attribute name[] != pattern & type( attribute value[] ) != literal )
	    {
		exception( stop, compose("Function 'table style theme':", new line, i+1[], ". parameter: attribute value = '", attribute value[], "' is of type '",type( attribute value[] ),"' not a literal."), 1);
	    }

	    if ( attribute name[] == pattern & type( attribute value[] ) != numeral )
	    {
		exception( stop, compose("Function 'table style theme':", new line, i+1[], ". parameter: attribute value = '", attribute value[], "' is of type '",type( attribute value[] ),"' not a numeral (required for attribute name 'pattern'."), 1);
	    }

	    if ( attribute name[] == frame & attribute value[] <> '{*}' )
	    {
		exception( stop, compose("Function 'table style theme':", new line, i+1[], ". parameter: attribute value = '", attribute value[], "' for attribute name = 'frame' is invalid (not beginning/ending with {..})"), 1);
	    }

	    chosen theme 2[ attribute name[] ] = attribute value[];
	}
	
	border color[] = {   0,   0,   0 }; // default color settings
	fill   color[] = { 127, 127, 127 }; 

	for all parameters ( { border color, fill color }, c[] )
	{
		if (existing(chosen theme 1[c[]])) if (chosen theme 1[c[]]!='')
		{
		    (c[])[] = chosen theme 1[c[]];
		    if (existing(chosen theme 2[c[]])) if (chosen theme 2[c[]]!='')
		    {
			(c[])[] = chosen theme 2[c[]];
		    }
		    if (c[][] = '{*}') (c[])[] = parameter set( c[][] );
		}
	}

	pattern[] = 0;
	if (existing(chosen theme 1[pattern])) if (chosen theme 1[pattern]!='')
	{
	    pattern[] = chosen theme 1[pattern];
	    if (existing(chosen theme 2[pattern])) if (chosen theme 2[pattern]!='')
	    {
		pattern[] = chosen theme 2[pattern];
	    }
	    if (pattern[] = '{*}') pattern[] = parameter set( pattern[] );
	}


	for all parameters( { sheet, table }, scope[] )
	{
	    if (existing(chosen theme 1[scope[]])) if (chosen theme 1[scope[]]!='')
	    {
		statement[] = "table style table( table name[], " + scope[] + ", " + chosen theme 1[scope[]] + ") // table setting acc. 'B4P style Themes.csv' ";
		exec( :statement[] );
	    }
	    if (existing(chosen theme 2[scope[]])) if (chosen theme 2[scope[]]!='')
	    {
	        statement[] = "table style table( table name[], " + scope[] + ", " + chosen theme 2[scope[]] + ") // Override setting acc. to function call, attribute name 'table'";
		exec( :statement[] );
	    }
	}

	rows covered[] = { 0 .. table length( table name[] ) - 1 };
	for (i[] = 0, (i[] <= 9) & (rows covered[]{}>0), i[]++)
	{
	    rule name[]		= 'rule ' + literal(i[]);
	    style name[]	= 'style ' +literal(i[]);
	    continue[]		= false;

//	    echo(i[],": Rule = ", chosen theme 1[rule name[]], "  Style = ", chosen theme 1[style name[]] );
//	    echo("  Rows to go: ", rows covered[]);

	    if (existing(chosen theme 1[style name[]])) if (chosen theme 1[style name[]]!='')
	    {
		rule[] = 'true';
		if (existing(chosen theme 1[rule name[]])) if (chosen theme 1[rule name[]]!='') rule[] = chosen theme 1[rule name[]];
		if (existing(chosen theme 2[rule name[]])) if (chosen theme 2[rule name[]]!='') rule[] = chosen theme 2[rule name[]];

		if (rule[] = '* >>')
		{
		    rule[] -= ' >>';
		    continue[] = true;
		}
		else: continue[] = false;


		rows[]		= table all selected rows( table name[], :rule[]);
		rows to process[] = rows[] & rows covered[];

	        statement[]	= "table style rows( table name[], " + literal(rows to process[]) + ", table, " + chosen theme 1[style name[]] + ") // default setting acc. 'B4P style Themes.csv' ";

	        exec( :statement[] );

		if (existing(chosen theme 2[style name[]])) if (chosen theme 2[style name[]]!='')
		{
		    statement[]		= "table style rows( table name[], " + literal(rows to process) + ", table, " + chosen theme 2[style name[]] + ") // Override setting acc. to function call, attribute name '" + style name[] + "'";
		    exec( :statement[] );
		}
		if (!continue[]) rows covered[]	-= rows to process[];
	    }
	}


	// Do the outer frame around the table if specified

	frame[] = '';
	if (existing(chosen theme 1[frame])) if (chosen theme 1[frame]!='') frame[] = chosen theme 1[frame];
	if (existing(chosen theme 2[frame])) if (chosen theme 2[frame]!='') frame[] = chosen theme 2[frame];

	if (frame[] <> '')
	{
	    if (frame[] <> '{*}') 
	    {
		exception( stop, compose("Function 'table style theme':", new line, "attribute value = '", frame[], "' for attribute name = 'frame' is invalid (not beginning/ending with {..})"), 1);
	    }
	    frame[] = parameter set( frame[] );

	    table process all rows( table name[], 
		call( table style cells, { table name[], 0,             row(), single, left border,  frame[] } );
		call( table style cells, { table name[], max width[]-1, row(), single, right border, frame[] } ) );

	    for (col[] = 0, col[] < max width[], col[]++ )
	    {
		call( table style cells, { table name[], col[], 0,                            single, top border,    frame[] } );
		call( table style cells, { table name[], col[], table length(table name[])-1, single, bottom border, frame[] } );
	    }
	}
    }
}





}
