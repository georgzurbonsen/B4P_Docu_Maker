//
B4PDOCU.START

  "Function Library" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Function Library" ],
    "Keywords":			[ "function library" ],
    "Description 01:Introduction to Function Library"::

	Beyond4P provides a large and comprehenisve library of different functions.¨
	Use the navigator bar to deep-dive into them.


	+++
   },


  "Control Flow Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Control Flow Functions" ],
    "Keywords":			[ "Control Flow Functions" ],
    "Description 01:Introduction to Control Flow Functions"::

	Beyond4P provides a wide variety of control flow functions which include conditional branches and loops.
	In contrast to other programming languages, trivial features such as the __if(__) statement is actually
	a Beyond4P function which influences execution the next statement or block.

	<br><br>

	In case you miss the <b>goto</b> statement, there is a good reason for this.  The highly structured
	Beyond4P interpreter would have faced risky challenge if that statement would have been impleemented.

	+++
   },

  "Loops" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Loops" ],
    "Keywords":			[ "Loops" ],
    "Description 01:Introduction into Loops"::

	Beyond4P provides a standard __do(__), __while(__) and __for(__) functions as they exist in quasi all
	common programming languages.  In addition, various <b>for all...</b> loops are available to work through
	tables and/or parameter sets.

	+++
   },


  "Branches" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Branches" ],
    "Keywords":			[ "Branches" ],
    "Description 01:Introduction into Branches"::

	Branches include __if(__), __once(__), and __switch(__) and __check(__) combined with __case(__) functions.

	+++
   },



  "Other Control Flow Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Other Control Flow Functions" ],
    "Keywords":			[ "Other Control Flow Functions" ],
    "Description 01:Other Control Flow Functions"::

	Inclcudes: __with table(__) to provide a context allowing partial table references.

	+++
   },



  "User-Defined Procedures and Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "User Defined Procedures and Functiions" ],
    "Keywords":			[ "User-defined procedures and functions", "user-defined procedures", "user-defined functions", "user procedures", "user functions" ],
    "Description 01:User-Defined Procedures and Functions"::

	Beyond4P supports standard procedures which are in fact used to defined user-specific procedures and functions. 
	Procedures are defined as functions which do not provide a return value and must be called as a procedure.
	Functions are defined to always provide return values and must be called as functions where the return value must be used further.
	A combination of both is allowed which provides flexibility to use defined code either as a procedure or function.

	<br><br>
	Additional function names may be defined for the same user code.  In this case, the local variable <b>function name[]</b> will be
	available to identify the function name used.


	<br><br>
	Inside the user-defined procedures and functions, following local variables are available, but cannot be deleted using __delete(__) function:

	=== 300, 700, bold_column_1
	Name of local variable | Description
	function name[] | Name of called function.  This is insofar useful if __additional function names__ have been defined for the same code
	<i>parameter name</i>[] | Name of parameter provided.  Example: <b>hello[]</b> is defined if one of the parameters is called <b>hello</b>.
	parameter <i>n</i>[] | Numbered parameter provided.  If the number of parameter is not limited, then all remaining parameters are numbered, with 1 as 1st parameter.
	parameter count[] | Contains the number of parameters passed.  This is useful if the defined function allows for flexibility regarding number of parameters passed.
	===

	+++
   },


  "Start or include Beyond4P Programs" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Start or include Beyond4P Programs" ],
    "Keywords":			[ "start programs", "include programs" ],
    "Description 01:Introduction"::

	Beyond4P provides __start(__) to start other Beyond4P programs.  Execution of this calling program continues when the Beyond4P program has ended.
	The __include(__) behaves similarly like __start(__), but memorizes the loaded program including the defined functions.  This features is useful
	to define and include user specific function libraries which can be re-used in different Beyond4P programs.

	+++
   },



  "Type Conversion and Formatting Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Type Conversion Functions" ],
    "Keywords":			[ "type conversion" ],
    "Description 01:Type Conversion Functions and Formatting Functions"::

	A set of functions are available to convert data in one type (e.g. __literals__) into other types (e.g. __dates__ and __numerals__).
	Converting values to __literal__ type supports a broad library of smart formatting features in order to output numbers, dates, etc. 
	in a desirable format.

	+++
   },




  "Mathematics and Statistics" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Mathematics and Statistics" ],
    "Keywords":			[ "mathematics and statistics" ],
    "Description 01:Mathematics and Statistics Functions"::

	Beyond4P provides a broad range of advanced mathematics and statistics functions.

	+++
   },



  "Basic Math Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "basic math functions" ],
    "Keywords":			[ "basic math functions" ],
    "Description 01:Basic Math Functions"::

	Beyond4P provides various functions to check numeric values and carry out basic mathematis functions.

	+++
   },


 "Transcendental Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "transcendental functions" ],
    "Keywords":			[ "transcendental functions" ],
    "Description 01:Transcendental Functions"::

	Transcendental functions include advanced mathematical functions covering logarithmic, exponential, trigonomietric and hyperbolic functions.

	+++
   },



 "Series Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "series functions" ],
    "Keywords":			[ "series functions" ],
    "Description 01:Series Functions"::

	This section covers all functions which can process value series of variable sizes.

	+++
   },	

"Matrix Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "matrix functions" ],
    "Keywords":			[ "matrix functions" ],
    "Description 01:Matrix Functions"::

	Beyond4P provides a library of powerful matrix functions.  While vectors are modeled as 1-dimensional __parameter sets__ containing __numerals__,
	matrices are modeled as __parameter sets__ (rows) containing __parameter sets__ containing __numerals__ (columns).

	Example: <b>{{ 1, 2, 3 }, { 4, 5, 6 }}</b> is a matrix consisting of 2 rows and 3 columns:<br><br>

	| 1  2  3 |<br>
	| 4  5  6 |<br>

	<br>

	These matrix functions are a supplement to __matrix arithmetics__ which make use of so called __deep operators__.
	You won't find a matrix addition function (like <i>madd(a[],b[])</i>) because it is realized with <b>a[] +^^ b[]</b>.

	<br><br>

	In addition to Matrix Functions which are part of the mathematical function library, __Matrix Manipulations__ provide additional
	matrix functions where the contents may be of any data type.  These functions do not apply any arithmetics on the values.


	+++
   },	

 "Statistics Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "statistics functions" ],
    "Keywords":			[ "statistics functions" ],
    "Description 01:Statistics Functions"::

	This section covers all statistics functions.

	+++
  },



 "Finance and Business Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "finance functions" ],
    "Keywords":			[ "finance functions", "business functions" ],
    "Description 01:Number Introduction to Finance and Business Functions"::

	This section various functions needed for financial calculations, business and capacity planning.

	+++
  },




 "Parameter Set Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "parameter set functions" ],
    "Keywords":			[ "parameter set functions" ],
    "Description 01:Parameter Set Functions"::

	This section describes various functions used to process or check parameter sets.
	<br>Additional powerful functions using parameter sets extensively are __series functions__, __matrix functions__, 
	__statistics functions__ and __conditional combination functions__.

	+++
  },



"Set Search and Extraction Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "parameter set search and extraction" ],
    "Keywords":			[ "parameter set search functions", "parameter set extraction functions" ],
    "Description 01:Introduction to Parameter Set Search and Extraction Functions"::

	This subsection describes various functions to search for parameter set patterns and extract subsets from parameter sets.

	+++
  },



 "Matrix Manipulation Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "matrix manipulation functions" ],
    "Keywords":			[ "matrix manipulation functions", "matrix manipulations" ],
    "Description 01:Introduction to Matrix Manipulation Functions"::

	Beyond4P provides a library of powerful matrix functions.  While vectors are modeled as 1-dimensional __parameter sets__ containing __numerals__,
	matrices are modeled as __parameter sets__ (rows) containing __parameter sets__ containing __numerals__ (columns).

	Example: <b>{{ 1, A, 3 }, { B, 5, F }}</b> is a matrix consisting of 2 rows and 3 columns:<br><br>

	| 1  A  3 |<br>
	| B  5  F |<br>

	<br>

	In addition to these functions, a different section called __Matrix Functions__ provide arithmetic functions on matrixes containing
	numerals, for example matrix multiplication, inversion and calculating determinants.

	+++
  },



"Date and Time Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "date and time functions" ],
    "Description 01:Introduction to Date Functions"::


	Beyond4P provides some powerful functions to process date and time information (particularly the variable type __date__) as well as stopwatch functions.

	The sections are:
	* __Date functions__
	* __Time functions__
	* __Stopwatch functions__

	The following important date functions are found in the section __Type Conversion Functions__ and connvert data of other types, e.g. __literals__, to __dates__.:
	* __date(__)
	* __pure date(__)
	* __date time(__)
	* __time(__)
	* __pure time(__)

	+++
  },

"Date Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "date functions" ],
    "Description 01:Introduction to Date, Time and Stopwatch Functions"::


	Beyond4P provides some powerful functions to process date .

	<br><br>

	The following important date functions are found in the section __Type Conversion Functions__ and connvert data of other types, e.g. __literals__, to __dates__.:
	* __date(__)
	* __pure date(__)
	* __date time(__)
	* __time(__)
	* __pure time(__)

	+++
  },


"Time and Stopwatch Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "time and stopwatch functions" ],
    "Description 01:Introduction to Time and Stopwatch Functions"::

	Beyond4P provides some powerful functions to process time information (particularly the variable type __date__ with time info contained)
	as well as stopwatch functions to measure the performance of your applications.

	+++
  },


"Sleep and Wait Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "sleep and wait functions" ],
    "Description 01:Introduction Sleep and Wait Functions"::

	The following functions suspend program execution for a specified time or until a specific time has been reached.
	The delay will pause Beyond4P's process and lets other application run at full speed.

	+++
  },


"String Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "string functions" ],
    "Keywords":			[ "literal functions", "string functions" ],
    "Description 01:Introduction to String Functions"::

	This section describes procedures and functions for character and string manipulations.

	+++
  },


"String Search and Extraction Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "string search and extraction" ],
    "Keywords":			[ "string search functions", "string extraction functions" ],
    "Description 01:Introduction to String Search and Extraction Functions"::

	This subsection describes various functions to search for string patterns and extract substrings from stings.

	+++
  },


"Character Encoding and Decoding":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "character coding" ],
    "Description 01:Introduction to String Search and Extraction Functions"::

	This subsection describes various functions to search for string patterns and extract substrings from stings.

	+++
  },



"Table Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "table functions" ],
    "Description 01:Introduction to Table Function"::

	This section summarizes all table functions.

	+++
  },


	
"Creating and Deleting Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "table creating deleting" ],
    "Description 01:Introduction"::

	This subsection contains basic functions to create and delete tables.

	+++
  },


"Accessing Table Information":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "accessing table info" ],
    "Description 01:Introduction"::

	This subsection contains basic table functions to access following information

	* Existence of specified table
	* Lengths
	* Widths

	+++
  },

"Accessing Table Contents":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Accessing table contents" ],
    "Description 01:Introduction"::

	This subsection contains basic table functions to access contents.

	+++
  },


"Loading and Saving Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Loading and saving tables" ],
    "Description 01:Introduction"::

	The procedures and functions described next cover loading and saving tables with a broad variety of data formats.

	+++
  },


"Input/Output with Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Input output wtih tables" ],
    "Description 01:Introduction"::

	The following functions relate to table-specific input / output features. They include:

	* Listing tables
	* Using tables as menus and asking for choices
	+++
  },


"Checking and Processing Headers":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Checking headers", "Processing headers" ],
    "Description 01:Introduction"::

	This subsection various functions which check table headers.
	It is highly advisable to check the input data to ensure that the corresponding headers and structures
	are available and error messages can be issued very early rather than somewhere in the middle of data processing steps.

	+++
  },


"Searching Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Searching tables" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means to search for data inside tables.



	+++
  },



"Processing Table Columns":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Processing table columns" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means to process table columns, i.e. 
	inserting, deleting, rearranging, processing, etc.



	+++
  },


"Processing Table Rows":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Processing table rows" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means process table rows, i.e.
	inserting, deleting, rearranging, manipulating, etc.

	+++
  },



"Processing Table Contents":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Processing table contents" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means process table contents.

	+++
  },


"Renaming, Copying and Splitting Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Copying and spitting tables" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means to copy and split tables.

	+++
  },


"Checking and Comparing Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Checking and comparing tables" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means to check tables for consistency and duplications as well
	as a simple-to-use function to compare tables and generate comparison reports.

	+++
  },


"Looking up Other Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Looking up Other Tables" ],
    "Description 01:Introduction"::

	The functions described next provide efficient lookup features to retrieve selected information from other
	tables.

	+++
  },

"Pivoting and Conosolidating Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Pivoting and consolidating tables" ],
    "Description 01:Introduction"::

	The functions described in this sections are building blocks to do powerful pivoting and consolidating tables.
	All functions have been optimized to deliver maximum performance, even with very large tables.  The functions
	described in the following sections cover follwing aspects:

	* Transposing contents (i.e. contents in 1st column become row headers)
	* Serializing horizontally laid out data
	* Spreading serialized data out horizontally (opposite of above), and
	* Consolidating tables (boiling tables down to fewer rows with specific consolidation actions serving as ingredients)

	+++
  },



"Combining Multiple Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Combining Multiple Tables" ],
    "Description 01:Introduction"::

	The functions described next cover the art of combining two (or more) tables using the fine arts of <a href="https://en.wikipedia.org/wiki/Relational_algebra" target="_blank">relational algebra</a>
	where different algebraic rules can be applied to rows and columns.

	<br><br>

	In a simple example, two tables with members of two clubs (e.g. tennis and squash) need to be merged into one where the last and first names of the
	members shall act as matching identifiers.  In case no person has a membership in both clubs, no overlap applies, and the list will simply be
	appended where the data are aligned to the right columns, using header names as orientation.  The columns in both tables do not need to be aligned
	before the merger.  If one or more persons possess memberships in both clubs, then the information will be consolidated where the same 
	__ consolidation actions__ rules are available as used by __table consolidate__.  As an example, the account receivable (e.g.
	indoor court reservation fees to be balanced) can be added up whereas the preferences at the club bar can be consolidated with <b>append once</b>
	so the preference for tonic water at one club and beer at the other club will appended into "tonic water, beer".

	<br><br>

	If no identifier columns are defined in the functions described next, then every row will be considered unique.  Merging the table is treated appending two tables,
	with aligning the data into the right columns.	 

	<br><br>

	The following table summarizes the 25 functions in a 5 x 5 matrix with specifc rules to be applied on rows as wll as columns.
	The table contains illustrations on how the rows are combined (shades of red / orange / yellow) and how columns are combined (shades of
	gray and light blue).  The syntax of the function name does first describe the operation on the rows (e.g. __table merge__) followed by
	the operation on the columns (e.g. __table merge extend columns(__)).  If no extension like <b>... extend columns</b> is specified, then
	no additional columns are added in the target table and the data in the source table not fitting in the target table structure will not be taken over.

	
		<br/><img src="Images/Description_Combining_Multiple_Tables.jpg" alt="Combining Multiple Tables"><br/><br/>

	The term <i>exclusivity</i> is also known as <i>symmetric difference</i> and <i>disjunctive union</i>.


    "Description 02:Additional Functions"::

	Following table operations are also described in this section:
	* Multiplying tables
	* Dividing tables (binary division in relational algebra)
	* Arranging tables sideways.


	+++
  },





"Exploring and Extracting Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Exploring and Extracting Tables" ],
    "Description 01:Introduction"::

	A new powerful B4P feature, consisting of three functions, is to identify, select and extract one or more sub-tables located inside a table.
	This becomes very useful when dealing with sophisticated tables created by external sources where you cannot advise them how to
	structure the data so you can use them easily.  Following three functions need to be called in sequence:

	__table explore(__): This function identifies all sub-tables inside a table where a few criteria settings are available to identify tables and keep them 
	separate from other contents, e.g. title texts.
	<br><br>
	This function returns a parameter set containing 0, 1 or more coordinates for every sub-table found.
	The sub-tables beginning on the same row must contain a spacing of 1 column.  Direct neighboring is possible if the next table begins at a different tow (Illustration: See sub-table 2 and 3).
	<br><br>
	__table filter(__): The collection of coordinates can be narrowed down by matching header contents with given patterns and specifying minimum 
	table widths and heights.  This function also returns the same kind of parameter set, but probably with fewer coordinates.
	<br><br>
	__table extract(__): This final function will extract a selected sub-table based on the coordinates and sub-table chosen.  
	Tables can be extracted either into new blank tables or added to existing tables, allowing to arrange them horizontally and/or vertically.


	
		<br/><img src="Images/Description_Exploring_and_Extracting_Tables.jpg" alt="Exploring and Extracting Tables"><br/><br/>


	+++
  },



"Variables Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "variables functions" ],
    "Description 01:Introduction to Variables Function"::

	This section summarizes all functions processing variables.  The functions are categorized into the following:
	* Obtaining information about the variables


	+++
  },


"Basic Variables Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "basic variables functions" ],
    "Description 01:Introduction"::

	This section summarizes all basic functions aroun variables
	* Information about variables
	* Simple data movements
	* Deleting variables

	__Arrays and structures__ will be addressed in the following section.

	+++
  },


"Arrays and Structures":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Arrays and Structures" ],
    "Description 01:Introduction"::

	This section provides an overview of functions defining and working with __arrays__ and __structures__.

	+++
  },




"Directory and File System Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "directory and file system" ],
    "Keywords": 		[ "short error messages on directories and files"],
    "Description 01:Introduction to Directory and File System Functions"::

	This subsection describes various functions to access and process files and directories.  Following key features 
	are included.

	* Accessing, searching and manipulating directories (create, change to, rename, remove directories)
	* Accessing, searching and manipulating files (directory listings, copy files, rename files, delete files)
	* Disk functions (e.g. disk size info)
	* Internet access (download files)

	+++,

    "Description 02:Path and File Names"::

	Under Windows, the path names are a chain of directory and subdirectory names separated with backslash '\' symbols.  Under LINUX and MACOS,
	the forward slash '/' is used.  Unless specified otherwise do add quotation marks to (sub-) directory and file names if they contain spaces.
	Avoid using symbols not supported or recommended by the operating systems, e.g. '<', , '&', '>' and ':'.

	<br><br>

	Beyond4P tolerates both slash symbols and does the operating system conversions automatically. Even a mix of both symbols are OK. Following examples are valid:
	* C:/Program Files\Beyond4P.exe
	* \usr\local/bin\Beyond4P

	<br><br>

	If the specified directory or file name contains no path name in front, then the current drive and working directory are assumed.

	<br><br>

	<u>Attention:</u> Directory and file names are case sensitive in LINUX and MACOS systems, but not in Windows.

	+++,
    "Description 03:Exception Handling"::

	Various procedures and functions contain <b>... silently</b> as ending part of their names.  This suffix
	lets Beyond4P to issue return values which are either "OK" or contain a short error message.  Without the
	suffix, an exception happens, program execution will stop and enters __interactive mode__.

	=== 250, 250, 500
	Return values for file functions	| Return values for directory functions | Description
	OK					| OK					| Successful execution
	Path not found				| Path not found			| Specified directory path not found or invalid
	File not Found				| Directory not found			| File / directory not found
	File access denied			| Directory access denied		| File / directory access denied. Insufficient privileges.
	File write-protected			| (n/a)					| File is write-protected.  Check protection settings.
	(n/a)					| Directory not empty			| Directory is not empty (contains files and/or sub-directories)
	File locked				| Directory locked			| File / directory is locked by other applications. Close the other application.
	File already existing			| Directory already existing		| File / The file already exists (e.g. attempt to overwrite with file copy function). For files, use the equivalent function name containing the suffix <b>overwrite</b>.
	File error				| Directory error			| Invalid file / directory name or file locked by other application.
	File invalid chars			| (n/a)					| File name contains invalid characters
	Can't move files across devices		| Can't move files across devices	| Can't move files across devices (with __file rename(__) function)
	File found directory expected		| Directory found file expected		| Specified directory name refers to an existing file, and vice versa
	===

	+++
  },



"Basic Directory and File Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "basic directory and file functions" ],
    "Description 01:Introduction to Basic Directory and File Functions"::

	This subsection describes various functions to search to accesss directories and files.

	+++
  },


"Listing and Searching Directories and Files":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "listing directories and files" ],
    "Description 01:Introduction to Listing Directories and Files"::

	This subsection describes various functions to obtain list of existing filse and directories, as well as searching for files and directories.

	+++
  },

"Manipulating Directories and Files":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "deleting directories and files" ],
    "Description 01:Introduction to Manipulating Directories and Files"::

	This subsection describes various functions to create, copy, rename and delete files and directories

	+++
  },


// ________________________________________________________________________________________ "/


"Cross-Functional Info":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Cross-functional info" ],
    "Description 01:Introduction"::

	This section contains various information which apply to different functions across the function library,
	for example applicable sorting and consolidating options.

	+++
  },


"Sorting and Ranking Options":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Sorting options", "Ranking options" ],
    "Description 01:Introduction"::

	The sorting options are used (amongst others) by following functions:
	* __table sort columns(__)
	* __table sort rows(__)
	* __table sort selected rows(__)
	* __table rank rows(__)
	* __table rank selected rows(__)

	+++,
    "Description 02:Overview of Available Options"::

	=== 200, 800, bold_column_1
	Sorting / Ranking Option 	| Description
	alphabetic			| Alphabetic order by UNICODE character set.
	alphabetic down			| Opposite direction of above
	alphabetic ignore case		| Alphabetic order, but ignores case (e.g. 'the Hague' comes before 'Uruguay')
	alphabetic down ignore case	| Opposite direction of above
	alphabetic ignore blanks	| Same as alphabetic. Blanks (incl. new line, tabs, space) are ignored.  'St. Moritz' and 'St.Moritz' are equivalent.
	alphabetic down ignore blanks	| Opposite direction of above
	alphabetic ignore both		| Same as alphabetic, ignoring both case and blanks
	alphabetic down ignore both	| Opposite direction of above
	numeric				| Sorts by numbers.  Non-numeric contents are interpreted like zero.  Smallest number comes first.
	numeric down			| Opposite direction of above
	date				| Sorts by dates.  Fields containing no qualified dates are interpreted like blank dates.  See rules below the table.
	===

	Rules on literals:
	* Blank literal '' comes first
	* One space symbol ' ' (UNICODE 32) comes next.
	* Sorting is done based on UNICODE character codes.
	* Sorting takes no cultural implications into consideration (e.g. Spanish: LL follows L).
	* Numbers are also treated as literals: 0100 comes before 10.

	Rules on numerals:
	* For contents beginning a number: The 1st number will be recognized.
	* For contents beginning with non-numeric symbols: Interpreted as zero.

	Rules on dates:
	* Blank dates come first.
	* If year is missing, current year is assumed.
	* If day is missing, the 1st day of month is assumed.
	* Month names in key languages like "Jan", "feb", "März", "avril", "May", "juni", etc. are recognized as months and sorted accordingly.
	* Local settings are used as rules to resolve country dependent date formats like 01/02/2015 (day and month ordering: 2. Jan 2015 or 1. Feb 2015).  Local settings are in the system variables and can be changed.
	* Time values in the date are ignored.  E.g. "14.07.2016 10:00" and "14.07.2016 11:00" are treated as identical values

	Rules on dates and times:
	* Blank dates come first.
	* Date values without time come before date values with time (e.g. "00:00:00") if date are on the same day.
	* Time values are not ignored

	Rules on times:
	* Blank dates come first.
	* Date values are ignored.  "14.07.2016 10:00” and “15.07.2016 10:00” are treated as identical values

	Following example shows a ranking based on the different options applied.
	+++,

    "Examples 02:"::
	include( Support Library );
	
	table initialize ( t,
	{ { Scheme, alphabetic, alphabetic down, alphabetic ignore case, alphabetic down ignore case, numeric, numeric down, date, date down, time, time down },
	    "02-Dec-2020 10:00", "02-Nov-2020 11:00", "05", "1", "Dec", "apr 15", "-1", "", "begin" } );

	for all parameters( [t:1..,0], option[] )  table rank rows( t, option[], Scheme, option[], 113 ); // 113 - Same ranking share same ranking position
	table transpose (t);
	table list (t);		
	+++,

    "Output 02:": "automatic"

  },



"Consolidation Actions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "consolidation actions" ],
    "Description 01:Introduction"::

	The sorting options are used (amongst others) by following functions:
	* __table consolidate(__)
	* __table merge(__) function family

	+++,
    "Description 02:Overview of Available Consolidation Actions"::

	The consolidation actions does only take place if a matching row further down in the table (or source table if 2 tables are combined) needs
	to be consolidated to the target fields.  No actions are applied if only one row exists with same identifer contents. 

	=== 200, 800, bold_column_1
	Consolidation Action		| Description
	none				| No consolidation: The destination fields will not be overwritten.<br>At the end of the consolidation run, the destination field contains the data from the first row belonging to the group.
	overwrite			| Source field overwrites destination field. <br>At the end of the consolidation run, the destination field contains the data from the last row belonging to the group.
	overwrite if blank		| Source field overwrites destination field if the destination field is still blank. See <sup>1</sup>
	overwrite except blank		| Source field overwrites destination field if the soruce field is not blank. See <sup>1</sup>
	blank				| Destination field will be blanked.  Useful to void contents no longer needed after consolidation.
	zero				| Destination field will be set to 0. Useful to void contents no longer needed after consolidation.
	delete				| This column will be deleted after the consolidation run.  Useful to get rid of contents no longer needed.
	append				| Append string contents from source fields to destination fields.  A separator string will be inserted if available.
	append once			| Like above, but contents are only appended if not yet found in the destination string.
	must match			| Checks source and destination fields.  If they differ, then <b>(Inconsistent)</b> will be written.
	blank if different		| Checks source and destination fields.  If they differ, then the destination fields will be blanked.
	min abc				| Choose the entry in the lower alphabetc sorting order (e.g. abc preferred over def). Blanks have highest priority. 
	min abc ignore blanks		| Choose the entry in the lower alphabetc sorting order (e.g. abc preferred over def). Blanks have lowest priority. See <sup>1</sup>
	max abc				| Choose the entry in the higher alphabetc sorting order (e.g. def preferred over abc). Blanks have lowest priority.
	min				| Choose the entry with the smaller value. Blanks and non-numeric contents are treated as zero.
	min ignore blanks		| Choose the entry with the smaller value. Blanks have lowest priority. Non-numeric contents are treated as zero. See <sup>1,2</sup>
	min ignore zero			| Choose the entry with the smaller value.  Blanks and non-numeric contents and zero have lowest priority. See <sup>2</sup>
	max				| Choose the entry with the greater value. Blanks and non-numeric contents are treated as zero.
	max ignore blanks		| Choose the entry with the greater value. Blanks have lowest priority. Non-numeric contents are treated as zero. See <sup>1,2</sup>
	max ignore zero			| Choose the entry with the greater value.  Blanks and non-numeric contents and zero have lowest priority. See <sup>2</sup>
	sum				| Calculates the sum: Adds source fields to destination fields.
	sum blank if zero		| Calculates the sum: Adds source fields to destination fields. If destination field is 0, it will be set to blank.
	product				| Calculates the product: Multiplies source fields to destination fields.  Blanks and non-numeric contents are treated as zero.
	product ignore blanks		| Calculates the product: Multiplies source fields to destination fields.  Blanks are ignore, but non-numeric contents are treated as zero. See <sup>1,2</sup>
	product ignore zero		| Calculates the product: Multiplies source fields to destination fields.    Blanks and non-numeric contents and zero are ignored.  See <sup>2</sup>
	average				| Calculates the average (sum divided by number of rows consolidated). Blanks and non-numeric contents are treated as zero.
	average ignore blanks		| Calculates the average (sum divided by number of rows consolidated). Non-numeric contents are treated as zero. See <sup>1,2</sup>
	average ignore zero		| Calculates the average (sum divided by number of rows consolidated).  Blanks and non-numeric contents and zero are ignored. See <sup>2</sup>
	count				| Count all fields.  Is always 1 or bigger.
	count ignore blanks		| Count non-blank fields only. See <sup>1</sup>
	count ignore zero		| Count non-zero fields. 0, blanks and non-numerals are ignored.
	count positive			| Count if value is > 0. 0, blanks and non-numerals are ignored.
	count positive or zero		| Count if value is >= 0.  Blanks and non-numerals are treated as 0 and will be counted.
	count negative			| Count if value is < 0. 0, blanks and non-numerals are ignored.
	count negative or zero		| Count if value is <= 0.  Blanks and non-numerals are treated as 0 and will be counted.
	===

	<sup>1</sup> Fields are considered blank if they are absolutely blank, i.e. containing zero characters.  Fields containing white spaces (spaces, tabs, new lines, etc.) are not considered blank.<br>
	<sup>2</sup> If none of the fields qualify for calculation (e.g. min ignore blanks where all fields are blank), then the result will be zero.

	+++

  }





B4PDOCU.STOP
