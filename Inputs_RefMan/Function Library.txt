 	//
B4PDOCU.START

  "Function Library" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Function Library" ],
    "Description 01:Introduction"::

	Beyond4P provides a large and comprehenisve library of different functions.¨
	Use the navigator bar to deep-dive into them.


	+++
   },


  "Control Flow Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Control Flow Functions" ],
    "Description 01:Introduction"::

	Beyond4P provides a wide variety of control flow functions which include conditional branches and loops.
	In contrast to other programming languages, trivial features such as the __if(__) statement is actually
	a Beyond4P function which influences execution the next statement or block.

	<br><br>

	In case you miss the <b>goto</b> statement, there is a good reason for this.  The highly structured
	Beyond4P interpreter would have faced risky challenge if that statement would have been impleemented.

	+++
   },

  "Loops" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Loops" ],
    "Description 01:Introduction"::

	Beyond4P provides a standard __do(__), __while(__) and __for(__) functions as they exist in quasi all
	common programming languages.  In addition, various <b>for all...</b> loops are available to work through
	tables and/or parameter sets.

	+++
   },


  "Branches" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Branches" ],
    "Description 01:Introduction"::

	Branches include __if(__), __once(__), and __switch(__) and __check(__) combined with __case(__) functions.

	+++
   },


  "Exception Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Exception Functions" ],
    "Description 01:Introduction"::

	Exception functions include the following: __pause__, __stop__, __end__, __exit__, __abort__, __throw__, __catch__ / __catch if__ and __interactive__.

	+++
   },


  "Other Control Flow Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Other Control Flow Functions" ],
    "Description 01:Introduction"::

	Inclcudes: __with table(__) to provide a context allowing partial table references.

	+++
   },

  "Code Execution Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Code Execution Functions" ],
    "Description 01:Introduction"::

	The functions enable translation of code fragments in string format and execute them directly.
	In addition, the __deep(__) function family allows to apply selected functions not only on single values
	but repeatedly across all values in parameter sets.

	+++
   },




  "User-Defined Procedures and Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "User Defined Procedures and Functiions" ],
    "Keywords":			[ "User-defined procedures and functions", "user-defined procedures", "user-defined functions", "user procedures", "user functions" ],
    "Description 01:Introduction"::

	Beyond4P supports standard procedures which are in fact used to defined user-specific procedures and functions. 
	Procedures are defined as functions which do not provide a return value and must be called as a procedure.
	Functions are defined to always provide return values and must be called as functions where the return value must be used further.
	A combination of both is allowed which provides flexibility to use defined code either as a procedure or function.

	<br><br>
	Additional function names may be defined for the same user code.  In this case, the local variable <b>function name[]</b> will be
	available to identify the function name used.


	<br><br>
	Inside the user-defined procedures and functions, following local variables are available, but cannot be deleted using __delete(__) function:

	=== 300, 700, bold_column_1
	Name of local variable | Description
	function name[] | Name of called function.  This is insofar useful if __additional function names__ have been defined for the same code
	<i>parameter name</i>[] | Name of parameter provided.  Example: <b>hello[]</b> is defined if one of the parameters is called <b>hello</b>.
	parameter <i>n</i>[] | Numbered parameter provided.  If the number of parameter is not limited, then all remaining parameters are numbered, with 1 as 1st parameter.
	parameter count[] | Contains the number of parameters passed.  This is useful if the defined function allows for flexibility regarding number of parameters passed.
	===

	+++
   },


  "Start or include Beyond4P Programs" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Start or include Beyond4P Programs" ],
    "Keywords":			[ "start programs", "include programs" ],
    "Description 01:Introduction"::

	Beyond4P provides __start(__) to start other Beyond4P programs.  Execution of this calling program continues when the Beyond4P program has ended.
	The __include(__) behaves similarly like __start(__), but memorizes the loaded program including the defined functions.  This features is useful
	to define and include user specific function libraries which can be re-used in different Beyond4P programs.

	+++
   },




"Input / Output Functions":
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "input output functions" ],
    "Description 01:Introduction"::

	This subsection describes various functions text and console input / output features such as __echo(__) considered as a common
	building-block for text output, but also __console special effects__ like clearing screens (__cls(__)) and changing text colors.

	+++
},


"Text Input / Output":
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "text input output" ],
    "Description 01:Introduction"::

	This subsection covers text-based input/output such as __input(__), __echo(__), __print(__) and so forth.

	+++
},


"Console Special Effects":
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Console special effects" ],
    "Description 01:Introduction"::

	This subsection covers special effects such as clearing screens, moving cursors and changing text and background colors.

	+++
},




"Inspection and Debugging":
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Inspection and debugging" ],
    "Description 01:Introduction"::

	The functions described in the following section are suited for __interactive mode__ and program use.  These functions provide
	convenient insight into variables and tables.

	+++
},




"Type Conversion and Formatting Functions" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Type Conversion Functions" ],
    "Keywords":			[ "type conversion" ],
    "Description 01:Introduction"::

	A set of functions are available to convert data in one type (e.g. __literals__) into other types (e.g. __dates__ and __numerals__).
	Converting values to __literal__ type supports a broad library of smart formatting features in order to output numbers, dates, etc. 
	in a desirable format.

	+++
},




"Mathematics and Statistics" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Mathematics and Statistics" ],
    "Description 01:Introduction"::

	Beyond4P provides a broad range of advanced mathematics and statistics functions.

	+++
},



"Basic Math Functions" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "basic math functions" ],
    "Description 01:Introduction"::

	Beyond4P provides various functions to check numeric values and carry out basic mathematis functions.

	+++
   },


"Transcendental Functions" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "transcendental functions" ],
    "Description 01:Introduction"::

	Transcendental functions are less mystic than you are believing.
	They include advanced mathematical functions covering logarithmic, exponential, trigonomietric and hyperbolic functions
	and suitable for everyday mathematics tasks.

	+++
},



"Series Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "series functions" ],
    "Description 01:Introduction"::

	This section covers all functions which can process value series of variable sizes.

	+++
   },	

"Matrix Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "matrix functions" ],
    "Description 01:Introduction"::

	Beyond4P provides a library of powerful matrix functions.  While vectors are modeled as 1-dimensional __parameter sets__ containing __numerals__,
	matrices are modeled as __parameter sets__ (rows) containing __parameter sets__ containing __numerals__ (columns).

	Example: <b>{{ 1, 2, 3 }, { 4, 5, 6 }}</b> is a matrix consisting of 2 rows and 3 columns:<br><br>

	| 1  2  3 |<br>
	| 4  5  6 |<br>

	<br>

	These matrix functions are a supplement to __matrix arithmetics__ which make use of so called __deep operators__.
	You won't find a matrix addition function (like <i>madd(a[],b[])</i>) because it is realized with <b>a[] +^^ b[]</b>.

	<br><br>

	In addition to Matrix Functions which are part of the mathematical function library, __Matrix Manipulations__ provide additional
	matrix functions where the contents may be of any data type.  These functions do not apply any arithmetics on the values.


	+++
   },	

 "Statistics Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "statistics functions" ],
    "Description 01:Introduction"::

	This section covers all statistics functions.

	+++
  },



 "Finance and Business Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "finance functions" ],
    "Keywords":			[ "business functions" ],
    "Description 01:Introduction"::

	This section various functions needed for financial calculations, business and capacity planning.

	+++
  },




 "Parameter Set Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "parameter set functions" ],
    "Description 01:Introduction"::

	This section describes various functions used to process or check parameter sets.
	<br>Additional powerful functions using parameter sets extensively are __series functions__, __matrix functions__, 
	__statistics functions__ and __conditional combination functions__.

	+++
  },



"Set Search and Extraction Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "parameter set search and extraction" ],
    "Keywords":			[ "parameter set search functions", "parameter set extraction functions" ],
    "Description 01:Introduction"::

	This subsection describes various functions to search for parameter set patterns and extract subsets from parameter sets.

	+++
  },



 "Matrix Manipulation Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "matrix manipulation functions" ],
    "Keywords":			[ "matrix manipulations" ],
    "Description 01:Introduction"::

	Beyond4P provides a library of powerful matrix functions.  While vectors are modeled as 1-dimensional __parameter sets__ containing __numerals__,
	matrices are modeled as __parameter sets__ (rows) containing __parameter sets__ containing __numerals__ (columns).

	Example: <b>{{ 1, A, 3 }, { B, 5, F }}</b> is a matrix consisting of 2 rows and 3 columns:<br><br>

	| 1  A  3 |<br>
	| B  5  F |<br>

	<br>

	In addition to these functions, a different section called __Matrix Functions__ provide arithmetic functions on matrixes containing
	numerals, for example matrix multiplication, inversion and calculating determinants.

	+++
  },



"Date and Time Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "date and time functions" ],
    "Description 01:Introduction"::


	Beyond4P provides some powerful functions to process date and time information (particularly the variable type __date__) as well as stopwatch functions.

	The sections are:
	* __Date functions__
	* __Time functions__
	* __Stopwatch functions__

	The following important date functions are found in the section __Type Conversion Functions__ and connvert data of other types, e.g. __literals__, to __dates__.:
	* __date(__)
	* __pure date(__)
	* __date time(__)
	* __time(__)
	* __pure time(__)

	+++
  },

"Date Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "date functions" ],
    "Description 01:Introduction"::


	Beyond4P provides some powerful functions to process date .

	<br><br>

	The following important date functions are found in the section __Type Conversion Functions__ and connvert data of other types, e.g. __literals__, to __dates__.:
	* __date(__)
	* __pure date(__)
	* __date time(__)
	* __time(__)
	* __pure time(__)

	+++
  },


"Time and Stopwatch Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "time and stopwatch functions" ],
    "Description 01:Introduction"::

	Beyond4P provides some powerful functions to process time information (particularly the variable type __date__ with time info contained)
	as well as stopwatch functions to measure the performance of your applications.

	+++
  },


"Sleep and Wait Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "sleep and wait functions" ],
    "Description 01:Introduction"::

	The following functions suspend program execution for a specified time or until a specific time has been reached.
	The delay will pause Beyond4P's process and lets other application run at full speed.

	+++
  },


"String Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "string functions" ],
    "Keywords":			[ "literal functions" ],
    "Description 01:Introduction"::

	This section describes procedures and functions for character and string manipulations.

	+++
  },


"String Search and Extraction Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "string search and extraction" ],
    "Keywords":			[ "string search functions", "string extraction functions" ],
    "Description 01:Introduction"::

	This subsection describes various functions to search for string patterns and extract substrings from stings.

	+++
  },


"Character Encoding and Decoding":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "character coding" ],
    "Description 01:Introduction"::

	This subsection describes various functions to search for string patterns and extract substrings from stings.

	+++
  },


"Miscellaneous String Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Other string functions" ],
    "Description 01:Introduction"::

	All other string functions, including random string generation, are explained next.

	+++
  },



"Table Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "table functions" ],
    "Description 01:Introduction"::

	This section summarizes all table functions.

	+++
  },

	
"Creating and Deleting Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "table creating deleting" ],
    "Description 01:Introduction"::

	This subsection contains basic functions to create and delete tables.

	+++
  },


"Accessing Table Information":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "accessing table info" ],
    "Description 01:Introduction"::

	This subsection contains basic table functions to access following information

	* Existence of specified table
	* Lengths
	* Widths

	+++
  },

"Accessing Table Contents":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Accessing table contents" ],
    "Description 01:Introduction"::

	This subsection contains basic table functions to access contents.

	+++
  },


"Loading and Saving Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Loading and saving tables" ],
    "Description 01:Introduction"::

	The procedures and functions described next cover loading and saving tables with a broad variety of data formats.

	+++
  },


"Input/Output with Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Input output wtih tables" ],
    "Description 01:Introduction"::

	The following functions relate to table-specific input / output features. They include:

	* Listing tables
	* Using tables as menus and asking for choices
	+++
  },


"Checking and Processing Headers":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Checking headers", "Processing headers" ],
    "Description 01:Introduction"::

	This subsection various functions which check table headers.
	It is highly advisable to check the input data to ensure that the corresponding headers and structures
	are available and error messages can be issued very early rather than somewhere in the middle of data processing steps.

	+++
  },


"Searching Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Searching tables" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means to search for data inside tables.



	+++
  },



"Processing Table Columns":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Processing table columns" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means to process table columns, i.e. 
	inserting, deleting, rearranging, processing, etc.



	+++
  },


"Processing Table Rows":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Processing table rows" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means process table rows, i.e.
	inserting, deleting, rearranging, manipulating, etc.

	+++
  },



"Processing Table Contents":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Processing table contents" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means process table contents.

	+++
  },


"Renaming, Copying and Splitting Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Copying and spitting tables" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means to copy and split tables.

	+++
  },


"Checking and Comparing Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Checking and comparing tables" ],
    "Description 01:Introduction"::

	The functions described next provide efficient means to check tables for consistency and duplications as well
	as a simple-to-use function to compare tables and generate comparison reports.

	+++
  },


"Looking up Other Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Looking up Other Tables" ],
    "Description 01:Introduction"::

	The functions described next provide efficient lookup features to retrieve selected information from other
	tables.

	+++
  },

"Pivoting and Conosolidating Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Pivoting and consolidating tables" ],
    "Description 01:Introduction"::

	The functions described in this sections are building blocks to do powerful pivoting and consolidating tables.
	All functions have been optimized to deliver maximum performance, even with very large tables.  The functions
	described in the following sections cover follwing aspects:

	* Transposing contents (i.e. contents in 1st column become row headers)
	* Serializing horizontally laid out data
	* Spreading serialized data out horizontally (opposite of above), and
	* Consolidating tables (boiling tables down to fewer rows with specific consolidation actions serving as ingredients)

	+++
  },



"Combining Multiple Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Combining Multiple Tables" ],
    "Description 01:Introduction"::

	The functions described next cover the art of combining two (or more) tables using the fine arts of <a href="https://en.wikipedia.org/wiki/Relational_algebra" target="_blank">relational algebra</a>
	where different algebraic rules can be applied to rows and columns.

	<br><br>

	In a simple example, two tables with members of two clubs (e.g. tennis and squash) need to be merged into one where the last and first names of the
	members shall act as matching identifiers.  In case no person has a membership in both clubs, no overlap applies, and the list will simply be
	appended where the data are aligned to the right columns, using header names as orientation.  The columns in both tables do not need to be aligned
	before the merger.  If one or more persons possess memberships in both clubs, then the information will be consolidated where the same 
	__ consolidation actions__ rules are available as used by __table consolidate__.  As an example, the account receivable (e.g.
	indoor court reservation fees to be balanced) can be added up whereas the preferences at the club bar can be consolidated with <b>append once</b>
	so the preference for tonic water at one club and beer at the other club will appended into "tonic water, beer".

	<br><br>

	If no identifier columns are defined in the functions described next, then every row will be considered unique.  Merging the table is treated appending two tables,
	with aligning the data into the right columns.	 

	<br><br>

	The following table summarizes the 25 functions in a 5 x 5 matrix with specifc rules to be applied on rows as wll as columns.
	The table contains illustrations on how the rows are combined (shades of red / orange / yellow) and how columns are combined (shades of
	gray and light blue).  The syntax of the function name does first describe the operation on the rows (e.g. __table merge__) followed by
	the operation on the columns (e.g. __table merge extend columns(__)).  If no extension like <b>... extend columns</b> is specified, then
	no additional columns are added in the target table and the data in the source table not fitting in the target table structure will not be taken over.

	
		<br/><img src="Images/Description_Combining_Multiple_Tables.jpg" alt="Combining Multiple Tables"><br/><br/>

	The term <i>exclusivity</i> is also known as <i>symmetric difference</i> and <i>disjunctive union</i>.


    "Description 02:Additional Functions"::

	Following table operations are also described in this section:
	* Multiplying tables
	* Dividing tables (binary division in relational algebra)
	* Arranging tables sideways.


	+++
  },





"Exploring and Extracting Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Exploring and Extracting Tables" ],
    "Description 01:Introduction"::

	A new powerful B4P feature, consisting of three functions, is to identify, select and extract one or more sub-tables located inside a table.
	This becomes very useful when dealing with sophisticated tables created by external sources where you cannot advise them how to
	structure the data so you can use them easily.  Following three functions need to be called in sequence:

	__table explore(__): This function identifies all sub-tables inside a table where a few criteria settings are available to identify tables and keep them 
	separate from other contents, e.g. title texts.
	<br><br>
	This function returns a parameter set containing 0, 1 or more coordinates for every sub-table found.
	The sub-tables beginning on the same row must contain a spacing of 1 column.  Direct neighboring is possible if the next table begins at a different tow (Illustration: See sub-table 2 and 3).
	<br><br>
	__table filter(__): The collection of coordinates can be narrowed down by matching header contents with given patterns and specifying minimum 
	table widths and heights.  This function also returns the same kind of parameter set, but probably with fewer coordinates.
	<br><br>
	__table extract(__): This final function will extract a selected sub-table based on the coordinates and sub-table chosen.  
	Tables can be extracted either into new blank tables or added to existing tables, allowing to arrange them horizontally and/or vertically.


	
		<br/><img src="Images/Description_Exploring_and_Extracting_Tables.jpg" alt="Exploring and Extracting Tables"><br/><br/>


	+++
  },



"Variables Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "variables functions" ],
    "Description 01:Introduction"::

	This section summarizes all functions processing variables.  The functions are categorized into the following:
	* Obtaining information about the variables


	+++
  },


"Basic Variables Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "basic variables functions" ],
    "Description 01:Introduction"::

	This section summarizes all basic functions aroun variables
	* Information about variables
	* Simple data movements
	* Deleting variables

	__Arrays and structures__ will be addressed in the following section.

	+++
  },


"Arrays and Structures":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Arrays and Structures" ],
    "Description 01:Introduction"::

	This section provides an overview of functions defining and working with __arrays__ and __structures__.

	+++
  },


"Loading and Saving Variables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Loading and saving variables" ],
    "Description 01:Introduction"::

	The following functions provide convenient methods to save variables (including all the structure and array members and sub-members) into files or $
	text strings (literals) and vice versa in JavaScriopt Object Notation (JSON).  Focus is given on full data preservation in round trip cases, 
	i.e. data is saved as JSON and covered again, and vice versa.

	<br><br>

	Following rules will be applied when saving variables into JSON text. 
	These rules are insofar important because the Beyond4P can consist of both base variables, array and structure members and sub-members, 
	and the simple JSON representation focuses on leaf data, meaning the final members and sub-members without the intermediate one.  
	In addition, special rules are applied to save Beyond4P specific formats such as dates (and times) and parameter sets.

	Following special rules apply
	=== 200, 800, noframe_1stcolbold, noheader
	General			| The base variable as well as all members and sub-members, regardless if array or structures, will be saved.
	__Simple Variables__	| If the variable is a simple variable, then it will be saved as a JSON plain array containing 1 element.  Using 'JSON B4P' option in the loading process will recover the variable properly.
	__Arrays__		| B4P arrays are stored as JSON arrays
	__Structures__		| B4P structures are stored as JSON objects
	Literals		| Literal string contents are stored as text in double quotation marks
	Numerals		| Numerals are written as numbers without quotation marks.  When saving, scientific notation is not used.  However, JSON files containing scientific notation will be loaded correctly.
	Booleans		| Will be written as <b>true</b> and <b>false</b>.  B4P will recognize boolean values and convert them to Boolean type
	Void values		| Are written as <b>null</b> in JSON output.
	Dates			| Dates (and times) are written as text in following formats: "YYYY-MM-DD", "hh:mm:ss", "YYYY-MM-DD hh:mm:ss", and "0000-00-00".  The last value refers to a blank date and will be recognized as such. When reading JSON data, dates and times must adhere strictly with the given formats, otherwise they will be loaded as text (e.g. "01 April 2020").
	Parameter Sets		| Parameter sets will be converted to string format (similarly implemented as in the __literal(__) function) and stored as text.  Literals are stored in single qutoation marks, aiming to avoid confusion wtih double quotation marks for JSON text contents.  Example: "{1,true,'Abc'}".  Nested parameter sets are supported.
	Loading literals	| All loaded literals are declared as <b>quoted literals</b>
	Special characters	| Specific characters will be converted to JSON-compliant escape sequences, e.g. new line, quotation marks inside literals, etc. 
	===
	+++,
    "Description 02:Intermediate Nodes"::
	The JSON model describes a tree containing data at the end nodes only (leaves) whereas B4P variable model also supports data in intermediate
	nodes as well.  In these case, intermediate arrays containing 2 elements are introduced to describe the intermediate node followed by the 
	remaining data up the data tree.  See the program example below:
    "Examples 02:JSON code without and with intermediate nodes"::
	b[Red] = Rot;
	b[Green,light] = Hellgrün;
	b[Green,dark] = Dunkelgrün;
	b[Blue,light] = Hellblau;
	b[Blue,dark] = Dunkelblau;

	inspect(b[]);

	j[] = variable to json( b[], JSON);

	echo("JSON code:", new line, j[], new line, "_______" );

	json to variable( c[], j[], JSON B4P );
	inspect( c[] );

	echo(new line, "Add data to intermediate nodes");

	b[] = Colors;
	b[Green] = Shades of green;

	j[] = variable to json( b[], JSON);

	echo("JSON code:", new line, j[], new line, "_______" );

	json to variable( c[], j[], JSON B4P );
	inspect( c[] ); // Same as before.
	+++,
	"Output 02": "automatic"

  },



"Variable References Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Variable references functions" ],
    "Description 01:Introduction"::

	This section describes functions related to __variable references__.

	+++
  },


"Resident Attributes Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Resident attributes functions" ],
    "Description 01:Introduction"::

	Resident attributes are values which can be stored in dedicated files.  In contrast to loading and saving variables, attributes are tuples
	consisting of <i>attribute names</i> and <i>attribute values</i>.  Values can take any type, e.g. numeral, literal, date, Boolean and parameter set.
	Attribute names can be either flat (just one name) or hierarchical (parameter set containing multiple names representng a sort of path name).

	<br><br>
	In contrast to Microsoft Windows registry, the B4P resident attributes is an operating-system independent solution to store small amounts of data
	or settings conveniently.  One file may contain one or more settings.  Thd data format used is JavaScript Object Notation (JSON).

	<br><br>
	If a nested sub-attribute is created, then the values associated to the attributes are blank literals "", and not void.
	Example:  attribute write ( path[ ], file[ ], {local machine, local settings, date format}, "YYYY-MM-DD" ) will automatically assign "" to attribute name local machine, 
	and local settings if not yet existing.

	+++
  },



"Comparison and Selection Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Comparison and selection functions" ],
    "Description 01:Introduction"::

	Common programming languages use standard constructs like <b>if ... else</b> or condensed statements
	such as <i>[condition]</i> <b>?</b> <i>[expression if true]</i> <b>?</b> <i>[expression if false]</i>,
	Aiming to allow for more dense and efficient coding, B4P provides a set of effective comparison and
	selection functions.  The functions come in two fragrances:

	+++,
    "Description 02:select ... ()"::
	In these functions all parameters are fully calculated regardless of the condition and/or if the values are finally selected or discarded.
	This approach is most efficient if the values are constants or simple expression (e.g. a constant, referring to variable, a table entry,
	a simple calculation, etc.) or if manipulations must be made in any case, e.g. doing a function call or incrementing/decrementing variables.
	+++,
    "Examples 02:Program example - all expressions are calculated:"::
	a[] = select if( true, echo(yes), echo(no) ); // Note. Both 'yes' and 'no' are printed here
	echo("Result is ", a[] );
	+++,
    "Output 02:Result:": "automatic",
    "Description 03:pick ... ()"::
	In these functions, the expressions for the values to select are only calculated if the results are needed.  Otherwise, these expressions
	will be skipped.  This approach saves a lot of computation effort if more sophisticated expressions are contained.  In addition, if a variable
	in an expression not selected is not defined, this does not matter because that expression is skipped.
	+++,
    "Examples 03:Program example - 'echo(no)' is not executed:"::
	a[] = pick if( true, echo(yes), echo(no) ); // Note: Only 'yes' if printed
	echo("Result is ", a[] );
	+++,
    "Output 03:Output": "automatic"
},



"Directory and File System Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "directory and file system functions" ],
    "Description 01:Introduction"::

	This subsection describes various functions to access and process files and directories.  Following key features 
	are included.

	* Accessing, searching and manipulating directories (create, change to, rename, remove directories)
	* Accessing, searching and manipulating files (directory listings, copy files, rename files, delete files)
	* Disk functions (e.g. disk size info)
	* Internet access (download files)

	+++,

    "Description 02:Path and File Names"::

	Under Windows, the path names are a chain of directory and subdirectory names separated with backslash '\' symbols.  Under LINUX and MACOS,
	the forward slash '/' is used.  Unless specified otherwise do add quotation marks to (sub-) directory and file names if they contain spaces.
	Avoid using symbols not supported or recommended by the operating systems, e.g. '<', , '&', '>' and ':'.

	<br><br>

	Beyond4P tolerates both slash symbols and does the operating system conversions automatically. Even a mix of both symbols are OK. Following examples are valid:
	* C:/Program Files\Beyond4P.exe
	* \usr\local/bin\Beyond4P

	<br><br>

	If the specified directory or file name contains no path name in front, then the current drive and working directory are assumed.

	<br><br>

	<u>Attention:</u> Directory and file names are case sensitive in LINUX and MACOS systems, but not in Windows.

	+++,
    "Description 03:Exception Handling"::

	Various procedures and functions contain <b>... silently</b> as ending part of their names.  This suffix
	lets Beyond4P to issue return values which are either "OK" or contain a short error message.  Without the
	suffix, an exception happens, program execution will stop and enters __interactive mode__.

	=== 250, 250, 500
	Return values for file functions	| Return values for directory functions | Description
	OK					| OK					| Successful execution
	Path not found				| Path not found			| Specified directory path not found or invalid
	File not Found				| Directory not found			| File / directory not found
	File access denied			| Directory access denied		| File / directory access denied. Insufficient privileges.
	File write-protected			| (n/a)					| File is write-protected.  Check protection settings.
	(n/a)					| Directory not empty			| Directory is not empty (contains files and/or sub-directories)
	File locked				| Directory locked			| File / directory is locked by other applications. Close the other application.
	File already existing			| Directory already existing		| File / The file already exists (e.g. attempt to overwrite with file copy function). For files, use the equivalent function name containing the suffix <b>overwrite</b>.
	File error				| Directory error			| Invalid file / directory name or file locked by other application.
	File invalid chars			| (n/a)					| File name contains invalid characters
	Can't move files across devices		| Can't move files across devices	| Can't move files across devices (with __file rename(__) function)
	File found directory expected		| Directory found file expected		| Specified directory name refers to an existing file, and vice versa
	===

	+++
  },



"Basic Directory and File Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "basic directory and file functions" ],
    "Description 01:Introduction"::

	This subsection describes various functions to search to accesss directories and files.

	+++
  },


"Listing and Searching Directories and Files":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "listing directories and files" ],
    "Description 01:Introduction"::

	This subsection describes various functions to obtain list of existing filse and directories, as well as searching for files and directories.

	+++
  },

"Manipulating Directories and Files":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "manipulating directories and files" ],
    "Description 01:Introduction"::

	This subsection describes various functions to create, copy, rename and delete files and directories

	+++
  },



"System Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "system functions" ],
    "Description 01:Introduction"::

	This section summarizes system specific functions including executing operating system commands (like Windows CMD, Linux shell, etc.)

	+++
  },


"Executing System Commands":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "executing system commands" ],
    "Description 01:Introduction"::

	This section describes the __system(__) function to execute system commands and also provides a function called __quote path(__) to precondition 
	path and file names so they can be used as command line parameters for system commands accordingly.

	+++
  },


"Registry Access Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "registry access functions" ],
    "Description 01:Introduction"::

	The Microsoft Windows operating system provides a <i>registry</i> which is a hierarchical database to store sytem and application
	settings.  The contents in the registry affect the behavior of the operating system, windows graphical user interface and application
	program.  B4P provides a set of registry access functions, however access to them have been restricted due to a considerable risk
	that unexperienced usage could cause severe and irreversible harm to the system.  The B4P installer program is actually accessing the registry in order to
	assign the file type ".b4p" to the B4P program, and to assign the icon to that file type.

	<br><br>
	For the reason above, the B4P contains no description of the registry access functions.  Linux and MacOS do not maintain such a registry.
	If you intended to use the registry for storing individual values, then consider using the __resident attributes functions__ instead, and this one
	works on all supported operating systems.

	<br><br>
	Please contact us if you need to write a B4P program which needs to access the registry and you have a good reason for that.
	+++
  },


"Licensing and Privileges":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "licensing and privileges" ],
    "Description 01:Introduction"::

	The following functions relate to system and B4P programming privileges as well as functions needed to activate licensing.
	As an example, these functions are used in the B4P installation script.

	+++
  },




"Help and Support Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "help and support functions" ],
    "Description 01:Introduction"::

	The functions described next are ideally suited for interactive use in order to obtain more information
	about specific functions and features and access on-line and off-line documentation directly.

	+++
  },

// ________________________________________________________________________________________ "/


"Cross-Functional Info":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Cross-functional info" ],
    "Description 01:Introduction"::

	This section contains various information which apply to different functions across the function library,
	for example applicable sorting and consolidating options.

	+++
  },


"Sorting and Ranking Options":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Sorting options", "Ranking options" ],
    "Description 01:Introduction"::

	The sorting options are used (amongst others) by following functions:
	* __table sort columns(__)
	* __table sort rows(__)
	* __table sort selected rows(__)
	* __table rank rows(__)
	* __table rank selected rows(__)

	+++,
    "Description 02:Overview of Available Options"::

	=== 200, 800, bold_column_1
	Sorting / Ranking Option 	| Description
	alphabetic			| Alphabetic order by UNICODE character set.
	alphabetic down			| Opposite direction of above
	alphabetic ignore case		| Alphabetic order, but ignores case (e.g. 'the Hague' comes before 'Uruguay')
	alphabetic down ignore case	| Opposite direction of above
	alphabetic ignore blanks	| Same as alphabetic. Blanks (incl. new line, tabs, space) are ignored.  'St. Moritz' and 'St.Moritz' are equivalent.
	alphabetic down ignore blanks	| Opposite direction of above
	alphabetic ignore both		| Same as alphabetic, ignoring both case and blanks
	alphabetic down ignore both	| Opposite direction of above
	numeric				| Sorts by numbers.  Non-numeric contents are interpreted like zero.  Smallest number comes first.
	numeric down			| Opposite direction of above
	date				| Sorts by dates.  Fields containing no qualified dates are interpreted like blank dates.  See rules below the table.
	===

	Rules on literals:
	* Blank literal '' comes first
	* One space symbol ' ' (UNICODE 32) comes next.
	* Sorting is done based on UNICODE character codes.
	* Sorting takes no cultural implications into consideration (e.g. Spanish: LL follows L).
	* Numbers are also treated as literals: 0100 comes before 10.

	Rules on numerals:
	* For contents beginning a number: The 1st number will be recognized.
	* For contents beginning with non-numeric symbols: Interpreted as zero.

	Rules on dates:
	* Blank dates come first.
	* If year is missing, current year is assumed.
	* If day is missing, the 1st day of month is assumed.
	* Month names in key languages like "Jan", "feb", "März", "avril", "May", "juni", etc. are recognized as months and sorted accordingly.
	* Local settings are used as rules to resolve country dependent date formats like 01/02/2015 (day and month ordering: 2. Jan 2015 or 1. Feb 2015).  Local settings are in the system variables and can be changed.
	* Time values in the date are ignored.  E.g. "14.07.2016 10:00" and "14.07.2016 11:00" are treated as identical values

	Rules on dates and times:
	* Blank dates come first.
	* Date values without time come before date values with time (e.g. "00:00:00") if date are on the same day.
	* Time values are not ignored

	Rules on times:
	* Blank dates come first.
	* Date values are ignored.  "14.07.2016 10:00” and “15.07.2016 10:00” are treated as identical values

	Following example shows a ranking based on the different options applied.
	+++,

    "Examples 02:"::
	include( Support Library );
	
	table initialize ( t,
	{ { Scheme, alphabetic, alphabetic down, alphabetic ignore case, alphabetic down ignore case, numeric, numeric down, date, date down, time, time down },
	    "02-Dec-2020 10:00", "02-Nov-2020 11:00", "05", "1", "Dec", "apr 15", "-1", "", "begin" } );

	for all parameters( [t:1..,0], option[] )  table rank rows( t, option[], Scheme, option[], 113 ); // 113 - Same ranking share same ranking position
	table transpose (t);
	table list (t);		
	+++,

    "Output 02:": "automatic"

  },



"Consolidation Actions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "consolidation actions" ],
    "Description 01:Introduction"::

	The sorting options are used (amongst others) by following functions:
	* __table consolidate(__)
	* __table merge(__) function family

	+++,
    "Description 02:Overview of Available Consolidation Actions"::

	The consolidation actions does only take place if a matching row further down in the table (or source table if 2 tables are combined) needs
	to be consolidated to the target fields.  No actions are applied if only one row exists with same identifer contents. 

	=== 200, 800, bold_column_1
	Consolidation Action		| Description
	none				| No consolidation: The destination fields will not be overwritten.<br>At the end of the consolidation run, the destination field contains the data from the first row belonging to the group.
	overwrite			| Source field overwrites destination field. <br>At the end of the consolidation run, the destination field contains the data from the last row belonging to the group.
	overwrite if blank		| Source field overwrites destination field if the destination field is still blank. See <sup>1</sup>
	overwrite except blank		| Source field overwrites destination field if the soruce field is not blank. See <sup>1</sup>
	blank				| Destination field will be blanked.  Useful to void contents no longer needed after consolidation.
	zero				| Destination field will be set to 0. Useful to void contents no longer needed after consolidation.
	delete				| This column will be deleted after the consolidation run.  Useful to get rid of contents no longer needed.
	append				| Append string contents from source fields to destination fields.  A separator string will be inserted if available.
	append once			| Like above, but contents are only appended if not yet found in the destination string.
	must match			| Checks source and destination fields.  If they differ, then <b>(Inconsistent)</b> will be written.
	blank if different		| Checks source and destination fields.  If they differ, then the destination fields will be blanked.
	min abc				| Choose the entry in the lower alphabetc sorting order (e.g. abc preferred over def). Blanks have highest priority. 
	min abc ignore blanks		| Choose the entry in the lower alphabetc sorting order (e.g. abc preferred over def). Blanks have lowest priority. See <sup>1</sup>
	max abc				| Choose the entry in the higher alphabetc sorting order (e.g. def preferred over abc). Blanks have lowest priority.
	min				| Choose the entry with the smaller value. Blanks and non-numeric contents are treated as zero.
	min ignore blanks		| Choose the entry with the smaller value. Blanks have lowest priority. Non-numeric contents are treated as zero. See <sup>1,2</sup>
	min ignore zero			| Choose the entry with the smaller value.  Blanks and non-numeric contents and zero have lowest priority. See <sup>2</sup>
	max				| Choose the entry with the greater value. Blanks and non-numeric contents are treated as zero.
	max ignore blanks		| Choose the entry with the greater value. Blanks have lowest priority. Non-numeric contents are treated as zero. See <sup>1,2</sup>
	max ignore zero			| Choose the entry with the greater value.  Blanks and non-numeric contents and zero have lowest priority. See <sup>2</sup>
	sum				| Calculates the sum: Adds source fields to destination fields.
	sum blank if zero		| Calculates the sum: Adds source fields to destination fields. If destination field is 0, it will be set to blank.
	product				| Calculates the product: Multiplies source fields to destination fields.  Blanks and non-numeric contents are treated as zero.
	product ignore blanks		| Calculates the product: Multiplies source fields to destination fields.  Blanks are ignore, but non-numeric contents are treated as zero. See <sup>1,2</sup>
	product ignore zero		| Calculates the product: Multiplies source fields to destination fields.    Blanks and non-numeric contents and zero are ignored.  See <sup>2</sup>
	average				| Calculates the average (sum divided by number of rows consolidated). Blanks and non-numeric contents are treated as zero.
	average ignore blanks		| Calculates the average (sum divided by number of rows consolidated). Non-numeric contents are treated as zero. See <sup>1,2</sup>
	average ignore zero		| Calculates the average (sum divided by number of rows consolidated).  Blanks and non-numeric contents and zero are ignored. See <sup>2</sup>
	count				| Count all fields.  Is always 1 or bigger.
	count ignore blanks		| Count non-blank fields only. See <sup>1</sup>
	count ignore zero		| Count non-zero fields. 0, blanks and non-numerals are ignored.
	count positive			| Count if value is > 0. 0, blanks and non-numerals are ignored.
	count positive or zero		| Count if value is >= 0.  Blanks and non-numerals are treated as 0 and will be counted.
	count negative			| Count if value is < 0. 0, blanks and non-numerals are ignored.
	count negative or zero		| Count if value is <= 0.  Blanks and non-numerals are treated as 0 and will be counted.
	===

	<sup>1</sup> Fields are considered blank if they are absolutely blank, i.e. containing zero characters.  Fields containing white spaces (spaces, tabs, new lines, etc.) are not considered blank.<br>
	<sup>2</sup> If none of the fields qualify for calculation (e.g. min ignore blanks where all fields are blank), then the result will be zero.

	+++

  }





B4PDOCU.STOP
