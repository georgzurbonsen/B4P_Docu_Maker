//
B4PDOCU.START



"The Language" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "The Language" ],
    "Description 01:Overview"::

	The B4P language is a very compact and powerful programming language aiming to solve challenging data processing problems involving
	large amounts of data.  The language contains specific syntax and semantic structures which are key enablers for rapid programming,
	high comprehensibility and exceptionally high performance.  Your key benefits are:

	* <b>Simple</b> procedural language.
	* Very easy to read and understand the code, therfore <b>very easy to learn</b> programming.
	* Powerful language semantics <b>minimizes the number of statements</b> needed to solve the problem.
	* <b>Very quickly</b> to get your code running
	* <b>Be natural</b> and less cryptic.  Giver your variables, tables, functions, etc. natural names (spaces are allowed)
	* <b>Tables</b> of any size are one of the main data storage models and B4P is optimized for this.
	* <b>No programming bureaucracy</b> such as type definitions, declaring all the variables and doing memory management on your own.
	* Significantly less need for <i>fine grained</i> programming like formulating loops, detailed algorithms, etc.
	* B4P understands data formats such as <b>Excel, HTML, XML, JSON, CSV</b>, etc. to retrieve data from Excel, database and the Internet directly
	* The run-time machine and all libary files are very lean, very robust and start quickly.
	* High focus on <b>cross-platform portability</b> (Windows, Linux, MacOS, etc.), enabling to run the same code on different platforms.
	* B4P output files for Excel can contain <b>style and formatting</b> like colors, row widths, etc.

	You will get to full speed quickly if you have some basic programming experience with a high level programming language or a macro
	language such as Visual Basic inside Excel.  B4P requires no knowledge about object oriented programming and specific algorithms to manage
	big data (e.g. indexing, memory management).  The syntax is, even though looking differently from other languages, incredibly easy to understand and to use.
	In contrast to other programming langages, much fewer statements and time are needed, no additional libraries need to be installed 
	separately (like Panda for Python) and you experience unparalleled machine performance, forgetting the fact that B4P is an interpreted language.

	<br><br>
	<b>B4P lets you focus on solving your key problems quickly, and not getting stuck with details:</b>

	<br/><img src="Images/Description_Introduction_Flowchart.png" alt="B4P Typical Data Processing Steps"><br/>

	<br>
	By experience, successful solutions have been provided already <b>during the first consultation</b> with colleagues who needed solutions for
	their data processing needs.  They originally expected a cost and time estimation and a project plan for the project in order to approve the 
	budget for hiring programmers or consultants, and all that ended up not necessary at all because a few lines of code solved the problem
	and a lot of money saved.

	+++
},



"Basic Language Structure" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		"Basic Language Structure",
    "Keywords":			"Blocks",
    "Description 01:Introduction"::

	The B4P language is designed to solve problems with as few clearly understandable statements as possible.  The language consists of 
	a small number of building blocks:

	=== 200, 600, 200, bold_column_1 bold_column_3
	Language Features	| Description																| Examples
	<b>Blocks</b>		| The contain 1 or more statements inside braces <b>{ ... }</b> in order to execute them jointly, e.g. after __if(__) functions \
				  and in control flow statements such as loops.	 											| { a[] = 1; b[] = 2; }
	<b>Statements</b>	| Can be a procedure call, an __assignment__, an ad-hoc operation or a transaction.<br>\
				  Multiple statements are separated with semiclons <b>;</b>										|
	__Procedure calls__	| B4P functions called as procedures.<br>In B4P, control flow statements are also procedure calls.					| echo( Hello World );
	__Assignments__		| A value or calculated __expression__ is assigned to a variable or table entry								| a[] = 3 * 3;
	__Ad-hoc operations__	| Immediate operation applied on a target variable without doing assignment								| a[]++;
	__Transactions__	| Smart assignments among variables including their hierarchical member variables and table rows 					| b[] <== a[];
	__Expressions__		| Values (constants), variables, table entries, functions called, or calculated combination of them using operators and parentheses	| a[] + 2*abs(b[])
	===
	<br><br>
	Like in other programming languages, long statements may take multiple lines of text becase the semicolon is delimiting the statements.

	+++,

    "Description 02:Control Flow Statements"::

	In contrast to other programming languages, the control flow statements such as __if(__), __while(__) and __for(__) loops and many more
	are indeed B4P __functions__ which are called as procedures and then decide whether to execute the following statements or block containing
	statements or not.  See also the section on __Control Flow Functions__.
	+++
},



"Distinct Language Features":
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Distinct Language Features" ],
    "Description 01:Overview"::

	<b> B4P includes an <i>interpreted programming language</i> with powerful syntax, highly flexible data structures, and a large function library which enables immediate results with 
	a minimum of code.</b>  Programs containing just a few statements can perform sophisticated operations such as merging two tables with very different data arrangements and formats
	or analyzing big amounts of data.  The following key features makes the B4P language distinct from other popular programming languages:

	<br><br>

	=== 200, 800, noframe_1stcolbold, noheader
	Interpreted				| The __run-time machine__ is designed to interpret and process the code with very high performance. \
						  Two factors contribute to high execution performance despite being an interpreted language: <br>\
						  1. The code is checked and fully tokenized before starting to run<br>\
						  2. The language provides an extensive library to manage large tables, variable structures and parameter sets (i.e. vectors and matrices).
	Fully portable across system platforms | B4P runs on WINDOWS, LINUX and MAC-OS.  You can develop your apps so they run on all \
			 			 platforms without changing the code. B4P provides harmonized functions for directory, file and system function calls,\
			 			 as well as system variables such as user names, key system directory names, etc.
	Names with spaces and special characters | You are allowed to use spaces and special characters in function names, variable names, table names, column header names, etc.  \
						  <b>max value[]</b> and <b>'1%'[]</b> are valid variable names. This allows you to use typical column headers, e.g. "Total Costs", \
						  without modifying them or putting quotations around. A valid function call could be " table create (customer table, supplier table, etc. ); \
						  " Function names like __table process selected rows(__) is easier to read than "TableProcessSelectedRows"
	Variables 				| All simple variables end with brackets <b>[]</b>  Example: <b>value[]</b>. If you forget them, then the name is just a string value.<br/>\
						  You can create child variables with any nesting, <br/>e.g. <b>animal[dog]=poodle; animal[cat]=tiger; animal[dog,leg count]=4;</b>.<br/>\
						  You can also define arrays, e.g. <b>matrix[2,3]</b> or the combination of both structures and arrays to develop sophisticated variable storage models.
	Values 					| Numbers are values, text are values, too.  In the example <b>a[] = bull dog ;  b[] = ' bull   dog ';</b> a[] is assiged with <i>'bull dog'</i> containing one space between the two words, whare as b[] is assigned with <i>' bull   dog '</i> where all spaces are preserved.  Without quotation marks, outside spaces and repeated spaces betwen words are ignored.
	Full UNICODE support 			| Every character counts as 1 character, including the foreign and non-ANSI ones.  The full UNICODE including the Basic Multilingual Plane (like &eacute; and &euro;), and all the other UNICODE planes (e.g. &#x1F609;) are supported.
	Basic variable types 			| They are <i>numeral</i>, <i>literal</i>, <i>boolean</i>, <i>date</i> (manages date, time and both), <i>parameter set</i>, and <i>void</i>.
	Parameter sets 				| Very powerful type to combine any number of variables and nested parameter sets into one parameter set.<br>Example: <b>names[] = {Abel, Beata, Charly};</b>
	Dynamic weak typing 			| B4P uses dynamic weak typing.  The type is set once a value is assigned. Example: <b>a[] = 1;</b> automatically declares a[] as a numeric variable. <br>The type will change if something non-numeric is assigned, eg. <b>a[] = Hello;</b>.
	Tables 					| Tables are the heart of B4P.  Typically referenced as <b>[table name : row , column ]</b>.<br/>If a conext with table name and row number is given, e.g. inside a loop, then a simple reference like <b>[column]</b> is sufficient.<br>Example: <b>table process</b>( membership list, <b>echo</b>( [Family Name], ", ", [First Name] );
	Accessing multiple values in tables 	| Powerful schemes are available to access individual cells, entire rows or parts of them, entire columsn or parts of them, or combination of all.
	Powerful table processing function library | A large number of procedures and functions is available to analyze, process and combine tables as you wish.  These functions deliver highest machine performance.
	Transactions 				| Very smart assignments for variables and table rows. You can replicate variables including all child members, or combine two variables including their member variables.
	Function parameters accept code pieces | Unlike in other languages, some functions accept pieces of code such as expressions and statements as input parameters.  These codes may be executed several time. <br/>Good example: <b>table process( members, [full name] = [1st name] + ' ' + [last name] );</b>
	Variable count function parameters 	| Some functions accept a variable number of parameters, with minimum, maximum and incrementals given.
	User definable procedures and functions | You can defined own procedures and functions.  Functions provide return values whereas procedures don't.  You can assign multiple function names to the same user-defined code. In this case, the pre-defined local variable <b>function name[]</b> allows to identify the function name used to call the code.
	Indirect parameter passing 		| Some procedures and functions allow one <i>parameter set</i> variable to be used to provide all function parameters in one.<br/>Example: a[] = { 2,3,4 }; <b>echo</b>( <b>min</b>( 2,3,4 ), ' and ', <b>min</b>( a[] ) ); // Output in both cases is 2.
	Deep unary and binary operators 	| Deep operators (supplemented with the circumflex '^' symbol) can be used to calculate with elements inside parameter sets. <br/>Example: { 1,2,3 } +^ { 4,5,6 } results in { 5,7,9 }.  However, { 1,2,3 } + { 4,5,6 } results in {1,2,3,4,5,6} instead.  Deep operations are analogous to vector and matrix operations.
	Control flow | Unless in other programming languages, control flow features like __if(__), __for(__), __while(__), __return__, etc. are actually procedure and function calls.  \
						  Something as simple as <b>if</b> takes one boolean value as function parameter and decides whether to execute or skip the next statement or code block.  In fact, this is made possible because procedures and functions can accept code pieces as it is required for functions like <b>for</b>.
	Portable directory paths 		| B4P accepts both '/' and '\' for path separators. They will be adjusted automatically to match with the operating system requirements.
	===
	
	+++,

    "Description 02:Think Big to be Successful"::

	You can unleash the full power of B4P if you are thinking big.  Writing a complete end-to-end solution (with loops, variable assignments, comparisons
	of individual values, etc.) is straighforward to learn with no special programming background.  Other languages like Python can do similar processing, but requires one to learn object-oriented programming, and does not scale for complexity.
	

	=== 60, 940, noframe_1stcolbold, noheader
	Hint 1 | Use the rich B4P function library to process these tables and big data.  Large tables will be analyzed and processed at naked machine performance.<br/>
	Hint 2 | Use deep operations (vector and matrix operations) to process large amount of data inside tables and parameter sets.<br/>
	Hint 3 | Think how you can formulate your code in a very compact manner without compromising comprehensibility.  Doing great things with 5-20 lines of code is within reach.<br/>
	===
	+++
},





"Comments" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "comments" ],
    "Keywords":			[ "comments" ],
    "Description 01:Introduction to Comments"::
	Documenting comments is very similar as in C/C++. The language supports following comment symbols:


	=== 150, 150, 700, bold_column_1 bold_column_2
	Comment Types	| Examples | Description
	Line comment	| // | Comment starting with double slashes and effective until end of line. The symbols for comment blocks /* and */ are ignored inside line comments.
	Comment block	| /* ... */ | Commented code section. <br/>/* begins commented section<br/>*/ ends commented sections<br/>Commented section is not ended prematurely with line comments.<br/>Nested comments are not supported, e.g. /* … /* … */ … */
	===

	You may wonder why obvious names such as 'if', 'while' and 'for' are not considered as similar reserved keywords.  In B4P, the control flow statements
	are actually procedure names which then influence executing further statements or blocks.  Therefore, you can actually use 'if' as the given function.
	+++,
    "Examples 01:"::
	// This is a commment
	// Bla Bla /* Bla Bla
	echo( This statement is outside a comment block );
	// Bla Bla */ Bla Bla
	+++,
    "Output 01:":		"automatic",

    "Description 02:Github Markdown Files"::
	B4P <i>understands</i> markdown files (with filenames ending '.md') where it only executes code lines which inside the code blocks.  All other contents
	outside the code blocks are treated like comments.  Code blocks must be delimited with three accent-grave symbols ```. Multiple such code blocks in one
	markdown file are supported.

    "Examples 02:"::
	# This is a markdown header
	And some text to describe it
	```program code
	echo( This statement is inside a code block );
	```
	# This is the next header

	+++,
    "Output 02:":		"This statement is inside a block"


},




"Characters" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Characters" ],
    "Description 01:Introduction"::

	B4P supports the full UNICODE character set which includes
	* The Basic Multilingual Plane (codes 0 ... 65,535), as well as
	* 16 additional UNICODE planes (codes 65,536 ... 1,114,111).

	In contrast to various other programming languages, B4P considers every UNICODE character as one single
	character.  For example, 'Caf&eacute;' counts 4 characters.  The full character set is available to define
	variable names, table names, table header names, user function names, path and file names, etc.
	Internally, in order to conserve memory needs for large data, all text data is stored and handled in UTF-8 format, but you don't need to worry about ths.

	<br><br>
	Note that Latin, Greek and Cyrillic characters share common letters, e.g. capital letter 'A'.  Attempting to compare them will indicate that
	they are different.  As another example, the Greek <i>mu</i> &mu; and the <i>micro</i> &micro; symbols are different, too.

	+++,

    "Examples 01:"::
	inhabitants [ Zürich ] = 402000;
	Пётр Чайкoвский [ famous concert ] = Nutcracker; // Piotr Tschaikowski
	echo( inhabitants [ Zürich ] );
	echo( Пётр Чайкoвский [ famous concert ] );
	+++,
    "Output 01:":		"automatic",


    "Description 02:Line Separator Symbols"::

	B4P is able to load text files containing both "carriage return + line feed" (CR+LF) characters common in Windows systems
	and "line feed only" (LF) common in UNIX/LINUX/MACOS systems.  Internally, B4P considers the __reserved keyword__ <b>new line</b> as
	a single character.  When saving contents to files, the <b>new line</b> symbol will be automatically saved as line-feed (LF) in UNIX / Linux / MacOS
	systems and carriage-return + line-feed (CR+LF) character pairs in Windows systems.

	<br><br>
	The legacy Macintosh "carriage return only" (CR) serving as line separator is not supported.

	+++

  },


"Case Sensitivity" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "case sensitivity" ],
    "Description 01:Introduction"::

	B4P is a case sensitive language.  This applies to all text contents such as table, variable, function names and __reserved keywords__.
	In UNIX / Linux / MacOS, directory and file names are fully case sensitive.  However in Windows, file names are only case-sensitivity when creating
	directories or file names, but finding them is not case sensitive.

    "Description 02:Case Conversion"::

	B4P provides the __unary operators__ <b>+</b>, <b>-</b> and <b>!</b> to change text to upper case, lower case or just capitalize the first character.
	The case conversion does not respect speciic locales, for example special handling of the Turkish letters turkish letters &#x0130; / i / I / &#x0131;.
	The lower case sharp-s &#x00DF; in the German Language will not be converted to upper case or substituted by two capital S.  The B4P case conversion is presently
	supporting following UNICODE characters:

	=== 300, 300, 300
	UNICODE Block 		| Code Range 		| Example
	Basic Latin 		| 00 - 7F (Hex) 	| A / a
	Latin 1 Supplement 	| 80 - FF (Hex) 	| &Auml; / &auml;
	Latin Extended A 	| 100 - 1FF (Hex) 	| &#x0102; / &#x0103;
	===
	
	+++
},




"Console Input / Output" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "console" ],
    "Description 01:Console Output"::

	Even in Windows 7, 8 and 10, the good old console (started with "cmd" or "msdos" or "powershell") contains archaeological software artefacts dating back to 1981
	when the IBM PC has been launched.  Luckily, the recent Windows releases support UTF-8 output to the console.  However, the supported character sets
	are limted to the following:

	* Basic Latin
	* Latin-1 Supplement (To ensure Düsseldorf is not written as Dusseldorf - translated as "village of fools")
	* Latin Extended A
	* Greek (for language enthsiasts and fraternity/sorority members in North America)
	* Cyrillic (Russian)
	* A set of additional symbols (also found in win1252 character set) including the Euro currency sign

	Unsupported symbols will automatically be shown as question mark or with a placeholder box.

	+++,

    "Description 02:Console Input"::

	Another relict from 1981: Unfortunately, Microsoft has not done its homework regarding UNICODE input from the keyboard and we need to accept the facts established
	in the year when Ronald Reagan was elected as the President, surely a better choice than since 2016, and foreign characters appeared more foreign at that time than today, too.
	Non-ANSI symbols (accents, umlauts, Euro currency symbol, etc.) are converted with an antiquated MS-DOS character set.  B4P resolves this issue by automatically
	converting entered characters into UNICODE.

	+++,
    "Description 03:UNIX, Linux and MacOS Platforms"::
	These platforms are much better prepared for full UNICODE (UTF-8) support when interacting with keyboard input and console output.
	+++
},




"Literal Constants" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Literal Constants" ],
    "Description 01:Introduction"::

	B4P treats literal constants a bit differently than in other programming languages.  B4P distinguishes between three different literal constants	
	which have different characteristics:

	* (unquoted) literals
	* softquoted literals
	* quoted literals

	These literal constants can be used in thefollowing contexts:

	=== 250, 250, 250, 250
	Usage of literal constants		| (Unquoted) literals				| Softquoted literals			| Quoted literals
	String values				| example					| 'example'				| "example"
	Base variable names (see <sup>1</sup>)	| example[]					| 'example'[]				| "example"[]
	Member variable names (see <sup>1</sup>)| example[example 2, ...]			| 'example'['example 2', ...]		| "example"["example 2", ...]
	Table names				| [example:...]					| ['example':...]			| ["example":...]
	Function names, called as procedures	| example;<br>example(...);			| (Not supported)			| (Not supported)
	Function names, called as functions in expressions\
						| = ... example();<br>= ... example(...);	| (Not supported)			| (Not supported)
	Reserved keywords			| true, false, else, ...			| (Not reserved if in quotation marks)	| (Not reserved if in quotation marks)
	===

	<sup>1</sup> <u>Attention</u>: Different from other programming languages, __variables__ in B4P are always specified by literals followed by a <b>[]</b> or <b>[...]</b> sequence.
	It appears outlandish, but has some key advantages which are described later in this manual

	+++
},



"(Unquoted) Literals" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Unquoted Literals", "Unquoted Literal" ],
    "Description 01:Introduction"::

	Simple (unquoted) literals are used to name variables, functions, tables and __reserved keywords__.<br>
	<u>Attention</u>: Don't forget to add the <b>[]</b> sequence behind the literal if it shall be used as a variable and not as a string value because B4P
	interpretes stand-alone unquoted literals as string values.

	<br><br>
	Following rules apply:
	* They may consist of 1 or more words separated by white spaces (space bar, tab, etc.)
	* Multiple consecutive spaces in the literal will collapse to one space symbol (e.g. <b>Hello&nbsp;&nbsp;&nbsp;World</b> is the same as <b>Hello World</b>)
	* The literals may consist of both text and numbers separated with spaces, e.g. <b>4200 Pennsylvania Avenue</b>, or <b>Number 1</b> or <b>555 1212</b> (phone number is text because of space inside).
	* The literals must fit on the same line
	* Leading and trailing spaces are ignored
	* All characters are allowed, as long they do not interfere with the B4P programmin syntax. Example: The hyphen in <b>Baden-Baden</b> (a spa city in Germany) is interpreted \
	  as a minus sign and does a text subtraction of <b>Baden</b> and the outcome is an empty string.  In this case, specify <b>'Baden-Baden'</b> or <b>"Baden-Baden"</b> instead.
	* Reserved keywords are automatically treated as such, e.g. <b>true</b> as Boolean <i>true</i> and not as a string.



	+++,
    "Examples 01:"::
	echo( Hello World );
	echo( Hello   World   );	// Same as above
	echo( One + One );		// + sign is an operator, or specify 'One + One'
	echo( Dial 555 1212 );
	echo( this is on, new line, the next line );  // new line is a reserved keyword
	echo( Café in Zürich );		// Foreign characters inside
	+++,
    "Output 01:": "automatic"
},


"Softquoted Literals" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Softquoted Literals", "Softquoted Literal", "Entities" ],
    "Description 01:Introduction"::

	Softquoted literals are used to name variables and tables, but not functions and __reserved keywords__. Softquoted literals are literals specified with single quotation marks.  Follwing rules apply:
	* Use single quotation marks <b>' ... '</b> to contain the literal constants
	* Any character except line breaks and single quotation marks are allowed inside
	* The literal constant may contain multiple consecutive spaces
	* The literal constant may contain leading or trailing spaces, as long they are inside the quotation marks
	* <b>Character entities common in HTML</b> like &amp;euro; or &amp;#x20ac; for the EURO symbol &euro; are supported here
	* In various functions, __wildcard symbols__ in softquoted literals (e.g. *, ?, #, etc.) are used for flexible searching and comparison rules

	+++,
    "Examples 01:"::
	echo( 'Hello World' );
	echo( '  Hello   World  ' );
	echo( 'One + One' );
	echo( '"In double quotation Marks"' );
	echo( 'Price tags: &euro; 10.00, &#x20ac; 10.00, &#8364; 10.00');
	echo( '3 * 2 = 6' );
	echo( 'A cheap way to continue on&#10;the next line' ); // Not recommended. Use '...', new line, '...' instead.
	+++,
    "Output 01:": "automatic"
},


"Quoted Literals" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Quoted Literals", "Quoted Literal" ],
    "Description 01:Introduction"::

	Quoted literals are used to name variables and tables, but not functions and __reserved keywords__. Softquoted literals are literals specified with double quotation marks.  Follwing rules apply:
	* Use double quotation marks <b>" ... "</b> to contain the literal constants
	* Any character except line breaks and single quotation marks are allowed inside
	* The literal constant may contain multiple consecutive spaces
	* The literal constant may contain leading or trailing spaces, as long they are inside the quotation marks
	* Character entities are treated as they are, i.e. they are not converted to the specified characters.
	* Wildcard symbols are treated as they are, i.e. no wildcard features are applied for searching and comparing strings.

	+++,
    "Examples 01:"::
	echo( "Hello World" );
	echo( "  Hello   World  " );
	echo( "One + One" );
	echo( "'single quotation Marks'" );
	echo( "Price tags: &euro; 10.00, &#x20ac; 10.00, &#8364; 10.00"); // No translation of entities here
	echo( "3 * 2 = 6" );
	echo( "A cheap way to continue on&#10;the next line" ); // No translation of entitites here
	+++,
    "Output 01:": "automatic"
},



"Reserved Keywords" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "reserved keywords" ],
    "Keywords":			[ "reserved keyword" ],
    "Description 01:Introduction to reserved keywords"::
	B4P has only six reserved symbols which must be specified as __unquoted literals__, i.e. without quotation marks.

	=== 100, 200, 700, bold_column_1
	Keyword 	| Meaning 		| Description
	tab		| Tabulator 		| Converts to a tab character (ANSI and UNICODE 9)
	new line	| Line Break 		| Converts to CR+LF (Windows) or LF (LINUX) to continue on the next line
	escape		| Escape chracter 	| Converts to an escape character (ANSI and UNICODE 27)
	true		| Boolean true  	| 'true' as boolean type, not literal
	false		| Boolean false		| 'false' as boolean type, not literal
	else		| 'else' in code syntax | To be used in association with <b>if</b>, <b>switch</b> and other control flow functions
	===

	As explained before, flow control keywords like __if(__), __while(__), etc. are treated like function names. 


	+++,
    "Examples 01:"::
	echo( type(true) );
	echo( 1, tab, 2, tab, 3 );
	echo( 1st line, new line, 2nd line );
	echo( true = false ); // Outputs 'false' (Boolean comparison)
	+++,
    "Output 01:":		"automatic",
    "See also":			[ "Control flow functions" ]

},



"Numeric Constants" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Numeric Constants" ],
    "Description 01:Introduction"::

	In B4P, numeric constants express numeric values.  Following rules apply to both numeric values in B4P programs and
	B4P tables.

	* It must contain at least 1 digit (0..9)
	* The number must not contain spaces and/or thousand separator symbols.  Use __clean numeral(__) to remove such symbols.
	* At most one decimal point may be used.  More points inside make the value look like an __unquoted literal__.
	* Leading zeros in front and trailing zeros after the digits after the comma are OK
	* At present, scientific notation is not allowed in the B4P code
	** Exceptions: Table entries may contain numbers in scientific notation, but use __table configure(__) to activate reading scientific notation.
	** The function __numeral(__) supports scientific notation in literals provided.
	** Scientific notation is also supported in numers in JSON files. 
	* In B4P, the text representation of literals will be memorized and used for later outputting
	** Useful for maintaining numeric values such as postal codes (e.g. 02111 for Boston Chinatown) or section numbers (e.g. 2.10).
	** The text representation will be dropped when calculations are made with that number, even adding 0, multiplying by 1 or negating them.

	+++,
    "Examples 01:"::
	echo( 1 );                   // Simple numeral
	echo( 1 1 + 2 2 );           // Attention: These two numbers are literals : '1 12 2' is returned, not '33' or '3 3'
	echo( 123.45 );
	echo( 0123.450 );            // Same value as above
	echo( 0123.450 *1);          // Operation applied (multplied by 1), therefore text representation has been dropped
	echo( numeral( '1.2E+3' ) ); // Scientific notation (must contain capital or lower-case E, + is optional, use - (minus) for small numbers)
	+++,
    "Output 01:":		"automatic"

},




"Basic Data Types" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "basic data types" ],
    "Description 01:Basic Data Types"::

	B4P supports six basic data types for data storage in variables and in all calculations (variables and constant values retrieved and processed).
	Only the __tables__ support only one data type which are __literals__.  Numbers written to tables are converted to strings, and the other way
	around when reading numbers from the tables.

	* __Literals__
	** Unquoted literals
	** Softquoted literals
	** Quoted literals
	* __Numerals__
	** Numerals with text representations
	** Plain numerals
	* __Dates__, able to contain dates, times or both
	** Dates with text representations
	** Plain dates
	* __Booleans__
	* __Parameter sets__
	* __Voids__

	+++
  },


  "Literals" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types literals" ],
    "Keywords":			[ "literal", "literals" ],
    "Description 01:Literals"::

	Literals are text representations (strings) consisting of 0, 1 or any number of UNICODE characters.  Every UNICODE character counts as 1, even
	if they are not belong to the Basic Multilingual Plane.  There is no hard limitation on the number of characters which can be stored.  Only the available memory
	sets the limitations.

	The variables in B4P do distinguish among the three sub-types already explained in __literal constants__:
	* (Unquoted) literals,
	* Softquoted literals, and
	* Quoted literals.

	+++,
    "Examples 01:"::
	a[0] =  Hello World;       // (Unquoted) literal
	a[1] =    Hello  World  ;  // Multiple white spaces between collapse to 1 space. No leading or trailing spaces.
	a[2] = 'Hello World';      // Softquoted literal
	a[3] = 'Hello  World';
	a[4] = "Hello World";      // Quoted literal
	a[5] = "Hello  World";

	a[6] = 07.04.2020;         // Literal constant, because it contains two points
	a[7] = 555 1212;           // Contains a space
	a[8] = 1 Main St.;         // This is a valid literal constant
	a[9] = mike@example.com;   // Valid, too.  See note below.

	a[10] = a[0] + a[2];       // When calculating literals, then the higher quoted one applies.
	a[11] = a[0] + a[4];       // "


	// General advice: Please put literal constants containing @, #, %, \ and other special
	// symbols not (yet) part of the B4P language elements into quotation marks in order
	// to avoid any compatibility issues in the future.

	inspect( a[] );

	echo( a[0] = a[1] ); // True
	echo( a[0] = a[2] ); // True
	echo( a[0] = a[4] ); // True
	echo( a[3] = a[5] ); // True
	+++,
    "Output 01:Output:":		"automatic",

    "Description 02:Summary"::

	=== 400, 200, 200, 200, simple
	Item 					| (Unquoted) literal 		| Softquoted literal 					| Quoted literal
	Representation in B4P code text		| Alphanumeric contents		| Alphanumeric contents in single quotation marks	| Alphanumeric contents in double quotation marks
	Resolving __entities__ in B4P code text	| No				| Yes							| No
	Wildcard symbols used for comparisons	| No				| Yes							| No
	Leading and trailing white spaces	| No				| Yes							| Yes
	Multiple consecutive white spaces	| No (They reduce to 1 white space) 	| Yes						| Yes
	Line breaks in literal values		| No (use 'new line')		| No (use 'new line')					| No (use 'new line')
	===

	+++

  },



  "Literals - Indexing" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "literals indexing" ],
    "Keywords":			[ "literals indexing", "length of literals" ],
    "Description 01:Literals - Simple Indexing"::

	<i>Simple indexing</i> is used to retrieve single characters from the literal.  Indexing begins with 0 which refers to the 1st
	character.  The index value is specified in braces and shall not be confused with a parameter set as such.

	<br><br>
	Following rules apply to the indexing literals:
	* The index must always be a numeric value.
	* Specifying just braces <b>{}</b> without an index will retrieve the length (character count) of the literal.  Alternatively, use __length [string function]__.
	* Indexing begins with 0 (zero).
	* The value will be rounded in case it does not contain an integer value.  Example: <b>a[]{2.99}</b> accesses the same member as <b>a[3]</b>.
	* __Negative indexing__ is supported. -1 refers to the last character in the literal. -2, -3, etc. refer to the previous ones, and so forth.
	* Empty sets are returned when accessing with index values which lie out of bounds.  Example: <b>{a,b,c}{5}</b> returnss <b>{}</b> (empty set).
	* Updating individual elements on the left hand side of assignments is not possible.  Wrong exmaple: <b>a[]{3} = 'E';</b>.

    "Examples 01:"::
	echo( abcde{} );     // Returns 5 (character count)
	echo( abcde{0} );   // Access the 1st element
	echo( abcde{-2} );  // Access the 2nd last element
	echo( abcde{10} );  // Attempts to access characters outside the string returns blank literals.
	echo( abcde{-10} ); // Same case here.
	+++,

    "Output 01:Output:":		"automatic"

  },



  "Literals - Extracting Substrings" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types literals extracting substrings" ],
    "Keywords":			[ "literals extracting substrings" ],


    "Description 01:Literals - Extracting Substrings"::

	Instead of specifying single index values to retrieve single characters, substrings can be retrieved by listing muliple values and/or ranges.
	The range operator '..' is available to specify a range.  The result will always be a literal.
	
    "Examples 01:"::
	echo( abcdefg { 0,2,4,2,0 } );    // Returns 'aceca'
	echo( abcdefg { 3..5 } );         // Returns 'def'
	echo( abcdefg { 5..3 } );         // Empty string.  Ranges cannot be listed in reverse direction
	echo( abcdefg { -3..-1 } );       // Returns 'efg' - Last 3 characters
	echo( abcdefg { 4..-1 } );        // Same result
	echo( abcdefg { 3..99 } );        // Returns 'defg'
	echo( abcdefg { -99..2 } );       // Returns 'abc'
	echo( abcdefg { 0..2,5,1..3 } );  // Combinations
	+++,

    "Output 01:":		"automatic"
  },




  "Numerals" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types numerals" ],
    "Keywords":			[ "numeral", "numerals", "plain numeral", "plain numerals"  ],
    "Description 01:Numerals"::

	Numerals are numeric data representations which are internally handled as double precision floating point numbers.
	The same type is used for typical integer use (for example a loop index counting upwards, referencing a row number to the table) and
	advanced mathematical use.

	The variables in B4P do distinguish among the two sub-types:
	* Numerals with text represenatations
	* Plain numerals

	Numerals picked up from the B4P program code or read in from tables will initially carry along their original
	text representations.  They are useful in case the leading and trailing zeros in numbers (like in postal codes and section numbers)
	need to be preserved.  The literal representation will be discarded immediately when any kind of algorithmic operation
	is applied, even if 0 is added or 1 is mulitplied or the value is negated.  No discardings take place on direct assignments
	and transactions without calculations done, e.g. <b>a[] = b[];</b>.


	+++,
    "Examples 01:"::
	a[0] = 123.45;
	a[1] = 007;
	a[2] = 20.20;
	a[3] = numeral( '1.5E-3' ); // Literal representation will not be included here
	a[4] = 0.00;

	for all variables( a[], b[] )
	{
	    c[] = literal(b[]);  // Recover literal representation
	    d[] = b[] * 1;       // Literal representation gets dropped
	    e[] = literal(d[]);  // Recover literal representation again

	    echo(b[],"  ", c[], "  ", d[], "  ", e[], "  ", type detailed( b[] ) );
	}
	+++,
    "Output 01:":		"automatic"

  },


  "Dates" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types dates" ],
    "Keywords":			[ "date", "dates", "plain date", "plain dates"  ],
    "Description 01:Dates"::

	This data type can store pure dates (beginning 1990-01-01), time of day (down to the second), combination of both date and time of day, or <i>blank dates</i> which 
	are blank values neither containing dates or times.

	Following sub-types are supported for dates:
	* Dates with text represenatations
	* Plain dates (don't confuse with blank dates)

	<br>

	Dates read in from tables (if reading data as dates is activated with the function __table configure(__)) will automatically include their
	text representations.  The literal representation will be discarded immediately when any kind of algorithmic operation
	is applied, even if 0 days are added.  No discardings take place on direct assignments
	and transactions without calculations done, e.g. <b>a[] = b[];</b>.

	In B4P code, dates are created using the following functions listed below and the dates are created as plain dates without memorized text representation.

	=== 200, 800, noframe_1stcolbold
	Function name 	| Description
	__date(__)    	| Depending on the literal value provided, it returns a date, date and time, time only, or blank date.
	__pure date(__) | Works like date, but ignores any time of day information.  Output is either a date or blank date.
	__date time(__) | Works like date.  If input is not a blank, and if no time of day is provided, then 00:00:00 (midnight) is assumed as time of day.
	__time(__)	| This function will only use the time information.  If the paramter contains a date only, then a blank date wil be returned.
	===	

	Simple and valid examples are: <b>date( 14.07.2020 ), date( "2020-07-04" ), date( today )</b>. The values provided in the date functions are literal constants.
	Please note that quotation marks (no matter if single or double) are required for the 2nd example because of the hyphens which would otherwise be treated as
	minus signs where 7 and 4 are subtracted from 2020.

	+++,

    "Examples 01:"::
	d1[] = "14. July 2021";
	d2[] = "now";
	d3[] = "20:15:00";
	d4[] = ""; // Blank date
	
	echo("date     (): ", date(d1[]), ", ", date(d2[]), ", ",date(d3[]), ", ",date(d4[]), ", ", type detailed(date(d1[])) );
	echo("time     (): ", time(d1[]), ", ", time(d2[]), ", ",time(d3[]), ", ",time(d4[]), ", ", type detailed(time(d1[])) );
	echo("pure date(): ", pure date(d1[]), ", ", pure date(d2[]), ", ",pure date(d3[]), ", ",pure date(d4[]), ", ", 
			type detailed(pure date(d1[])) );
	echo("date time(): ", date time(d1[]), ", ", date time(d2[]), ", ",date time(d3[]), ", ",date time(d4[]), ", ", 
			type detailed(date time(d1[])) );

	echo;
	echo(date("31. March 2021"), " / ", type detailed(date("31. Dezember 2021")) );
	echo(date("2020 / 12 / 31 15:00")+1);		// Date and time
	echo(date time("2020-12-31"));			// Add a time (default 00:00:00)
	echo(time("2020-12-31 15:00"));			// Time
	echo(time("2020-12-31 15:00")+1/24);		// Time, 1 hour later
	echo(pure date("31. Dezember 2021")+1);		// Numeral
	+++,
    "Output 01:":		"automatic"



  },



"Booleans" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types booleans" ],
    "Keywords":			[ "boolean", "booleans"  ],
    "Description 01:Voids"::

	The boolean data type takes two values which are __reserved keywords__: <b>true</b> and <b>false</b>.<br>
	<u>Attention</u>: The keywords are case-sensitive. <b>True</b> and <b>TRUE</b> are a string values, as well as <b>'true'</b> and <b>"false"</b>.

    "Examples 01:"::
	echo(true, " / ", type(true));        // Boolean true
	echo(True, " / ", type(True));        // This is a literal value (T is upper case.)
	echo(5 > 6, " / ", type(5 > 6));      // Boolean false 
	+++,

    "Output 01:":		"automatic"

},





"Voids" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types voids" ],
    "Keywords":			[ "void", "voids"  ],
    "Description 01:Voids"::

	The void data type typically indicates an invalid value returned from a function or a variable with undefined values.
	The following table lists few approaches how to obtain a void value intentionally.

	=== 200, 800, noframe_1stcolbold
	Method	 		| Description
	__null(__)    		| Call the null function
	Undefined array member	| Create an array implicity, e.g. by assigning a[1] = 1;  Read-accessing a[0] will return <i>void</i>
	Reading JSON data	| Intermediate nodes carry no values and are <i>void</i>.  End nodes with value 'null' are also interpreted as <i>void</i>.
	===

	Please try to use void values as little as possible in your B4P programs.
	+++,

    "Examples 01:"::
	a[1] = 1;
	echo( a[0] );
	echo( null() );
	echo( type(null()) );
	+++,

    "Output 01:":		"automatic"

},



"Parameter sets" :
 {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets" ],
    "Keywords":			[ "parameter set", "parameter sets"  ],
    "Description 01:Parameter Sets"::

	Parameter sets is be considered as the sixth Basic Data Type which allows to hold 0, 1 or more elements.
	Each element is again a value of any of the six Data Types, including nested parameter sets.

	In the program code, sets can be defined with any number of values or expressions inside braces <b>{ }</b> and separated with commas. Nested parameter sets are supported.

	=== 250, 750, noframe_1stcolbold, noheader
	Number of elements	| At least zero (empty set)
	Empty sets		| Empty parameter sets { }are not the same as blank or void values
	Mixed data types	| A parameter set may contain data of different types, e.g. { 1, Abc, true, date(31.12.2020) }
	Nesting			| Parameter sets support nesting, e.g. { { 1, 2 }, { 3, 4 }, 5 }
	Nested empty sets	| Nested empty sets are allowed.  E.g. { {} } is not the same as { } or { { {} } }.
	Sequence of elements	| The sequence of elements is preserved, i.e. {a,b,c,d} and {d,c,b,a} are different.<br>Comparing them with '=' returns true (ordering does not care), but with '==' returns false (elements must be in same order).
	Mulitple identical elements | Parameter sets may contain multiple identical elements, e.g. { a, b, a, a, c, c }.  You can use the __trim(__) function to eliminate duplicates.
	Protection		| In contrast to variable array members and structure members, parameter sets provide no dedicated protection rules.
	Embedding		| A paramter set can be embedded into another parameter set, e.g. a[] = {1,2}; b[] = {a[]};
	__Parameter Set Indexing__	| One element can be extracted by indexing.  1st element begins wtih 0. Example:  a[] = {a,b,c,d}{1}; Here, the 1st element is accessed, a[] gets value 'b'.
	__Negative indexing__	| Negative indexing supported here. a[] = { a,b,c,d,e }{-2} assigns 'd' to a[].
	__Extracting subsets__	| Specify multiple index values and ranges to extract subsets.
	Arithmetics		| A broad range of arithmetic operators are available to manipulate parameter sets.
	===	
	+++,

    "Examples 01:"::
	a[] = { 1, a, 2, {b,c}, true, date(today) };
	echo( a[], " / ", type(a[]) );
	echo( "First element: ", a[]{0}, " and last element: ", a[]{1} );
	+++,

    "Output 01:":		"automatic"

  },


  "Parameter sets - Indexing" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets indexing" ],
    "Keywords":			[ "parameter set indexing", "length of parameter sets" ],
    "Description 01:Parameter Sets - Simple Indexing"::

	<i>Simple indexing</i> is used to retrieve single elements from the parameter set.  Indexing begins with 0 which refers to the 1st
	parameter set element.  The index value is specified in braces and shall not be confused with a parameter set as such.
	<i>Cascaded indexing</i> for retrieving elements from nested parameter sets is also supported. 

	<br><br>
	Following rules apply to the indexing parameter sets:
	* The index must always be a numeric value.
	* Specifying just braces {} without an index will retrieve number of elements (nested elements count 1) of the parameter set.
	* Indexing begins with 0 (zero).
	* The value will be rounded in case it does not contain an integer value.  Example: <b>a[]{2.99}</b> accesses the same member as <b>a[3]</b>.
	* __Negative indexing__ is supported. -1 refers to the last element. -2, -3, etc. refer to the previous elements.
	* Blanks are returned when accessing with index values which lie out of bounds.  Example: <b>Hello{5}</b> returns a blank value.
	* Updating individual characters on the left hand side of assignments not possible.  Exmaple: <b>a[]{3} = 123;</b>


    "Examples 01:"::
	echo( { a,b,c,d      } {0} );                     // Access the 1st element
	a[] = { a,b,c, {d,e,f}, g };                      // Assign a parameter set to variable a[]
	echo( "Last element            : ", a[]{-1} );    // Retrieve the last element
	echo( "Next element to the left: ", a[]{-2} );    // Retrieve the 2nd last element
	echo( "Cascaded indexing       : ", a[]{3}{2} );  // retrieve 3rd element, and inside the subset the 2nd element (cascaded indexing)
	echo( "# elements in           : ", a[]{} );      // Number of elements
	echo( "# elements in nested set: ", a[]{-2}{} );  // Number of elements in subset (cascaded indexing)
	echo( "Out of bounds case      : ", a[]{99} );    // Empty is returned if index lies out of bounds
	+++,

    "Output 01:":		"automatic",

    "Description 02:Parameter Sets - Simple Indexing in Write Accesses"::

	<i>Simple indexing</i> also works with write accesses in __assignments__.  The target variable must contain an existing parameter set.  Values of other types
	are not allowed and will cause error messages.  Any data type may be assigned. For example, a numeric element can be replaced by a literal or parameter set
	(a subset).  Using multiple indexes as allowed for read accesses is not possible (e.g. [a]{1,2} = {A,B};).

    "Examples 02:"::
	a[] = { a,b,c, {d,e,f}, g };                      // Assign a parameter set to variable a[]
	a[]{1} = B;
	a[]{-1} = {G,H,I};
	echo( "Modified value in a[] = ", a[] );
	+++,

    "Output 02:":		"automatic"

  },




  "Parameter sets - Extracting Subsets" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets extracting subsets" ],
    "Keywords":			[ "parameter sets extracting subsets", "extracting subsets" ],


    "Description 01:Parameter Sets - Extracting Subsets"::

	Instead of specifying single index values to retrieve single elements, subsets can be retrieved by listing muliple values and/or ranges.
	The range operator '..' is available to specify a range.  The result will always be returned in a parameter set, even if the subset
	specified results in just one element.

    "Examples 01:"::
	a[] = { a,b,c, {d,e,f}, g };                          // Assign a parameter set to variable a[]
	echo( "4 elements              : ", a[]{3,1,2,1} );   // Retrieves 4 elements (2 of them repeating here)
	echo( "2nd to 2nd last         : ", a[]{1..3} );      // Use a range
	echo( "2nd to 2nd last         : ", a[]{1..-2} );     // Same output
	echo( "2nd to 2nd last         : ", a[]{-4..3} );     // Same output (-4 = 4th last or 2nd element)
	echo( "1st element             : ", a[]{0..0} );      // Return 1st element, but in a subset and not alone
	echo( "Combinations            : ", a[]{2..4,1} );    // Combination of simple values and ranges
	+++,

    "Output 01:":		"automatic"
  },



  "Parameter sets - Value Ranges" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets value ranges" ],
    "Keywords":			[ "parameter set value ranges"],
    "Description 01:Parameter Sets - Simple Values"::

	Simple parameter set values are 0, 1 or more values of any types, regardless if values, variables, expressions or subsets, embedded inside braces
	and separated with commas. Example:  {} (empty set),  { 1, a, {} } (contains 2 values and nested a empty set), and { {1,2},{3,4} } describing a
	nested parameter set which looks like a 2-dimensional matrix and can be used as such.
	+++,


    "Description 02:Parameter Sets - Value Ranges (Numerals)"::

 	Simple parameter sets become cumbersome when describing a sequence of incrementing values, e.g. { 1,2,3,4,5,6,7,8,9,10 }, especially much bigger
	ones.  One way to do this is with a loop, but is cumbersome.  Alternatively, value ranges can be specified.  A range consists of a starting value
	and an ending value with '..' inbetween, e.g. { 1..10 }.  The increment is 1, unless a <i>second value</i> in the middle is specified, e.g. { 2..4..10 }
	to describe the 2nd value.  It may be bigger (for counting up), smaller (for counting down), but not equal to the 1st value (error message occurs).

	<br><br>
	A mixup of numerals and other types inside a range specification is invalid.
	+++,

    "Examples 02:"::
	print("Start with the classic way : ");
	a[] = {};
	for (i[]=1, i[]<=10, i[]++) a[] += {i[]};
	echo(a[]);

	echo("And the easy way           : ", {1 .. 10});
	echo("Steps of 2.5               : ", {1 .. 3.5 .. 10});
	echo("Steps of -1: Right way     : ", {10 .. 9 .. 1});
	echo("Steps of -1: Wrong way     : ", {10 .. 1}); // Returns empty set
	echo("Combination of 2 ranges    : ", {2..4..10, 20..40..100} );
	echo("Build a 3x3 matrix         : ", {{11..13},{21..23},{31..33}} );
	+++,

    "Output 02:":		"automatic",


    "Description 03:Parameter Sets - Value Ranges (Literals)"::

	Value ranges are also supported for literals.  The literal values may consist of one or more characters.  The intial value, optionally <i>second value</i>
	and final values must contain literals with same number of characters and <u>only one character in the same position changing</u>.
	An exception applies if the literal contains numeric digits.  Here, up to 8 digits are allowed.  This allows counting from smaller numbers (fewer digits)
	to larger numbers (more digits).  Minus signs are not considered as part of numbers. A mixup of literals and other types inside a range specification is invalid.
	
	<br>
	Following exampls are invalid: 
	<br>{1 .. '5'}  (Type mixup)
	<br>{Option A .. option C } (1st and last characters are different)
	<br>{Option A .. Option   } (final value has fewer characters),
	<br>{Option A .. Option AA} fails because final value has more characters, and
	<br>{Point -3 .. Point 3  } fails because minus sign is an extra character.
	<br>Valid examples: See below

    "Examples 03:"::
	echo("Start simple               : ", {a..z});
	echo("Every 2nd letter           : ", {a..c..z});
	echo("1 letter in string         : ", {'Article A:' .. 'Article F:'} );
	echo("Combination of 2 ranges    : ", {2..4..10, 'Article A:' .. 'Article F:'} );
	echo("Numbers in literals        : ", {'Chapter 9:' .. 'Chapter 12:'} );
	echo("Numbers in literals        : ", {'Chapter 09:' .. 'Chapter 12:'} );
	+++,

    "Output 03:":		"automatic",


    "Description 04:Parameter Sets - Value Ranges (Dates)"::

	Unique to Beyodn4P, Value ranges are also supported for dates and times.  If the value consists of
	both date and time value, then the range may only be applied either on the date (with time kept
	unchanged) or time (with date kept unchanged).

	<br><br>
	For dates, the default increment is +1 day.  For times, the default increment is +1 hour.  Use the <second value>
	to influence the interval.  Both positive and negative intervals are allowed.  Time counting must not pass
	across midnights to cover additional days.


    "Examples 04:"::
	echo("Dates                       : ", { date(30.03.2016) .. date(02.04.2016) });
	echo("Dates, 3 day intervals      : ", { date(01.04.2016) .. date(04.04.2016) .. date(10.04.2016) });
	echo("Today to yesterday - bad    : ", { date(today) .. date(today)-1 });
	echo("Today to yesterday - OK     : ", { date(today) .. date(today)-1 .. date(today)-1 });
	echo("Times, 1 hour intervals     : ", { time("12:15:00")..time("15:15:00") });
	echo("Times, 5 minute intervals   : ", { time("12:15:00")..time("12:20:00")..time("12:30:00") });
	echo("30 seconds back - bad       : ", { time(now) .. time(now)-30/(24*60*60) });
	echo("30 seconds back, 10s interv.: ", { time(now) .. time(now)-10/(24*60*60) .. time(now)-30/(24*60*60) });
	echo("Changing dates              : ", { date("05.06.2016 10:00:00")..date("08.06.2016 10:00:00") });
	echo("Changing times, seconds     : ", { date("05.06.2016 10:00:00")..date("05.06.2016 10:00:01")..date("05.06.2016 10:00:03") });


	+++,

    "Output 04:":		"automatic"

  },


  "Parameter sets - Value Repetitions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets value repetitions" ],
    "Keywords":			[ "parameter set value repetitions", "value repetition", "value repetitions"],
    "Description 01:Parameter Sets - Value Repetitions"::

	Large parameter sets with same values repeating can be built up with value repetitions.  Repetitions are specified by numeric values following
	a colon symbol and following the paramter set element to repeat.  Multiple repetitions may be specified inside a parameter set value.

    "Examples 01:"::

	echo({ 5:0 } );              // Generates { 0,0,0,0,0 }
	echo({ 2:3,3:2 } );          // Generates { 3,3,2,2,2 }
	echo({ 0.9:A } );            // Generates { A }  Rounded up
	echo({ 0.1:A } );            // Generates { }  Rounded down
	echo({ 2:Hello } );          // Generates { Hello,Hello}
	echo({ 0:Hello } );          // Generates { }
	echo({ -2:Hello } );         // Generates { }
	echo({ 3:{a,b} } );          // Generates { {a,b},{a,b},{a,b} }
	echo({ 2:{3:1} } );          // Generates { {1,1,1},{1,1,1} }
	echo({ 2:{1..4} } );          // Generates { {1,2,3,4},{1,2,3,4} }
	+++,

    "Output 01:":		"automatic"

},


"Directories and Files" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Directory and files" ],
    "Keywords":			[ "directories", "files"],
    "Description 01:Introduction"::

	Special care has been taken with accessing directories and files as well as specifying directory and
	file names in order to achieve an optimum cross-platform portability, able to run on Windows, UNIX/Linux and MacOS platforms.
	They cover issues as little as directory separator symbols in path names, using the right line break character sequences,
	chosen character sets and country-specific differences in files considered highly standardized and generic which they are not.

	<br><br>
	Following aspects are described next:

	* Path and File Names
	* Loading files - character sets
	* Saving files - character sets
	* CSV file format - local differences

	+++
},



"Path and File Names" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "path names" ],
    "Keywords":			[ "path name", "path names", "file name", "file names" ],
    "Description 01:Introduction to portable Path Names"::

	The different operating systems (Windows, Linux, MacOS) use different conventions to specify drives, directory path names
	and file names.  Directory separators (slash or backslash) is one example.  FUll case sensitivity of path and file names in LINUX and MACOS
	environments is another example. B4P supports various measures in order to make path and file naming more portable for the applications.

	* Both directory separator symbols "/" (UNIX/ / LINUX style) and "\" (WINDOWS style) are supported.  They will be changed to the right symbol automatically before accessing directories and files in the present operating system.
	* Returned directory and file names, e.g. in directory listings, __search files(__) function, etc. will use the directory separator native to the operating system (e.g. "/" under LINUX).
	* Under LINUX and MACOS, the file names are fully case sensitive.
	* Under Windows, case sensitivity only applies to creating new directory and file names.
	* Please avoid using following special symbols in file names:
	** : Colon - Used to specify drives in Windows environments
	** ", ' quotation marks - Not valid as part of file name.  Quotation marks may be needed at command level to specify path and file names containing spaces, but not to be done in B4P code.
	** *, ? wildcard symbols
	** , comma - B4P uses commas to specify multiple file names, e.g. in the __directory listing(__) function
	** & ampersand - Typically a control symbol for operating system command shells
	** &lt;, &gt;, | - Rediction and piping
	** /, \ - Directory separators
	* Further OS-specific restrictions on path and file names may apply
	* __Wildcard symbols__ are resolved by B4P and not by the operating system.

	+++

},




"Loading Files - Character sets" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "loading files" ],
    "Description 01:Introduction"::

	Beyond4P checks all files (programs and data) opened for <i>Byte Order Marks</i> (BOM) at the beginning of the file.  The BOM is a UNICODE character and used to differentiate between
	UTF-16 big endian, UTF-16 little endian and UTF-8 file formats.  All formats are supported, whereas UTF-8 is by far the most common UNICODE data storage format
	as it is compatible to various legacy systems supporing 8-byte character sets only.

	<br><br>
	<b>Data transparency:</b> The byte order marks will be recognized and then discarded, i.e. not passed on as special characters to the application.
	<br><br>

	How BOM's are checked in files loaded or opened:
	* If the 2 byte sequence FE FF (hexadecimal) is found, then the text file is in UTF-16 big endian format. 
	* If the 2 byte sequence FF FE (hexadecimal) is found, then the text file is in UTF-16 little endian format.
	* If the 3 byte sequence EF BB BF (hexadecimal) is found, then the text file is in UTF-8 format.
	* Some files contain multiple identical BOMs. They have been sighted in export files from relational databases.

	In case no BOM is found, following checks will be applied throughout the first ca. 4000 – 8000 bytes in the file (and not the entire file for performance reasons):
	* NULL-characters / 00 (hexadecimal) in even numbered positions (first byte in file is position 0): File is UTF-16, big endian format.  <br>Example: 00 31   00 30   00 20   20 AC   00 0D   00 0A  (10 € followed by new line sequence CR+LF). <br>Even for <i>difficult</i> contents such as pure Chinese text, the UTF-16 will be identified from space symbols (00 20), numeric digits and CR+LF symbols.
	* NULL-characters / 00 (hexadecimal) in odd numbered positions: File is UTF-16, little endian format.  <br>Example: 31 00   30 00   20 00   AC 20   0D 00   0A 00  (10 € followed by new line sequence CR+LF)

	If the criteria above do not apply, then the file will be checked for typical UTF-8 patterns in the first 4000-8000 bytes, provided the file contains non-ANSI characters.

	* Presence of non-ANSI symbols which make up typical UTF-8 byte patterns.  These are 2, 3 or 4 symbols with specific binary patterns.
	* Presence of non-ANSI symbols which do not match with UTF-8 byte patterns, e.g. simple 8-bit text in a ISO 8859-1 or WIN 1252 format with single non-ANSI characters
	* If the 1st criteria applies, but the 2nd does not, then the file is in UTF-8 format.
	* If the 2nd criteria applies, but the 1st does not, then the assumption will be non-UNICODE file format WIN 1252 which is the West European 8-bit character set.

	If the input file is in HTML format, then the "charset=…" commands will be checked accordingly.  JSON files are assumed in UTF-8 format by default.
	Ambiguities may still apply in the following case:
	* 1 line of UTF-16 text containing foreign characters only and new line sequence, e.g. one sentence in Greek, Cyrillic or Chinese (without digits, spaces, new lines).
	* 8-bit text file without non-ANSI character in the first 4000-8000 bytes (lots of English text in a huge file, a foreign word such as Café follows in a concluding sentence at the end of the file.

	Ambiguities need to be resolved with the system variable <b>local settings [ input file character set ]</b>.
	As long no clear character format has been identified (e.g. UTF-16 or UTF-8), then the local settings will be referenced.  The initial default value is win1252 (American and West European character set).

	<br><br>
	Supported character sets summarized<br>

	=== 200, 300, 500
	Character Set | Format | Description
	ANSI 		| 8 bits, 7 of them used 	| Traditional ANSI characters.  All non-ANSI characters, including foreign characters, the Euro symbol, etc. are converted into question marks. <br>Examples: E  e
	iso8859-1	| 8 bits			| ANSI characters plus West European character set in the range between 0xA0 (160) and 0xFF (255). <br> This format does not support Windows proprietary character range between 0x80 (128) and 0x9F (159) which affects the Euro symbol (€). <br>Examples: E  e  É  é
	win1252		| 8 bits, <br> default setting for Windows | Same as above, but includes Windows proprietary character range so additional punctuation symbols as well as the Euro symbol (€) will be handled correctly. <br>Examples: E  e  É  é  €
	utf-8		| 8 bits			| UNICODE format.  Characters can take 1, 2, 3 or 4 byes.<br>Examples: E  e  É  é  €  Ə  ə  中国  𐌄 (also applicable in next rows below)
	utf-16		|16 bits (little endian)	| UNICODE format. Every character contains precisely 2 bytes, starting with the least significant byte.  Surrogate pairs are used for characters outside Basic Multilingual Plane.
	utf-16 big endian | 16 bits (big endian)	| UNICODE format like above, but the two bytes are swapped. Surrogate pairs are used for characters outside Basic Multilingual Plane.
	===

	Note: Microsoft Excel does not understand utf-16 big endian, but understands the remaining UNICODE formats.  Use this format only if the recipient (e.g. a UNIX server) operates on big endian format only.

	<br><br>
	JSON files are always loaded assuming that UTF-8 format is used.
	+++

},



"Saving Files - Character sets" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "saving files" ],
    "Description 01:Introduction"::

	The chosen file format either depends on the format specified in a parameter in the __table save(__) function call, 
	or it refers to the default setting stored in the __system variable__ <b>local settings [ output file character set ]</b>. If not modified by the user, 
	this file contains the value UTF-8. Files saved in UNICODE-format (UTF-8 and UTF-16 formats) will always begin start with corresponding Byte Order Marks.
	This allows other applications to recognize and interpret the contents correctly.  This does effectively apply to Excel when reading comma or tab separated
	file formats (.csv format).<br>
	<br>Text files under Windows contain "carriage return + line feed" line breaks. 
	<br>Text files under LINUX contain "line feed" line breaks.
	<br>You can change the setting with by setting system variable <b>runtime settings [ crlf ]</b> to true (enabled) or false (disabled)

	<br><br>
	JSON files are always saved in UTF-8 format.

	+++

},



"CSV File Format" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "CSV" ],
    "Keywords":			[ "CSV" ],
    "Description 01:CSV File Format"::

	The CSV (Comma Separated Values) is a simple structured text file format existing since the nostalgic 1970's along with the introduction of FORTRAN 77 and is supported by
	Beyond4P, along with HTML/MHTML, XML and JSON.

	<br><br>
	THe biggest drawback is the ignorance towards country settings.  CSV generated from Excel files use symbols such as
	* List separator (could be commas, semicolons, tab stops, etc.)
	* Decimal point (as used in US, GB, CH) or decimal comma (as used in DE)
	* Thousand separator (various symbols and blanks exist)

	The files can be loaded with and without specifying the list separators.  If no list separator is specified, then Beyond4P tries to automatically detect the
	applicable separators by checking for commas, semicolons and tabs.

	Regarding decimal symbols, the standard function __table load(__) will check for numerals in text and CSV files (but not HMTL files and likes) with decimal 
	commas and convert them to decimal points.  The new function __table load unchanged(__) will not do the conversion.  You may need this if you need to
	discriminate between actual numbers and other numeric data separated with commas but not considered as regular numeric data. 
	<br/>Consider using the __clean numeral(__)
	function to prepare numbers containing commas (and possibly more, such as thousand separators, currency symbols, etc.).
	<br/>Consider using __table save with local decimal separator(__) to save CSV files using the decimal separator symbol applicable with your country settings (comma or point).
	<br/>Consider using __table save with decimal comma(__) to make sure all numbers use decimal commas.
	<br>The original function __table save(__) saves numbers with decimal points, regardless of the applicable country settings.
	
	<br><br>

	Notice on files with fixed column widths: The best is to load these files with "new line" as separator symbol so the table contains one item per row.
	Then create additional columns with dedicated data items using the __left(__) / __middle(__) / __right(__) functions where you can specify numeric column positions, 
	and remove redundant white space symbos with the __trim(__) function.
	
	+++
},


"Locales" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Locales" ],
    "Keywords":			[ "list of Locales", "locale" ],
    "Description 01:Introduction"::

	Beyond4P is able to support different locales (regional and language specific settings) which are managed in 
	a file called "List of locales.csv".  This file comes along with the installation package and will be referenced automatically
	whenever locale information is needed to carry out a particular function, e.g. converting a __date__ to a __literal__.

	<br><br>
	The locale settings influence information processing such the following described below:

	* Region-specific number formats (choice of decimal and thousand separator symbols)
	* Date formats (e.g. MM/DD/YYYY or DD/MM/YYYY as default)
	* Weekday and month names in different languages
	* Using the right list separator for loading and saving CSV files for interaction with Excel (some countries-specific installations use comma, others use semicolon)
	* Currency names and symbols

	+++,
    "Description 02:Specifying locales"::
	Locales typical comprise of a combination of abbreviated language name followed by country name with an underscore symbol inbetween, e.g. "de_CH" for
	<b>German language, Switzerland</b>.  You may also specifc country or language names only, however they create ambiguitiess with countries where more than
	one language is spoken (or better: supported, e.g. Canada), and languages which are spoken in several countries (e.g. English).

	<br><br>
	For all functions asking for <i>locale</i> parameters, you can specify the locale, the language or the country.  No case sensitvity applies, meaning that
	both "en_US" and "EN_us" are accepted, as well as "USA" and "usa".  If only the language or the country is chosen, then the first match applies.
	Therefore, make it a habit to specify locales precisely using the pair of abbreviations.

	<br><br>
	Special values:
	* none = Apply no locale specific context
	* local = Apply presently appliable settings, either set during program installation, or modified with __set locale(__) function call.


	+++,
    "Description 03:Functions asking for locales"::

	* __literal(__), __softquoted literal(__): 2nd function parameter
	* __set locale(__): 1st function parameter (must be a locale value, not country or language name alone=)

	+++,
    "Description 04:Supported locales"::

	=== 100, 100, 100, 700
	Locale		| Language	| Country		| Explanation
	none		| none		| none			| Suppresses thousand separator, date is in universally recognized YYYY-MM-DD format
	en_US		| English	| USA			| Decimal point, 1000-comma, M/D/YYYY
	en_GB		| English	| Great Britain		| Decimal point, 1000-comma, DD/MM/YYYY
	en_CA		| English	| Canada		| Decimal point, 1000-comma, DD/MM/YYYY
	en_DE		| English	| Germany		| Decimal comma, 1000-point, DD/MM/YYYY, weekday and month names are in English
	en_CH		| English	| Switzerland		| Decimal comma, 1000-point, DD/MM/YYYY, weekday and month names are in English
	en_AT		| English	| Austria		| Decimal comma, 1000-point, DD/MM/YYYY, weekday and month names are in English
	en_FR		| English	| France		| Decimal comma, 1000-space, DD/MM/YYYY, weekday and month names are in English
	en_SE		| English	| Sweden		| Decimal comma, 1000-space, YYYY-MM-DD, weekday and month names are in English
	en_IN		| English	| India			| Decimal point, 1000-comma, D/M/YYYY, weekday and month names are in English, <br>Note: Different thousand-separation scheme applies in India: 12,34,567.89 
	in_IN		| Indian	| India			| Decimal point, 1000-comma, D/M/YYYY, <br>Note: Different thousand-separation scheme applies in India: 12,34,567.89
	de_CH		| German	| Switzerland		| Decimal point, 1000-apostrophe, DD.MM.YYYY
	de_DE		| German	| Germany		| Decimal comma, 1000-point, YYYY-MM-DD
	de_AT		| German	| Austria		| Decimal comma, 1000-space, DD.MM.YYYY
	de_IT		| German	| Italy			| Decimal comma, 1000-point, DD.MM.YYYY, weekday and month names are in German
	fr_CA		| French	| Canada		| Decimal point, 1000-space, YYYY-MM-DD, weekday and month names are in French
	fr_FR		| French	| France		| Decimal comma, 1000-space, DD.MM.YYYY
	fr_CH		| French	| Switzerland		| Decimal comma, 1000-space, DD.MM.YYYY, weekday and month names are in French
	fr_BE		| French	| Belgium		| Decimal comma, 1000-space, D/MM/YYYY, weekday and month names are in French
	it_IT		| Italian	| Italy			| Decimal comma, 1000-point, DD/MM/YYYY
	it_CH		| Italian	| Switzerland		| Decimal point, 1000-apostrophe, DD.MM.YYYY, weekday and month names are in Italian
	es_ES		| Spanish	| Spain			| Decimal point, 1000-comma, D/MM/YYYY
	es_US		| Spanish	| USA			| Decimal point, 1000-comma, M/D/YYYY, weekday and month names are in Spanish
	sv_SE		| Swedish	| Sweden		| Decimal comma, 1000-space, YYYY-MM-DD
	===

	+++

},




"Miscellaneous Features" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Miscellaneous Features" ],
    "Description 01:Introduction"::

	Miscellaneous features descrbed next include:

	* Setting __verbose levels__ to facilitate monitoring and debugging program execution, and 
	* __Negative Indexing__
	
	+++
},



"Verbose Levels" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "verbose" ],
    "Keywords":		[ "verbose levels" ],
    "Description 01:Verbose Level Settings"::

	The __system variable__ <b>runtime settings[verbose]</b> rules the amount of additional console output messages to be generated which
	could be helpful for developing the code and monitoring program execution.  The default verbose setting is <b>low</b>.  This setting can be changed anytime.
	In addition, if the B4P program is called from command line, the command line switches <b>-q</b> and <b>-w</b> will set this setting to <b>quiet</b>.

	<br><br>
	Following verbose settings are supported:

	<b>quiet</b><br>
	* No additional output is generated other than explicitly instructed in the B4P programs, e.g. using __echo(__) or __print(__).
	* However, error messages and important warning messages will definitely appear.

	<b>low</b>: in addition to 'quiet' (default setting):

	* Outputs progress info (percentage figures shown) if selected functions are processing big amount of data (e.g. large tables, large variable trees)
	* Short feedback messages on tables and variables loaded and saved (name of file, number of rows, etc.)
	* Info about standard B4P library files loaded (e.g. Support Library)
	* Some warnings, e.g. obsolete character sets found in input files

	<b>medium</b>: in addition to 'low':

	* Outputs the function names for the more sophisticated functions (e.g. __table consolidate(__) is included, but __abs(__) is not in order to avoid excessive messages) with first few paramters
	* Informs about the intermediate processing steps inside selected functions, e.g. __table load excel file(__)

	<b>high</b>: in addition to 'medium':

	* In addition to the function names printed out, all parameters provided will also be shown.
	* Further information on intermediate processing steps inside selected functions, e.g. __table merge (__)

	+++
},



"Negative Indexing" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "negative indexing" ],
    "Description 01:Introduction"::

	Python, a common programming language, supports negative indexing for arrays.  B4P applies negative indexing on a broader range.  Typically, the -1
	refers to the last element, with -2, -3, etc. referring to the elements further up (or leftward).  At present, negative indexing is used in the following:

	* Arrays (-1 = last element)
	* Table row numbers (-1 = last row)
	* Table column number (-1 = last column.  Few exceptions exists where -1 refers to a vacant column after the last one, and is documented so if it applies)
	* Parameter set elements (-1 = last parameter set element)
	* Function parameters (in selected functions where documented)

	Negative numbers must be at least big enough in order to access the first element / row / column.  Going further will result in exceptions (error messages).

	+++,
    "Examples 01:Programming example"::
	array( a[], { ha, he, hi, ho, hu } );
	structure( b[], { reptile, mammal, bird, fish }, { turtle, deer, swallow, dorade } );
	c[] = { Hah, Heh, Hih, Hoh, Huh };

	echo( a[-2], "  ", a[-1] ); // ho, hu
	echo( b[-2], "  ", b[-1] ); // deer, turtle (last two acc. to alphabetic order of structure members)
	echo( c[]{-2}, "  ", c[]{-1} ); // Hoh, Huh

	echo(new line, "Example with tables:");
	table initialize( t, { { Last Name, First Name, Street, City, Country }, 
	    { Adams, Abel, Main St, S. Francisco, USA }, { Billson, Bill, South St, London, UK } } );

	echo( [t:-2,-1] ); // Last row, 2nd last column.  It's 'London'.
	echo( [t:-1,-1] ); // Last row, last column.  It's 'UK'.	
	+++,
    "Output 01:Outcome": "automatic"
},



"Language Pitfalls" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Language pitfalls", "Hijacking parameters" ],
    "Description 01:Introduction"::

	The syntactic and semantic structure of B4P allow powerful features such as multiple-word naming for variables, functions and tables, as well as
	other benefits.  However, even experienced programmers trip into some pitfalls.  This section makes you aware of the most the most common pitfalls.

    "Description 02:Brackets follow Variable Names"::

	In regular programming languages, keywords are treated as reserved keywords or variables.  In B4P, they are unquoted literals.  To use these literals
	to access variables, do not forget to add <b>[]</b> behind it.  No differnece applies if you access a subscript of an array or a structure, e.g. <b>a[10]</b>.


    "Description 03:For loops - Different from C/C++ and Java"::

	In conventional languages, the three key statements inside for loops are separated by semicolons, e.g. <b>for( a = 1; a < 10; a++ )</b>.  To make things
	even wordse, multiple statements inside the three statements are separted by commas.

	<br><br>

	In B4P, __for(__) is treated like a __procedure call__ where parameters are separated with commas and not with semicolons.  This function accepts
	__code pieces__ as parameters.  Multiple statements inside a parameter are separated with semicolons. Right formulation: <b>for ( a[]=1, a[]<10, a[]++)</b>.

    "Description 04:Comparison Operators Hijack Parameters"::

	If you are comparing things using the <b>=</b> or <b>&lt;&gt;</b> symbols, note that these two __comparison operators__ (but not <b>==</b> and <b>!=</b>) can expect
	more than 1 operand.  For example, <b>a[] = 2,3,5,7,11 </b> is a legitimate expression to compare a[] with five different prime numbers.

	<br><br>

	With b[] = 6, the expression <b>a[] = { 1, b[]=5, 6, 7, 8 }</b> is actually resulting <b>{ 1, true }</b> because the comparison has hijacke the remaining
	parameters in the parameter set.  Add parenthese to avoid this, e.g. <b>a[] = { 1, (b[]=5), 6, 7, 8 }</b> which returns <b>{1, false, 6, 7, 8}</b>.
	Note that the same hijacking 

    "Description 05:Memory Effect on Table Headers"::

	Please see the details on the __Memory Effect__	when referencing table heades with string values as they are normally
	checked once and the column number will be memorized for future use in order accelerate performance significantly.


    "Description 06:Forgetting colon before 'else'"::

	Since B4P's unique cababilties of supporting multi-word identifiers for variables, tables and function names, one drawback needs to be covercome:
	Whenever single __statements__ follows __else__, then a colon is needed to keep them separated.  
	* Correct: <b>... else : a[] = 1;</b>
	* Misleading: <b>... else a[] = 1;</b> Here, 1 is assigned to a variable called <b>else a</b>.
	* No issues with __blocks__: <b>... else { a[] = 1; } </b>


	+++
}







B4PDOCU.STOP