//
B4PDOCU.START



"Formulas and Operators" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "formulas and operators" ],
    "Description 01:Introduction"::

	Formulas are expression which contains a combination of the following algorithms:
	* Constants (numerals, literals, Booleans, dates etc.)
	* __Parameter sets__
	* __Variables__ and __references to variables__
	* References to __tables__
	* Operators
	** __Unary operators__ (e.g. minus sign for negation)
	** __Binary operators__ (arithmetic, comparison and logical operators)
	* Parenthses (to influence the calculation precedence)

	<br>
	The following sections provide further details on the operators.

    "Description 02:Calculation Precedence Rules"::

	=== 100, 200, 700, bold_column_1 bold_column_2
	Precedence	| Symbols	| Description
	1 (highest)	| +, -, ~, !	| All unary operators
	2		| *, /		| Arithmetic operators: multiplication and division
	3		| +, -		| Arithmetic operators: addition and subtraction
	4		| =, ==, &lt;&gt;, !=, &gt, &gt;, &lt;, &lt;= | Comparison operators
	5 (lowest)	| &amp;, &vert;	| Logical operators
	===
	<br>
	Use parentheses to influence the precedence, e.g. <b>2*(5+7)</b> returns 24 and not 17.

	+++
},



"Unary Operators" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "unary operators" ],
    "Description 01:Introduction"::

	<br/><img src="Images/Description_Formulas_Unary_Operators.jpg" alt="Unary Operators"><br/>

	<sup>1</sup> First character is capitalized.  All other characters are not touched.<br>
	<sup>2</sup> Mirroring, example: !{a,b,c} returns {c,b,a}.  Contents in nested parameter sets remain unaffected (no mirroring there).<br>
	<sup>3</sup> Sorting order across different data types: parameter set > literal > date > numeral > boolean, then followed by contents if types are equal. For sets with common contents and different lengths,
	             the longer one is considered as the "greater" one.  Nested sets will also be sorted.

	+++,
    "Examples 01:"::
	a[0] = -1;
	a[1] = -'heLLO world';
	a[2] = +'heLLO world';
	a[3] = !'heLLO world';
	a[4] = ~ Hello World;
	a[5] = + { 3, a, f, { a, b, d}, { c, a, b }, 1, true, date(today), 5, b,  };
	a[6] = - { 3, a, f, { a, b, d}, { c, a, b }, 1, true, date(today), 5, b,  };
	a[7] = + false;
	a[8] = - false;
	a[9] = + true;
	a[10] = - true;
	a[11] = ! true;

	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 01:": "automatic"
},


"Arithmetic Operators" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "arithmetic operators" ],
    "Description 01:Introduction"::
	Arithmetic operators cover the four basic mathematical operations:
	* __addition__
	* __subtraction__
	* __multiplication__
	* __division__

	The operators can also be imposed on non-numeric data types which result in different operations (e.g. string operations)
	or implicit conversion to numerals before operation (e.g. boolean values converted to 0 or 1 before operation is carried out).

+++

},


"Additions" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "addition" ],
    "Description 01:Introduction"::

	Basic rules to additions:
	* Numbers are added together as learnt in 1st grade.
	* Boolean values are converted to 0 and 1 first.
	* Literal strings are catenated.
	* The elements in parameter sets are also catenated.
	* Special rules apply on arithmetics with dates and times which are described further below.
	* Special rules apply to some operations with different data types.  See the table below for details.
	

	<br/><img src="Images/Description_Formulas_Additions.jpg" alt="Additions"><br/>

	+++,
    "Examples 01:"::
	a[0] = 5 + 3;
	a[1] = Hello + ' ' + World;
	a[2] = 0.5 + true;
	a[3] = { a, b, c } + { c, d };

	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 01:": "automatic",
    "Description 02:Addition of Dates"::

	Note that value of type date may assume 4 states: date only, time only, date and time combined and blank date (no value).  Even for the same operator,
	the rules of calculating dates and numeric operands differ.

	<br/><img src="Images/Description_Formulas_Additions_of_Dates.jpg" alt="Additions"><br/>

	'Date 1' and 'Time 1' refer to the data from the left operand whereas 'Date 2' and 'Time 2' refer to the right operand.<br>
	<sup>1</sup> Only fractional part (digits behind decimal point) are used to add time value.  Value must be between 0 and (24*60*60-1)/(24*60*60).  Calculated sum must lie within 00:00:00 and 23:59:59.<br>
	<sup>2</sup> Only the integer (whole number before decimal point) is used for the calculation.<br>
	<sup>3</sup> Sorting order across different data types: parameter set > literal > date > numeral > boolean, then followed by contents if types are equal. For sets with common contents and different lengths,
	             the longer one is considered as the "greater" one.  Nested sets will also be sorted.

	+++,
    "Examples 02:"::
	d [] = date('2020-07-14');
	dt[] = date('2020-07-14 12:30:00');
	t [] = date('09:15:00');
	o [] = date(''); // blank date

	a[0] = d[] + 3.25;     // Just integer is used
	a[1] = dt[]+ 3.25;    // 3 days, 6 hours
	a[2] = t[] + 0.25;     // 6 hours
	a[3] = d[] + t[];     // Date + time combind
	a[4] = d[] + true;     // add 1 day
	a[5] = o[] + d[];      // Add date to blank date

	for all variables( a[], b[] ) echo( b[] );

	+++,
    "Output 02:": "automatic"
},


"Subtractions" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "subtraction" ],
    "Description 01:Introduction"::

	Basic rules to subtractions:
	* Numbers are subtracted from each other as learnt at school.
	* Boolean values are converted to 0 and 1 first.
	* Literal strings: The first occurrences of the (sub-)string in the right operand found in the left operand will be removed, but not all.
	* Parameter sets: The first occurrences of the elements in the right operand found in the left operand will be removed, but not all.
	* Special rules apply on arithmetics with dates and times which are described further below.
	* Special rules apply to some operations with different data types.  See the table below for details.


	<br/><img src="Images/Description_Formulas_Subtractions.jpg" alt="Subtractions"><br/>


	+++,
    "Examples 01:"::
	a[0] = 5 - 3;
	a[1] = Hello - ell;
	a[2] = 0.5 - true;
	a[3] = { a, b, c, c } - { c, d }; // Removes one c, not all

	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 01:": "automatic",
    "Description 02:Subtraction of Dates"::

	Note that value of type date may assume 4 states: date only, time only, date and time combined and blank date (no value).  Even for the same operator,
	the rules of calculating dates and numeric operands differ.

	<br/><img src="Images/Description_Formulas_Subtractions_of_Dates.jpg" alt="Additions"><br/>

	'Date 1' and 'Time 1' refer to the data from the left operand whereas 'Date 2' and 'Time 2' refer to the right operand.<br>
	<sup>1</sup> Only fractional part (digits behind decimal point) are used to add time value.  Value must be between 0 and (24*60*60-1)/(24*60*60).  Calculated sum must lie within 00:00:00 and 23:59:59.<br>
	<sup>2</sup> Only the integer (whole number before decimal point) is used for the calculation.<br>
	<sup>3</sup> Sorting order across different data types: parameter set > literal > date > numeral > boolean, then followed by contents if types are equal. For sets with common contents and different lengths,
	             the longer one is considered as the "greater" one.  Nested sets will also be sorted.

	+++,
    "Examples 02:"::
	d [] = date('2020-07-14');
	dt[] = date('2020-07-14 12:30:00');
	t [] = date('09:15:00');
	o [] = date(''); // blank date

	a[0] = d[] - 3.25;    // Just integer is used
	a[1] = dt[]- 3.25;    // 3 days, 6 hours
	a[2] = t[] - 0.25;    // 6 hours
	a[3] = d[] - true;    // subtract 1 day

	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 02:": "automatic"
},


"Multiplications" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "multiplication" ],
    "Description 01:Introduction"::

	Basic rules to subtractions:
	* Numbers are multiplied with each other as learned in business school (probably a bit too late).
	* Boolean values are converted to 0 and 1 first.
	* Parameter sets: Parameter sets can be multiplied with numbers in order to repeat the elements.
	* Special rules apply to some operations with different data types.  See the table below for details.

	<br/><img src="Images/Description_Formulas_Multiplications.jpg" alt="Multiplications"><br/>

	+++,
    "Examples 01:"::
	a[0] = 5 * 3;
	a[1] = '' * 10; // Blank = 0
	a[2] = 0.5 * true;
	a[3] = { a, b, c } * 3; // Repetition
	a[4] = { a, b, c } * 0; // Empty set

	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 01:": "automatic"

},


"Divisions" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "division" ],
    "Description 01:Introduction"::

	Basic rules to divisions:
	* Numbers are divided with each other as learned in 2nd grade.
	* Boolean values are converted to 0 and 1 first.
	* Literal strings: All occurrences of the (sub-)string in the right operand found in the left operand will be removed.
	* Parameter sets: All occurrences of the elements in the right operand found in the left operand will be removed.
	* Special rules apply on arithmetics with dates and times which are described further below.
	* Special rules apply to some operations with different data types.  See the table below for details.

	<br/><img src="Images/Description_Formulas_Divisions.jpg" alt="Divisions"><br/>

	+++,
    "Examples 01:"::
	a[0] = 5 / 3;
	a[1] = '' / 10; // Blank = 0
	a[2] = 0.5 * true;
	a[3] = { a, b, c, c, d } / { b, c }; // Removes all matching elements
	a[4] = This is a great tiger / i; // All i's removed

	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 01:": "automatic"

},



"Comparison Operators" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "comparison operators" ],
    "Description 01:Introduction"::
	Unlike other programming languages which define 6 comparison operators, B4P supports 8 comparison operators and a few modifiers:
	* <b>&lt;</b> Less than
	* <b>&le;</b> Less than or equal to
	* <b>&gt;</b> Greater than
	* <b>&ge;</b> Greater than or equal to
	* <b>=</b> Equal to, expecting 1 or more operands separated by comma (comparing with a selection of values) and/or ranges.  
	* <b>&gt;&lt;</b> Not equal to, expecting 1 or more operands separated by comma (comparing with a selection of values) and/or ranges.
	* <b>==</b> __strictly Equal__ to, expecting 1 operand only
	* <b>!=</b> __strictly not equal__ to, expecting 1 operand only

	Comparisons with b>=</b> and <b>&gt;&lt;</b> are more tolerant in comparing numbers and strings containing numbers, and also support
	wildcard symbols on the right-hand operands if they are defined as softquoted literals (e.g. values in single quotation marks, not double).

	+++,
    "Description 02:Attention! = and &lt;&gt; may Hijack Parameters"::

	<u>Attention</u>: As the two comparison operators <b>=</b> and <b>&gt;&lt;</b> expect 1 or more operands on the right hand side,
	you may risk situations where the comparison hijacks the remaining comma-separated values on the right-hand-side typically encountered
	in function parameters and values in parameter sets.  To avoid this, put the comparison into parentheses, or use the <b>==</b> and <b>!=</b>
	symbols.
	+++,
    "Examples 02"::
	b[] = 12; 
	// Want to compare b[] == 9 and include the result in the parameter set between 'false' and 12
	// Good luck!

	a[0] = { 3, 6, false, b[] =  9 , 12, 15 }; // Comparison has hijacked the last two parameters
	a[1] = { 3, 6, false,(b[] =  9), 12, 15 }; // OK
	a[2] = { 3, 6, false, b[] == 9 , 12, 15 }; // OK

	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 02": "automatic"
},



"Equal to" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "equal to" ],
    "Description 01:Introduction"::

	Basic rules to equal-to comparisons which are a bit more relaxed than the __strictly equal to__ comparison operator:
	* The number of operands on the right-hand-side is not limited to 1.  A selection of multiple values may be specified as well as ranges.
	* __Wildcards__ are supported in the right-hand operand if the value is a softquoted literal (e.g. specified inside single quotation marks)
	* When comparing parameter sets, the same elements in both left and right hand side must exist, but they do not need to be in the same order
	* Dates, Booleans and numerals can be compared with literals if they have the same text value / literal representation (e.g. if printed out). Example: '5' = 5, and 'true' = true are both true.
	* Comparing two void values will always return true.

	<br/><img src="Images/Description_Formulas_Equal_to.jpg" alt="Comparison Equal to"><br/>

	<sup>1</sup> If a numeral is compared with a literal, then a literal copy will be made of the numeral and both literals are compared.<br>
	<sup>2</sup> If a date is compared with a literal, then a literal copy will be made of the date and both literals are compared.  Depending on the state of the date, the format is "YYYY-MM-DD", "HH:II:SS", or "YYYY-MM-DD HH:II:SS".<br>
	<sup>3</sup> If a boolean value is compared with a literal, then a literal copy will be made of the boolean value and both literals are compared.<br>
	<sup>4</sup> Contents in both sets must be the same, but the ordering does not matter.  E.g. {1,2,3} = {3,2,1} returns true.


	+++,
    "Examples 01:"::
	echo("Basic comparisons:");

	a[0] = 3 = 3;		// true
	a[1] = 5.1 = 5;         // false
	a[2] = 5 = 2,3,5,7;     // true
	a[3] = 5 = 2,2+1,5,7;	// true
	a[4] = 5 = 1..3;	// false
	a[5] = 5 = 4..7;	// true
	a[6] = 5 = 1..3,5,7;	// true
	a[7] = {1,2,3} = {3,2,1}; // true

	for all variables( a[], x[] ) echo( x[] );

	echo("Literal with other types:");

	b[0] = 123 = "123";         // true
	b[1] = '123' = 123;         // true
	b[2] = false = 'false';     // true
	b[3] = false = 'False';     // false
	b[4] = date("2020-08-01") = "2020-08-01";  // true
	b[5] = date("2020-08-01") = "01.08.2020";  // false
	// The last one is 'false' because literal representation of date is YYYY-MM-DD

	for all variables( b[], x[] ) echo( x[] );

	echo("Compare with wildcards:");

	c[0] = Hello World = '*o*'; // Contains 0, true
	c[1] = Hello World = "*o*"; // Not equal to string "*o*", false
	c[2] = Hi = 'Ha,Hi,Ho';     // Wildcard with commas, true
	c[3] = Hi = Ha,Hi,Ho;       // Selection with commas, true

	for all variables( c[], x[] ) echo( x[] );
	+++,
    "Output 01:": "automatic",
    "Description 02:Comparing Dates"::

	Note that value of type date may assume 4 states: date only, time only, date and time combined and blank date (no value).  Even for the same operator,
	the rules of calculating dates and numeric operands differ.

	<br/><img src="Images/Description_Formulas_Equal_to_of_Dates.jpg" alt="Comparison Equal to of dates"><br/>
	
	Note that in some cases, only the time or only the dates are compared.

	+++,
    "Examples 02:"::
	d [] = date('2020-07-14');
	dt[] = date('2020-07-14 12:30:00');
	t [] = date('12:30:00');
	o [] = date(''); // blank date
	dz[] = date('2020-07-14 12:30:01');

	a[0] = d[] = dt[];   // true, dates same, time not compared
	a[1] = t[] = dt[];   // true, times same, date not compared
	a[2] = d[] = date("2020-07-15") - 1; // true
	a[3] = dt[] = dz[];   // false (time differs)
	
	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 02:": "automatic"
},



"Not Equal to" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "not equal to" ],
    "Description 01:Introduction"::

	Basic rules to not-equal-to comparisons which are a bit more relaxed than the __strictly not equal to__ comparison operator:
	* The number of operands on the right-hand-side is not limited to 1.  A selection of multiple values may be specified as well as ranges.
	* __Wildcards__ are supported in the right-hand operand if the value is a softquoted literal (e.g. specified inside single quotation marks)
	* When comparing parameter sets, the same elements in both left and right hand side must exist, but they do not need to be in the same order
	* Dates, Booleans and numerals can be compared with literals if they have the same text value / literal representation (e.g. if printed out). Example: '5' = 5, and 'true' = true are both true.
	* Comparing two void values will always return true.

	<br/><img src="Images/Description_Formulas_Not_Equal_to.jpg" alt="Comparison not Equal to"><br/>


	<sup>1</sup> If a numeral is compared with a literal, then a literal copy will be made of the numeral and both literals are compared.<br>
	<sup>2</sup> If a date is compared with a literal, then a literal copy will be made of the date and both literals are compared.  Depending on the state of the date, the format is "YYYY-MM-DD", "HH:II:SS", or "YYYY-MM-DD HH:II:SS".<br>
	<sup>3</sup> If a boolean value is compared with a literal, then a literal copy will be made of the boolean value and both literals are compared.<br>
	<sup>4</sup> Contents in both sets must be the same, but the ordering does not matter.  E.g. {1,2,3} = {3,2,1} returns true.

	+++,
    "Examples 01:"::
	echo("Basic comparisons:");

	a[0] = 3 <> 3;		// false
	a[1] = 5.1 <> 5;         // true
	a[2] = 5 <> 2,3,5,7;     // false
	a[3] = 5 <> 2,2+1,5,7;	// false
	a[4] = 5 <> 1..3;	// true
	a[5] = 5 <> 4..7;	// false
	a[6] = 5 <> 1..3,5,7;	// false
	a[7] = {1,2,3} <> {3,2,1}; // false

	for all variables( a[], x[] ) echo( x[] );

	echo("Literal with other types:");

	b[0] = 123 <> "123";         // false
	b[1] = '123' <> 123;         // false
	b[2] = false <> 'false';     // false
	b[3] = false <> 'False';     // true
	b[4] = date("2020-08-01") <> "2020-08-01";  // false
	b[5] = date("2020-08-01") <> "01.08.2020";  // true
	// The last one is 'true' because literal representation of date is YYYY-MM-DD

	for all variables( b[], x[] ) echo( x[] );

	echo("Compare with wildcards:");

	c[0] = Hello World <> '*o*'; // Contains o, false
	c[1] = Hello World <> "*o*"; // Not equal to string "*o*", true
	c[2] = Hi <> 'Ha,Hi,Ho';     // Wildcard with commas, false
	c[3] = Hi <> Ha,Hi,Ho;       // Selection with commas, false

	for all variables( c[], x[] ) echo( x[] );
	+++,
    "Output 01:": "automatic",
    "Description 02:Comparing Dates"::

	Note that value of type date may assume 4 states: date only, time only, date and time combined and blank date (no value).  Even for the same operator,
	the rules of calculating dates and numeric operands differ.

	<br/><img src="Images/Description_Formulas_Not_Equal_to_of_Dates.jpg" alt="Comparison Equal to of dates"><br/>
	
	Note that in some cases, only the time or only the dates are compared.

	+++,
    "Examples 02:"::
	d [] = date('2020-07-14');
	dt[] = date('2020-07-14 12:30:00');
	t [] = date('12:30:00');
	o [] = date(''); // blank date
	dz[] = date('2020-07-14 12:30:01');

	a[0] = d[] <> dt[];   // false, dates same, time not compared
	a[1] = t[] <> dt[];   // false, times same, date not compared
	a[2] = d[] <> date("2020-07-15") - 1; // false
	a[3] = dt[] <> dz[];   // true (time differs)
	
	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 02:": "automatic"
},


"Strictly Equal to" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "strictly equal to" ],
    "Description 01:Introduction"::

	Basic rules to strictly-equal-to comparisons:
	* The number of operands on the right-hand-side is always 1.  No risk of hijacking parameters.
	* Contents are compared strictly, i.e. data type and contents must match perfectly.  No wildcards are supported here.
	* Comparing values of different types, e.g. numerals with literals, will always be unequal.
	* When comparing parameter sets, the same elements in both left and right hand side must exist, and they need to be in the same order.
	* Comparing two void values will always return true.

	<br/><img src="Images/Description_Formulas_Strictly_Equal_to.jpg" alt="Comparison Equal to"><br/>

	<sup>1</sup> Contents in both sets must be the same and in the same ordering E.g. {1,2,3} = {3,2,1} returns false.

	+++,
    "Examples 01:"::
	echo("Basic comparisons:");

	a[0] = 3 == 3;             // true
	a[1] = 5.1 == 5;           // false
	a[2] = {1,2,3} == {3,2,1}; // false
	a[3] = {1,2,3} == {1,2,3}; // true

	for all variables( a[], x[] ) echo( x[] );

	echo("Literal with other types always return false:");

	b[0] = 123 == "123";         // false
	b[1] = '123' == 123;         // false
	b[2] = false == 'false';     // false
	b[3] = date("2020-08-01") == "2020-08-01";  // false

	for all variables( b[], x[] ) echo( x[] );
	+++,
    "Output 01:": "automatic",
    "Description 02:Comparing Dates"::

	Note that value of type date may assume 4 states: date only, time only, date and time combined and blank date (no value).  Even for the same operator,
	the rules of calculating dates and numeric operands differ.

	<br/><img src="Images/Description_Formulas_Strictly_Equal_to_of_Dates.jpg" alt="Comparison Equal to of dates"><br/>

	+++,
    "Examples 02:"::
	d [] = date('2020-07-14');
	dt[] = date('2020-07-14 12:30:00');
	t [] = date('12:30:00');
	o [] = date(''); // blank date
	dz[] = date('2020-07-14 12:30:01');

	a[0] = d[] != dt[];   // true (one contains time, the other not)
	a[1] = t[] != dt[];   // true (one contains date, the other not)
	a[2] = d[] != date("2020-07-15") - 1; // false
	a[3] = dt[] != dz[];   // true (time differs)
	
	for all variables( a[], b[] ) echo( b[] );

	+++,
    "Output 02:": "automatic"
},



"Strictly Not Equal to" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "strictly not equal to" ],
    "Description 01:Introduction"::

	Basic rules to strictly-equal-to comparisons:
	* The number of operands on the right-hand-side is always 1.  No risk of hijacking parameters.
	* Contents are compared strictly, i.e. data type and contents must match perfectly.  No wildcards are supported here.
	* Comparing values of different types, e.g. numerals with literals, will always be unequal.
	* When comparing parameter sets, the same elements in both left and right hand side must exist, and they need to be in the same order.
	* Comparing two void values will always return true.

	<br/><img src="Images/Description_Formulas_Strictly_Not_Equal_to.jpg" alt="Comparison not Equal to"><br/>

	<sup>1</sup> Contents in both sets must be the same and in the same ordering E.g. {1,2,3} = {3,2,1} returns false.

	+++,
    "Examples 01:"::
	echo("Basic comparisons:");

	a[0] = 3 != 3;             // false
	a[1] = 5.1 != 5;           // true
	a[2] = {1,2,3} != {3,2,1}; // true
	a[3] = {1,2,3} != {1,2,3}; // false

	for all variables( a[], x[] ) echo( x[] );

	echo("Literal with other types always return false:");

	b[0] = 123 != "123";         // true
	b[1] = '123' != 123;         // true
	b[2] = false != 'false';     // true
	b[3] = date("2020-08-01") != "2020-08-01";  // true

	for all variables( b[], x[] ) echo( x[] );
	+++,
    "Output 01:": "automatic",
    "Description 02:Comparing Dates"::

	Note that value of type date may assume 4 states: date only, time only, date and time combined and blank date (no value).  Even for the same operator,
	the rules of calculating dates and numeric operands differ.

	<br/><img src="Images/Description_Formulas_Not_Equal_to_of_Dates.jpg" alt="Comparison Equal to of dates"><br/>
	
	Note that in some cases, only the time or only the dates are compared.

	+++,
    "Examples 02:"::
	d [] = date('2020-07-14');
	dt[] = date('2020-07-14 12:30:00');
	t [] = date('12:30:00');
	o [] = date(''); // blank date
	dz[] = date('2020-07-14 12:30:01');

	a[0] = d[] != dt[];   // true (one contains time, the other not)
	a[1] = t[] != dt[];   // true (one contains date, the other not)
	a[2] = d[] != date("2020-07-15") - 1; // false
	a[3] = dt[] != dz[];   // true (time differs)
	
	for all variables( a[], b[] ) echo( b[] );

	+++,
    "Output 02:": "automatic"
},



"Smaller than (or Equal to)" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "smaller than or equal to" ],
    "Keywords":			[ "smaller than" ],
    "Description 01:Introduction"::

	Basic rules to smaller than / smaller than or equal to comparisons:
	* Contents are compared strictly, i.e. data type and contents must match perfectly.  No wildcards are supported here.
	* Comparing values of different types, e.g. numerals with literals, will always return false.
	* When comparing parameter sets, the sorting order of the parameter is compared.

	<br/><img src="Images/Description_Formulas_Smaller_than_or_Equal_to.jpg" alt="Comparison Smaller than (or Equal to)"><br/>

	<sup>1</sup> When comparing parameter sets, the following sorting order across different data types applies: parameter set > literal > date > numeral > boolean, 
	then followed by contents if types are equal. For sets with common contents and different lengths,
	the longer one is considered as the "greater" one.  Nested sets will also be compared.

	+++,
    "Examples 01:"::
	echo("Basic comparisons:");

	a[0] = 3   <  3;            // false
	a[1] = 3   <= 3;            // true
	a[2] = 4.9 <  5;            // true
	a[3] = Ha  < He;            // true (sorting order)
	a[4] = {1,2,3} <  {3,2,1};  // true
	a[5] = {1,2,3} <  {1,2,3};  // false
	a[6] = {1,2,3} <= {1,2,3};  // true
	a[7] = {1,2,3} < {1,2,3,4}; // true
	a[8] = false < true;        // true
	a[9] = a < 1;               // always false

	for all variables( a[], x[] ) echo( x[] );
	+++,
    "Output 01:": "automatic",
    "Description 02:Comparing Dates"::

	Note that value of type date may assume 4 states: date only, time only, date and time combined and blank date (no value).  Even for the same operator,
	the rules of calculating dates and numeric operands differ.

	<br/><img src="Images/Description_Formulas_Smaller_than_or_Equal_to_of_Dates.jpg" alt="Comparison Smaller than (or Equal to) of dates"><br/>

	+++,
    "Examples 02:"::
	dt1[] = date('2020-07-14 12:30:00');
	dt2[] = date('2020-08-01 06:45:00');
	d1 [] = date('2020-07-14');
	d2 [] = date('2020-08-01');
	t1 [] = date('12:30:00');
	t2 [] = date('06:45:00');

	a[0] = dt1[] < dt2[]; // true
	a[1] = dt1[] < t2 []; // Times compared, false
	a[2] = dt2[] < d1 []; // Dates compared, false
	a[3] = dt2[] < t2 []; // Times compared, false
	a[4] = dt2[] <=t2 []; // Times compared, true
	a[5] = dt1[] < d1 []; // Dates compared, false
	a[6] = dt1[] <=d1 []; // dates compared, true
	a[7] = dt1[] < dt1[]; // false
	a[8] = dt1[] <=dt1[]; // true

	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 02:": "automatic"
},



"Greater than (or Equal to)" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "greater than or equal to" ],
    "Keywords":			[ "greater than" ],
    "Description 01:Introduction"::

	Basic rules to greater than / greater than or equal to comparisons:
	* Contents are compared strictly, i.e. data type and contents must match perfectly.  No wildcards are supported here.
	* Comparing values of different types, e.g. numerals with literals, will always return false.
	* When comparing parameter sets, the sorting order of the parameter is compared.

	<br/><img src="Images/Description_Formulas_Greater_than_or_Equal_to.jpg" alt="Comparison Greater than (or Equal to)"><br/>

	<sup>1</sup> When comparing parameter sets, the following sorting order across different data types applies: parameter set > literal > date > numeral > boolean, 
	then followed by contents if types are equal. For sets with common contents and different lengths,
	the longer one is considered as the "greater" one.  Nested sets will also be compared.

	+++,
    "Examples 01:"::
	echo("Basic comparisons:");

	a[0] = 3   >  3;            // false
	a[1] = 3   >= 3;            // true
	a[2] = 4.9 >  5;            // false
	a[3] = Ha  > He;            // false (sorting order)
	a[4] = {1,2,3} >  {3,2,1};  // false
	a[5] = {1,2,3} >  {1,2,3};  // false
	a[6] = {1,2,3} >= {1,2,3};  // true
	a[7] = {1,2,3} > {1,2,3,4}; // false
	a[8] = false > true;        // false
	a[9] = a > 1;               // always false

	for all variables( a[], x[] ) echo( x[] );
	+++,
    "Output 01:": "automatic",
    "Description 02:Comparing Dates"::

	Note that value of type date may assume 4 states: date only, time only, date and time combined and blank date (no value).  Even for the same operator,
	the rules of calculating dates and numeric operands differ.

	<br/><img src="Images/Description_Formulas_Greater_than_or_Equal_to_of_Dates.jpg" alt="Comparison Greater than (or Equal to) to of dates"><br/>

	+++,
    "Examples 02:"::
	dt1[] = date('2020-07-14 12:30:00');
	dt2[] = date('2020-08-01 06:45:00');
	d1 [] = date('2020-07-14');
	d2 [] = date('2020-08-01');
	t1 [] = date('12:30:00');
	t2 [] = date('06:45:00');

	a[0] = dt1[] > dt2[]; // false
	a[1] = dt1[] > t2 []; // Times compared, true
	a[2] = dt2[] > d1 []; // Dates compared, true
	a[3] = dt2[] > t2 []; // Times compared, false
	a[4] = dt2[] >=t2 []; // Times compared, true
	a[5] = dt1[] > d1 []; // Dates compared, false
	a[6] = dt1[] >=d1 []; // dates compared, true
	a[7] = dt1[] > dt1[]; // false
	a[8] = dt1[] >=dt1[]; // true

	for all variables( a[], b[] ) echo( b[] );
	+++,
    "Output 02:": "automatic"
},


"Logical Operators" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "logical operators" ],
    "Description 01:Introduction"::
	Logical operators cover the follwoing two operators:
	* __logical and__
	* __logical or__

	The operators are only applicable to boolean values and parameter sets.

+++

},


"Logical And" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "logical and" ],
    "Description 01:Introduction"::

	Basic rules to logical AND (Symbol: <b>&amp;</b>):
	* For boolean values the logical AND operator is applied.
	* For parameter sets, the intersection of equal elements will be identified.
	* All other data types wll be rejected

	<br/><img src="Images/Description_Formulas_Logical_And.jpg" alt="Logical And"><br/>

	+++,
    "Examples 01:"::
	echo("On boolean values:");

	a[0] = false & false;
	a[1] = true & false;
	a[2] = true & true;

	for all variables( a[], x[] ) echo( x[] );

	echo("On parameter sets:");

	b[0] = { a, b, c, 1, 2 } & { d, f, 3 }; // Empty set
	b[1] = { a, b, c, 1, 2 } & { c, b, 3 }; // {b, c}
	b[2] = { a, b, c, 1 ,2 } & { 1, 2, c }; // {c, 1, 2}
	b[3] = { a, b, b, c } & { b, a, b, b }; // {a, b, b}

	for all variables( b[], x[] ) echo( x[] );
	+++,
    "Output 01:": "automatic"

},

"Logical Or" :
{
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "logical or" ],
    "Description 01:Introduction"::

	Basic rules to logical OR  (Symbol: <b>&vert;</b>):
	* For boolean values the logical OR operator is applied.
	* For parameter sets, the union of equal elements will be identified.
	* All other data types wll be rejected

	<br/><img src="Images/Description_Formulas_Logical_Or.jpg" alt="Logical Or"><br/>

	+++,
    "Examples 01:"::
	echo("On boolean values:");

	a[0] = false | false;
	a[1] = true | false;
	a[2] = true | true;

	for all variables( a[], x[] ) echo( x[] );

	echo("On parameter sets:");

	b[0] = { a, b, 1 } | { 1, b, a }; // {a, b, 1}
	b[1] = { a, b, 1 } | { 1, b, c }; // {a, b, 1, c}
	b[2] = { a, b, b } | { b, b, c }; // {a, b, b, c}

	for all variables( b[], x[] ) echo( x[] );
	+++,
    "Output 01:": "automatic"

}





B4PDOCU.STOP