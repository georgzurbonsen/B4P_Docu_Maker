//
B4PDOCU.START

  "Functions and Procedures" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Functions and Procedures" ],
    "Description 01:Introduction"::

	Functions and procedures are subroutines which can be called using their name.  For simplicity, all such subroutines will be referred to as
	<i>functions</i> throughout the B4P documentation, regardless if they are called up as procedures (without using the return value provided)
	or as functions (with return values being used).  B4P provides an extensive library of standard functions, with focus on processing
	sophisticated tables and data structures.  In addition, you can define your own __user functions__ or even create own libraries containing
	user functions.

	<br><br>

	Different from quasi all other programming languages, B4P function names may consist of multiple words with spaces inbetween.
	Function names are case sensitive and always specified as as unquoted literals, i.e. quotation marks are not allowed in order to refer
	to a fancy function name.  Because function names are unquoted literals, the number of spaces (or tabs) between the individual words is
	irrelevant, but must be at least one.  The first two function names listed below are equivalent, but the remaining ones are not.  

	* <b>table process(...)</b>
	* <b>table&nbsp;&nbsp;&nbsp;process&nbsp;&nbsp;(...);</b> // Same as 'table process'
	* <b>tableprocess(...)</b> // 'tableprocess' differs from 'table process'
	* <b>Table process(...)</b> // Upper case letter
	* <b>table_process(...)</b> // <i>Snake case</i>: Underscore and other symbols differ from spaces.
	* <b>Table-process(...)</b> // <i>Kebab case</i>: Likely wrong. Attempts to subtract return value of <b>process(...)</b> from the string 'Table'.

	<br><br>

	Functions may require no, a fixed number or a variable number of __function parameters__ with different __function parameter directions__.

	<br><br>

	The difference between procedures and functions is that procedures do not provide return values but functions do.  Where allowed,
	functions can also be called as procedures.

	=== 200, 600, 200, bold_column_1 bold_column_3
	Function Nature		| Description					| Exmaples
	Function		| The function will always provide a return value and can only be called inside expressions where the return value is used further. | a[] = abs( 1.5 );<br>echo( sqrt( 81 ) );
	Procedure		| The function will not provide return values and must be called as procedures.  If no parameters are supplied, then the function name can be used alone with semicolon at the end. | echo;<br>echo();<br>echo(Hello);
	Procedure or function	| The function can be called as procedrues or functions. Use of return value is voluntary. | table rename headers(...);<br>a[] = table rename headers(...);
	Control flow functions	| __Control flow functions__ require a succeeding statement or code block which will be executed as specified by these functions.  The __if(__) statement is one of them. | if (a[]=1) echo("is 1");
	===	

	+++
   },


  "Function Parameters" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Function Parameters" ],
    "Description 01:Introduction"::

	Depending on their specifications, B4P functions can take a fixed or variable number of parameters.  For variable number of parameters,
	the minimum required, maximum allowed (or no limitation), and increments (e.g. min 2, max 11, increments of 3 means allowing 
	2, 5, 8 or 11 parameters) are defined.

	Function parameters can be values, variables (including references to variables), expressions, table references and __code pices__.
	Details are ruled in the respective function definitions.

	<br><br>

	The ability to pass __code pieces__ as parameters into functions, which are then executed by the function once or repeatedly on when needed,
	are unique to B4P and not common in other programming languges. This feature is actually used in control flow funtions (e.g. __if(__),
	__while(__), etc.) which are, in other languages, defined as fixed keywords and are inherent parts of the programming language.  
	In addition, this feature allows convenient operations through tables without specifying loops, e.g. with the __table process(__) function.

	<br><br>

	Depending on the specific functions, they may acceept parameters with values of any type (e.g. numerals only), a combination of them, or
	or any type.  Type checking of the function parameters happen before the actual function is executed.  Type mismatches will be report
	as exceptions (error messages).  Various functions dealing with tables do also accept __table columns as function parameters__ which is a flexible parameter
	type and accepts one of the following: individual header names, individual column numbers or several of them provided in a __parameter set__ variable.


	<br><br>

	B4P supports different __parameter directions__: Input, output, input/output, __variable references__ and __code pieces__.
	Functions may require no, a fixed number or a variable number of __function parameters__.


	+++
   },



  "Function Parameter Directions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Function parameter directions", "parameter directions" ],
    "Description 01:Introduction"::

	B4P distinguishes among following function parameter directions which are described next.

	=== 200, 150, 150, 200, 200, bold_column_1
	Direction			| Constants 	| Expressions 	| Variables			| Table references
	Input parameters		| allowed	| allowed	| allowed (must be defined)	| allowed
	Output parameters		| not allowed	| not allowed	| allowed (may be defined)	| allowed
	Input / output parameters	| not allowed	| not allowed	| allowed (must be defined)	| allowed
	References			| not allowed	| not allowed	| allowed (must be defined)	| not allowed
	__Code pieces__			| 		| 		| See section on __code pieces__   | 
	===

	+++,
    "Description 02:Input Parameters"::

	The parameters supplied to the function are values.  They can be constants, existing __variables__, __table references__,
	and any form of right-hand expressions containing calculations and/or other function calls.  Variables passed as paramters
	must be defined (i.e. values assigned) prior to calling the function.

	+++,
    "Examples 02:"::
	a[] = World;
	echo( "Hello ", a[], ' ', abs(-1)+2+3 );
	+++,

    "Output 02:": "automatic",

    "Description 03:Output Parameters"::

	The parameters must either be a __variable__ or __table reference__, similar to left-hand side of assignment statements.
	Constants and calculated expressions are not allowed.  Before the function is called, variables which are not yet existing,
	will be defined automatically. After the function call has been completed, the value will be written back to the variable or table.

	+++,
    "Examples 03:"::
	a[] = find( 'Say Hi!', { Ha, HÃ¤, He, Hi, Ho }, 0, which[] );
	echo( which[] ); // 3, because Hi is in position 3 in the parameter set
	+++,

    "Output 03:": "automatic",

    "Description 04:Input / Output Parameters"::

	The parameters must either be an existing __variable__ or __table reference__, similar to left-hand side of assignment statements.
	Constants and calculated expressions are not allowed.
	Before the function is called, the value will be retrieved from the variable or table.  After the function call has been completed,
	the value will be written back to the table.

    "Examples 04:"::
	table initialize( t, {{ Hi, He }} );
	a[] = Ho;
	exchange( [t:0,0], a[] );
	echo( [t:..,0], " and ", a[] );
	+++,

    "Output 04:": "automatic",

    "Description 05:References"::

	Some functions take over the reference to the variables provided in the function parameters.  References provide following benefits:
	* Higher performance (no payload data, e.g. big parameter sets, are copied in before the call and copied back after the call)
	* Direct access to the variable contents, especially in __user procedures__ and __user functions__
	* Access to member variables (__structure__ and __array__ members and their sub-members if available)
	* Access to variable properties, e.g. __variable protection__ settings.

	The following code example shows how the user-defined procedure <b>my funct</b> accesses a member variable and defines an additional
	member variable.

	+++,
    "Examples 05:"::
	define procedure( my func, { { a, all, reference } } )
	{
	    echo(a[one]);
	    a[two] = TWO;
	}
	
	b[one] = ONE;
	my func( b[] );
	echo(b[two]);
	+++,

    "Output 05:": "automatic",
    "Description 06:Code Pieces"::

	Passing code pieces as function parameters is a unique feature in B4P.  Code pieces can either be provided directly or as a literal string.
	When the function is called, the code piece is checked for correct syntax.  While the function is running, the code pieces provided may be
	called multiple times, or in specific cases not at all.

	<br><br>
	See section on __code pieces__ for further details.
	+++
  },





  "Function Parameter Types" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Function parameter types" ],
    "Description 01:Introduction"::

	B4P supports different parameter types (e.g. literal, etc.) as well as more specialized parameter types.

	=== 200, 800, bold_column_1
	Parameter Types		| Description
	All			| Accepts 
	Numeral			| Accepts numerals and expressions returning numeral values
	Literal			| Accepts unquoted, softquoted and quoted strings and expressions returning strings
	Boolean			| Accepts <b>true</b>, <b>false</b> or expressions returning boolean values, e.g. comparisons
	Date			| Accepts dates and/or time values or expressions returning date/time values.
	Date or literal		| In this case, literals will be converted to dates automatically, e.g. "29.Feb. 20" to 2020-02-29, or "today" to today's date
	Parameter set		| Accepts parameter sets or expressiosn returning parameter sets
	Combinations of above	| Various functions accept values of different types
	Table columns		| Parameter to specify one or multiple table columns in a flexible way. See section on __table columns as function parameters__.
	Parameter set or literal| Various functions accept either parameter sets or literals.  See section on __parameter set or literal__  for details
	All types		| Accepts values of all types, including void
	Valid types		| Accepts values of all types, except void
	Variable		| __Code piece__, expecting a variable name
	Comparison expression	| __Code piece__, expecting a comparison expression
	Expression		| __Code piece__, expecting an expression
	Statements		| __Code piece__, expecting a statement, multiple statements or a block of statements (inside braces)
	===

	Special parameter types and rulings are desrbied in the next section.

	+++
   },


  "Parameter Set or Literal (Func. Param. Type)":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "parameter set or literal" ],
    "Keywords":			[ "parameter set or literal" ],
    "Description 01:Introduction"::

	Various functions accept either parameter sets or literals when expecting one or multiple strings, for example file names
	as supported by various file functions. The rules are described below

	Whenever a function expects a __function parameter__ for table columns, the following types are supported and automatically
	put into parameter sets.

	=== 200, 500, 300, bold_column_1
	Type			| Description				| Example
	Quoted literals		| The content of the entire string is interpreted as one string value | "Last,First Name" is such an example
	Quoted literals		| "" Empty string, will be treated as one blank string | "" translates to {""}
	Softquoted literal	| Contents separated with commas are broken down into individual strings. Spaces around commas are ignored. | 'Last Name, First Name' results in two values: {'Last Name','First Name'}.
	Softquoted literals	| '' Empty string, will be treated as no string | '' translates to { } (empty set)
	Unquoted literal	| Treated like quoted literals (containing no commas, but multiple consecutive spaces collapse to 1 space) | Last Name, Last&nbsp;&nbsp;&nbsp;Name (both are equialent)
	Parameter set		| Parameter sets contain a colection of values | { 1, Last Name, "Value [EUR]" }
	===

	<br><br>
	The following code example demonstrates this parameter type ruling using a user-defined function.  The user-defined function gets all
	values in form of parameter sets and prints the contents.

	+++,

    "Examples 01:"::
	define procedure( demonstrate, { { parameter 1, to parameters } }, 1, unlimited )
	{
	    for (i[] = 1, i[] <= parameter count[], i[]++)
	    {
		var name[] = 'parameter ' + literal(i[]);
	    	print( var name[][], "  (", var name[][]{}," items) " );
	    }
	    echo;
	}

	demonstrate( A, B );
	demonstrate( Hello World,  Hello   World  ); // Both are same
	demonstrate( "A,B", " A, B " ); // Both are different
	demonstrate( 'A,B', ' A , B '); // Both are same
	demonstrate( "", '', '  ' ); // Blank, empty, empty
	demonstrate( 'Hello World,  Hello   World  ,"   Hello   World   "');
	demonstrate( { Hello   World, '  Hello   World  ',"   Hello   World   "}); // Note the differences

	echo;

	define additional procedure( demonstrate 2, demonstrate, 
	    { { parameter 1, to parameters members to literal } }, 1, unlimited );
	
	demonstrate   ( { 1, 2, '3' } );
	demonstrate 2 ( { 1, 2, '3' } ); // Note: All numbers are converted to literals

	+++,
    "Output 01:": "automatic"
   },



  "Table Columns (Func. Param. Type)" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Table columns" ],
    "Keywords":			[ "table columns as function parameters", "Shifted Table Column Specifications" ],
    "Description 01:Introduction"::

	Whenever a function expects a __function parameter__ for table columns, the following types are supported:

	=== 200, 500, 300, bold_column_1
	Type			| Description				| Example
	Numeral			| Specifies a __table column number__, beginning with 0.  __Negative indexing__ is allowed, i.e. -1 is last column in the top row, counting leftward. | 0 (left most column)<br> -2 (2nd. last column)
	Quoted literals		| The content of the entire string is interpreted as one header name | "Last,First Name" refers to one header name<br>"" is a blank header name
	Quoted literals		| "" Empty string, will be treated as one blank header name | "" translates to {""}
	Softquoted literal	| Contents separated with commas are broken down into individual header names. Spaces around commas are ignored. | 'Last Name, First Name' results in 2 headers: 'Last Name' and 'First Name'.
	Softquoted literals	| '' Empty string, will be treated as no header name | '' translates to { } (empty set)
	Unquoted literal	| Treated like quoted literals (containing no commas, but multiple consecutive spaces collapse to 1 space) | Last Name, Last&nbsp;&nbsp;&nbsp;Name (both are equialent)
	Parameter set		| Parameter sets contain a colection of header names and/or column numbers | { 1, Last Name, "Value [EUR]" }
	===

	Various functions specific rules may apply:
	* Header names must exist
	* Header names may exist (missing ones may be created as additinal columns in the table)
	* Header names must not exist (e.g. to check if specific header names are <i>not</i> used in a specific table
	* Column numbers are allowed, or not allowed
	* Column numbers may only refer to existing colums, or alternatively all columns even if not yet existing

	<br>
	<u>Note</u>: If Table headers contain numbers, the put the numbers into quotation marks.

	+++,
    "Description 02:Shifted Table Column Specifications"::

	In some cases, you want to refer to neighboring columns to the left or to the right of a column for which the header name is presently
	known. In this case, put the header name into <u>single</u> quotation marks so it will be regarded as a softquoted literal, and
	add one or multiple '&lt;' or '&gt' symbols before the name starts, but inside the single quotation marks.  Multiple consecutive
	symobls can be cascaded to refer to nearby columns which are not immediate neighbors.

	* &lt; = Refer to the next column to the left.  Example:  '&lt;First Name'
	* &gt; = Refer to the next column to the right.  Example:  '&lt;State or Province'
	* &lt;&lt; = Refer to 2 columns to the left left.  Example:  '&lt;&lt;First Name'
	* &gt;&gt; = Refer to 2 columns to the left right..  Example:  '&lt;&lt;State or Province'
	* &gt;&gt; = The two shift operations facing to opposite directions neutralize each other, regardless how they are arranged

	
	<u>Attention</u>: The &lt; and &gt; symbols must be the 1st characters after the quotation marks.  If spaces lie inbetween, then these symbols are considered as part of header names.<br>
	<u>Attention</u>: Shifting does not happen in quoted literals, e.g. "&gt;Last Name". It assumes the header name containing the &gt; symbol.<br>
	
	<br><br>
	Attempting to left-shift beyond the first column (column 0) will assert exceptions.  Attempting to right-shift beyond the last column is OK as long
	the function allows it.  Otherwise exceptions will be asserted, too.

	+++,
    "Examples 02:"::
	table initialize( t,  { { Col A, Col B, Col C, Col D, Col E, Col F },
	                        { Val A, Val B, Val C, Val D, Val E, Val F, Val G } } );

	echo( table read column selected rows ( t, Col B, true ) ); // Val B
	echo( table read column selected rows ( t, '<Col B', true ) ); // Val A
	// echo( table read column selected rows ( t, '<<Col B', true ) ); // would assert exception
	echo( table read column selected rows ( t, '<>Col B', true ) );	// Val B
	echo( table read column selected rows ( t, '>Col E', true ) ); // Val F
	echo( table read column selected rows ( t, '>>Col E', true ) ); // Val G
	+++,
    "Output 02:": "automatic"
   },



  "Code Pieces (Func. Param. Type)" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Code Piece" ],
    "Keywords":			[ "code pieces" ],
    "Description 01:Introduction"::

	Passing code pieces as function parameters is a unique feature in B4P.  Code pieces can either be provided directly or as a literal string.
	When the function is called, the code piece is checked for correct syntax.  While the function is running, the code pieces provided may be
	called multiple times, or in specific cases not at all.

	<br><br>

	Code pieces provided in literal strings must be referenced with a preceding colon (:) symbol in order to avoid interpreting the string
	value or expression as actual code to execute.

	Code pieces come in 4 different flavors:

	=== 200, 600, 200, bold_column_1 bold_column_3
	Code Piece Type			| Description																					| Syntax Examples
	Comparison expression		| Expression to compare something without value on left hand side.<br>The parameter inside the __case(__) function is a comparison expression.					| &gt;30<br>3..4<br>A  (equals A)
	Expression			| Any form of B4P expression as expected on right hand side of assignments<br>The parameter inside the __while(__) function is an expression which must return a boolean result.	| a[]+1<br>abs(-1)
	Variables			| Expression on left hand side of assignments, which are destination variables, but not tables.<br>The __dim(__) function makes use of this. 	| a[]<br>[table:Name,1]
	Statements			| 1 or more statements, separated with semicolons. Braces are allowed.<br>The __for(__) function expects two such statements.			| a[]=b[]+2;<br>{ echo(test); c[]=1 }
	===

	+++,
    "Description 02:Comparison Expressions"::

	A comparison expression is part of an expression where one left-hand value is compared with one or more other right-hand values.  While the a regular
	expression contains left-hand value, comparison operator and right values, the comparison expression leaves out the left-hand value out.
	<br><br>

	__case(__) and __compare select(__) are two common functions which utilize comparison expressions.

	<br><br>
	<u>Attention</u>: Extra arentheses are required when specifying individual values, multiple values spearated with commas, ranges, and when using following comparison operators in front: = and &lt;&gt;.  The reason is
	that with out parentheses, the comparison tries to hijack all further parameters separated with commas as their own right-hand values to compare, too.<br>
	No extra parentheses are required when the comparison expression is in the last function parameter or is the only one function parameter.<br>
	No extraparentheses are required if the comparison expression begins with following operators: &lt;, &lt;=, &gt;, &lt;=, ==, and !=.<br>
	No extra parentheses are required if the comparison expression is provided in a string value.

	+++,
    "Examples 02:"::
	p[] = { 2, 3, 5, 7, 10, 11, 13, 17, 23, 31, 37, A, a, Hello };

	for all parameters( p[], var[] )
	{	
		result[] = compare select( var[], other, 
				(11,37),      is 11 or 37, // Parentheses required if no operator put in front
				==13, 	      thirteen, 	
				(=+a),        1st letter in alphabet, // Parentheses required with = and <>
				('H*'),	      Begins with H,
				>15,          greater than 15,
				(3..5,10),    "is one of 3..5, 10" );
		print(var[],": ", result[],"  / ");

		// Demonstrate the same with comparison expressions in strings.  Note the colons used in front.

		c[] = '(3..5,10)';
		result[] = compare select( var[], other, 
				:literal(11)+",37", is 11 or 37,    // Expression returning a string
				:'==13',      thirteen,     // Softquoted string: No difference to quoted string
				:'=+a',       1st letter in alphabet, 
				:"'H*'",      Begins with H, // See note below !
				:">15",       greater than 15,
				:c[],         "is one of 3..5, 10" ); // Referring to a variable
		echo(result[]);
	}

	// Note :"'H*'" with nested quotation marks:  Expression inside requires a single quotation mark to
	// let the comparison expression support wildcard symbols.


	+++,
    "Output 02:": "automatic",

    "Description 03:Expressions"::

	A expression is a a value, a fuction call or a calculation which returns a value.
	The individual functions may impose additional requirements, for exmplae that the expression must return boolean
	values <b>true</b> or <b>false</b>.

	<br><br>

	The __while(__) loop function is a good example where the expression inside is calculated several times while the
	function is executed.  In addition, various functions containing <b>... selected rows ...</b> in their names make
	use expressions as code pieces.

	<br><br>

	<u>Attention</u>: Parentheses are required when the expression coontains a comparison operator using = or &lt;&gt.  The reason is that
	these two comparison operators may expect more than one value separated with commas and they would, if parenthese are not used,
	hijack the remaining function parameters as additional values to compare.
	No extra parentheses are required when the expression is in the last function parameter or is the only one function parameter.<br>
	No extra parentheses are required if the expression begins with following operators: &lt;, &lt;=, &gt;, &lt;=, ==, and !=.<br>
	No extra parentheses are required if the expression is provided in a string value.

	+++,
    "Examples 03:"::
	table initialize( primes, 
	  { Number, 2, 3, 5, 7, 10, 11, 13, 17, 23, 31, 37, A, a, Hello } );

	table process selected rows( primes, ([Number]=11,37),   echo( [Number],": ", "is 11 or 37" ) );
	table process selected rows( primes,  [Number]==13,      echo( [Number],": ", "thirteen" ) );
	table process selected rows( primes, ([Number]='H*'),    echo( [Number],": ", "Begins with H" ) );
	table process selected rows( primes, ([Number]=3..5,10), echo( [Number],": ", "is one of 3..5,10" ) );

	echo; // Do the same with expression in strings.  No parentheses needed-

	c[] = '[Number] = 3..5,10'; //
	table process selected rows( primes, :c[], echo( [Number],": ", "is one of 3..5,10" ) );

	c[] = "[Number] = 'H*'";
	table process selected rows( primes, :c[], echo( [Number],": ", "Begins with H" ) );
	+++,
    "Output 03:": "automatic",

    "Description 04:Variables"::

	Variable are expressions which must refer directly to a variable.  Any other forms of expressions such as constants, calculations,
	function calls, table references, etc, are forbidden and assert exceptions.  However, variable members (in __structures__ and __arrays_
	are allowed).

	__dim(__), __structure(__), __array(__) and __protect(__) are common functions which utilize this variant of code pieces.

	+++,
    "Examples 04:"::
	var 1[] = my array;
	var 2[] = 'my array[]';

	   array(  var 0[],   {hog, bat, pig} );
	// array(  var 1[][], {dog, cat, rat} );   // This one is wrong
	   array( :var 2[],   {dog, cat, rat} );   // This one is OK
	
	echo( var 0[1] ); // bat
	echo( my array[1] ); // cat
	+++,
    "Output 04:": "automatic",

    "Description 05:Statements"::

	Statements may consist of one single statement, multiple statements separated with semicolons, and blocks.  Blocks are one or more
	statements encapsulated with { ... } braces.

	<br><br>

	The __for(__) and __table process(__) are common functions making use of statements.<br>

	<u>Attention: </u>Don't confuse with C/C++: The three parameters inside the for-function must be separated with commas, not semicolons.  And use semicolons instead of commas to separate statements.<br>
	+++,	
    "Examples 05:"::
	// Demonstrates direct use of code and code in string using colon

	next[] = "a[]++; print( Next )";
	for ( a[] = 1; print( Start ), a[] < 5, :next[] )
	{
	    echo( " ", a[] );
	}
	+++,
    "Output 05:": "automatic"


  },


  "Expressions to Select Rows" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Expressions to select rows" ],
    "Description 01:Introduction"::

	<i>Expressions to select rows</i> are a variant of code pieces containing expressions, but provide additional flexibility.  These expressions
	are typically used in funtions with names containing <b>... selected rows ... </b> where expressions are applied to chosses specifc rows to
	include in the data processing.

	<br><br>
	Like expressions specified as code pieces, these expressions can be coded directly or provided as strings wiht preceding colon (:) symbols.

	<br><br>
	The expressions may return values of following types:
	=== 200, 800, noheader, noframe bold_column_1
	boolean		| Row will be included if the result is <b>true</b> for the corresponding row.
	numeral		| One specific row, addressed with the row number, will be addressed.  __Negative indixing__ is allowed, e.g. -1 refers to the last row.
	parameter set	| The parameter set must contain numerals (row nubmers) or may be an empty set if no rows shall be selected.  __Negative indexing__ is allowed, i.e. -1 refers to the last row.
	===

	<u>Note:</u>The expression will be calculated only once and not for every row if it has returned a numeral or parameter set.

	+++,
    "Examples 01:"::
	table initialize ( table,
	{ { Animal, leg count }, { Worm,  0}, { Bird, 2 }, { Dog, 4 }, { Fly, 6 }, { Tick, 8 } } );

	table process selected rows( 
		table, ([Animal]=Tick,Bird), 
		echo( "row nr.: ", row(),"  Animal: ", [Animal], " has ", [leg count], " legs" ) );

	echo;
	table process selected rows( 
		table, -1, // -1 -> Row 5 (Negative indexing)
		echo( "row nr.: ", row(),"  Animal: ", [Animal], " has ", [leg count], " legs" ) );

	echo;
	table process selected rows( 
		table, {1,3,-2},  // -2 -> Row 4 (Negative indexing)
		echo( "row nr.: ", row(),"  Animal: ", [Animal], " has ", [leg count], " legs" ) );
	+++,
    "Output 01:": "automatic"

  },

  "Indirect Parameter Passing" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Indirect parameter passing" ],
    "Description 01:Introduction"::

	Some functions which only use input parameters support <i>indirect parameter passing</i> where instead of providing
	the function parameters directly, the function parameters are put into a __parameter set__ and then pass as one
	single function parameter instead.

	<br><br>
	In the function descriptions, the support for indirect parameter passing is described under the item <i>Restrictions</i>
	where you find a statement where indirect parameter passing is either enabled or disabled. 

	<br><br>
	In general indirect parameter passing is not enabled whenever the functions include output parameters, 
	input/output parameters, references and/or code pieces.  Indirect parameter passing is also not allowed for
	__control flow functions__ and __user-defined functions__.

    "Examples 01:"::
	table create( table1, table 2 ); // The direct way

	indirect[]= { table 1, table 2 }; // The indirect way
	table create( indirect[] );
	echo("Created two tables in both cases" );

	+++,
    "Output 01:": "automatic"

  }


B4PDOCU.STOP
