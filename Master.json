
{

  "Basic Data Types" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types" ],
    "Keywords":			[ "data types", "basic data types" ],
"Description 01:Basic Data Types" : [
"",
"	Beyond4P supports six basic data types as listed below.  These data types are supported by all __variables__ and expressions.",
"	Regarding variables, Beyond4P uses the <i>dynamic weak typing</i>rule where the data type can be freely changed with any ",
"	new assignment unless specific __variable protections__ have been applied.",
"",
"	=== 150, 500, 350, noframe_1stcolbold",
"	Data Type | Description | Example",
"	__Literals__ | Text (alphanumeric string) data in true UNICODE format | Hello World, ' Hello  World '",
"	__Numerals__ | Numeric values (double precision floating point), stored with or without literal presentation of number received | 1.234",
"	__Dates__    | Can be a full date, a full date combined with time of day (down to seconds), time of day only, or blank date | date(\"2020-07-14\"), date(now)",
"	__Booleans__ | Binary values | true, false",
"	__Voids__    | Represenation of null or invalid information. Should be avoided. |",
"	__Parameter sets__ | Combination of any number of elements of any data type described here (including parameter sets as subsets) into sets | { A, true, 1, {4, 5}, \"Hi!\" }",
"	===",
""
 ]
	
  },


  "Literals" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types literals" ],
    "Keywords":			[ "literal", "literals", "softquoted literal", "softquoted literals", "quoted literal", "quoted literals", "unquoted literal", "unquoted literals" ],
"Description 01:Literals" : [
"",
"	Literals are text representations (also known as strings) consisting of 0, 1 or any number of true UNICODE characters.",
"	The number of characters per literal is only limited by the overall available free memory in the system.",
"",
"	Beyond4P distinguishes among three different sub-types of literals:",
"",
"	=== 20, 500, noframe_1stcolbold, noheader",
"	1. | (Unquoted) literals",
"	2. | Softquoted literals",
"	3. | Quoted literals",
"	===",
"",
"	In the Beyond4P code text, the entire literal must be located in one line.",
""
 ]
	,

"Description 02:(Unquoted) Literals" : [
"",
"	Unlike in most other common programming languages, all text expressions without use of quotation marks in the Beyond4P code are treated",
"	as unquoted literals and not as variable and expression names. Every unquoted literal begins with the first non-blank symbol (i.e. all letters, non-ANSI",
"	symbols such as foreign letters, numeric digits and special symbols not used by the Beyond4P language (e.g. @).  Unquoted literals may contain blanks",
"	(spaces, tabs), but they intepreted as 1 space.  Literals containing numeric digits (with with or without decimal point) but no other symbols and blanks",
"	are regarded as __numerals__.  Unqoted literals ignore leading and trailing blanks.",
"	<br><br>",
"	Literals may take any legitimate value, except for __reserved keywords__ which are interpreted differently (e.g. true, false, else).",
""
 ]
	,
"Examples 02:" : [
"	echo(Hello World);",
"	echo(  Hello   World   ); // To include the blanks, use quotation marks.",
"	echo(Hello World, new line, Hello Folks, new line); // 'new line' is a reserved keyword.",
"	echo( 31.12.2021 );       // No automatic conversion to __date__ type.  Use: echo(date( 31.12.2021 ))",
"	echo( 100 Flowers );",
"	echo( mike@example.com ); // No need include quotation marks because the @-sign is not a Beyond4P symbol",
"	echo( 1 2 3 );            // Is a literal because of spaces between teh digits",
"	echo( type( 1 2 3 ));"
 ]
	,
    "Output 02:This is the output":		"automatic",

"Description 03:Softquoted Literals" : [
"",
"	Softquoted literals are literals placed in <u>single quotation marks</u> (example: '123', 'true', '  Hello World').  Any contents inside single quotation marks",
"	are part of softquoted literals, including leading and trailing blanks.  __Entities__ (known in HTML, for exmaple &amp;euro;) will be decoded automatically",
"	(example: &euro;).  When using softquoted literals on the right hand of comparisons, then __wildcard symbols__ are supported in order to do smart",
"	string comparisons.",
""
 ]
	,
"Examples 03:" : [
"	echo('  Hello   World   ', new line, 'new line'); ",
"	echo(Hello World = 'Hell*'); // Example with wildcard symbol meaning 'true if beginning with Hell'",
"	echo('&euro;');",
"	echo( length('&euro;') );"
 ]
	,
    "Output 03:":		"automatic",



"Description 04:Quoted Literals" : [
"",
"	Quoted literals are literals placed in <u>double quotation marks</u> (example: \"123\", \"true\", \"  Hello World\").  Any contents inside single quotation marks",
"	are part of softquoted literals, including leading and trailing blanks.  Entities will not be decoded.  If you still need to decode entities, then use the",
"	function __decode entitites(__).  In comparison operations, the contents are interpreted as given, i.e. wildcard symbol interpretation will not happen.",
""
 ]
	,
"Examples 04:" : [
"	echo(\"  Hello   World   \", new line, 'new line'); ",
"	echo(\"&amp;\");",
"	echo(Hello World = \"Hell*\"); // 'Hello World' is not the same as 'Hell*'"
 ]
	,
    "Output 04:":		"automatic",


"Description 05:Summary" : [
"",
"	=== 400, 200, 200, 200, simple",
"	Item | (Unquoted) literal | Softquoted literal | Quoted literal",
"	Representation in Beyond4P code text		| Alphanumeric contents | Alphanumeric contents in single quotation marks	| Alphanumeric contents in double quotation marks",
"	Resolving entities in Beyond4P code text	| No			| Yes							| No",
"	Wildcard symbols used for comparisons		| No			| Yes							| No",
"	Leading and trailing white spaces		| No			| Yes							| Yes",
"	Multiple consecutive white spaces		| No			| Yes							| Yes",
"	Line breaks in literal values			| No (use 'new line')	| No (use 'new line')					| No (use 'new line')",
"	===",
""
 ]
	

  },



  "Literals - Indexing" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "literals indexing" ],
    "Keywords":			[ "literals indexing", "length of literals" ],
"Description 01:Literals - Simple Indexing" : [
"",
"	<i>Simple indexing</i> is used to retrieve single characters from the literal.  Indexing begins with 0 which refers to the 1st",
"	character.  The index value is specified in braces and shall not be confused with a parameter set as such.",
"",
"	<br><br>",
"	Following rules apply to the indexing literals:",
"	* The index must always be a numeric value.",
"	* Specifying just braces {} without an index will retrieve the length (character count) of the literal.  Alternatively, use __length [string function]__.",
"	* Indexing begins with 0 (zero).",
"	* The value will be rounded in case it does not contain an integer value.  Example: <b>a[]{2.99}</b> accesses the same member as <b>a[3]</b>.",
"	* __Negative indexing__ is supported. -1 refers to the last character in the literal. -2, -3, etc. refer to the previous ones, and so forth.",
"	* Empty sets are returned when accessing with index values which lie out of bounds.  Example: <b>{a,b,c}{5}</b> returnss <b>{}</b> (empty set).",
"	* Updating individual elements on the left hand side of assignments is not possible.  Wrong exmaple: <b>a[]{3} = 'E';</b>.",
"",
"" ],
"Examples 01:" : [
"	echo( abcde {} );     // Returns 5 (character count)",
"	echo( abcde, {0} );   // Access the 1st element",
"	echo( abcde, {-2} );  // Access the 2nd last element",
"	echo( abcde, {10} );  // Attempts to access characters outside the string returns blank literals.",
"	echo( abcde, {-10} ); // Same case here."
 ]
	,

    "Output 01:Output:":		"automatic"

  },



  "Literals - Extracting Substrings" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types literals extracting substrings" ],
    "Keywords":			[ "literals extracting substrings" ],


"Description 01:Literals - Extracting Substrings" : [
"",
"	Instead of specifying single index values to retrieve single characters, substrings can be retrieved by listing muliple values and/or ranges.",
"	The range operator '..' is available to specify a range.  The result will always be a literal.",
"" ],
"Examples 01:" : [
"	echo( abcdefg { 0,2,4,2,0 } );    // Returns 'aceca'",
"	echo( abcdefg { 3..5 } );         // Returns 'def'",
"	echo( abcdefg { 5..3 } );         // Empty string.  Ranges cannot be listed in reverse direction",
"	echo( abcdefg { -3..-1 } );       // Returns 'efg' - Last 3 characters",
"	echo( abcdefg { 4..-1 } );        // Same result",
"	echo( abcdefg { 3..99 } );        // Returns 'defg'",
"	echo( abcdefg { -99..2 } );       // Returns 'abc'",
"	echo( abcdefg { 0..2,5,1..3 } );  // Combinations"
 ]
	,

    "Output 01:":		"automatic"
  },




  "Numerals" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types numerals" ],
    "Keywords":			[ "numeral", "numerals", "plain numeral", "plain numerals"  ],
"Description 01:Numerals" : [
"",
"	Numerals are numeric data representations which are internally handled as double precision floating point numbers.",
"	The same type is used for typical integer use (for example a loop index counting upwards, referencing a row number to the table) and",
"	advanced mathematical use.",
"",
"	Beyond4P distinguishes between two different sub-types of numerals:",
"",
"	=== 20, 500, noframe_1stcolbold, noheader",
"	1. | (Regular) Numerals",
"	2. | Plain Numerals",
"	===",
""
 ]
	,

"Description 02:(Regular) Numerals" : [
"",
"	All numbers directly expressed in the Beyond4P program text or read in from files or tables as well as command line parameters are",
"	considered (regular) numerals.  The original text representation describing the numeral will be preserved in addition to the numeric",
"	value internally handled as double precision floating point values.  The text representation can be used later for output purposes as",
"	long the numerals have not been manipulated.",
"	<br><br>",
"	Such manipulations include any form of arithmetics (e.g. additions, negations) or processing them with functions (e.g. __abs__() ) to",
"	calculate the absolute value.  Even adding a 0 or multiplying a 1 to a value voids the text representation and the numeral turns into",
"	a plain numeral.",
"	<br><br>",
"	Negative numbers must begin with minus signs.  Decimal points are assumed regardless of regional settings enabled.  Functions are available",
"	to accept alternative symbols such as decimal commas when reading tables.  Thousand separators are supported.  Use functions like",
"	__clean numeral__() and __smart numeral__() to precondition the numeric values in case they contain wrong decimal separators,",
"	unnecessary thousand separators and commercial variants of negation such as parentheses. ",
""
 ]
	,

"Description 03:Plain Numerals" : [
"",
"	Numerals turn into plain numerals with original text representation voided."
 ]
	,


"Examples 03:" : [
"	echo(012.340);		// Numeral",
"	echo(type detailed(012.340), new line);",
"	echo(012.340 + 0);	// Plain numeral - Original text representation is lost",
"	echo(type detailed(012.340 + 0));",
"	echo(numeral(012.340));	// Also plain numeral"
 ]
	,
    "Output 03:":		"automatic",



"Description 04:Scientific Notation" : [
"",
"	The Beyond4P code text does not support scientific notation, e.g. 1.2E+3 would assert a syntax error.  However, the function __numeral()__",
"	supports scientific notation.  However, scientific notation is supporte in reading values from tables (provided the __system variable__ ",
"	<b>table conversion[scientific]</b> is set to true, JSON files and user input."
 ]
	,

"Examples 04:" : [
"	echo(numeral(\"1.2E+03\"));"
 ]
	,

    "Output 04:":		"automatic"

  },


  "Dates" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types dates" ],
    "Keywords":			[ "date", "dates", "plain date", "plain dates"  ],
"Description 01:Dates" : [
"",
"",
"	This data type can store pure dates (beginning 1990-01-01), time of day (down to the second), combination of both date and time of day, or <i>no date</i> which ",
"	is a blank value neither containing dates or times, referred to as 'blank date'.",
"",
"	Beyond4P distinguishes between two different sub-types of numerals:",
"",
"	=== 20, 500, noframe_1stcolbold, noheader",
"	1. | (Regular) Dates",
"	2. | Plain Dates",
"	===",
""
 ]
	,


"Description 02:(Regular) Dates" : [
"",
"	Regular dates contain the digital date (and/or time of day) along the original text representation provided.  This sub-type applies only in a few cases",
"	which includes accessing dates from tables (if enabled with the system variable table conversion[date] = true, otherwise the date is read in as a literal),",
"        or the __date(__) function is used with a formatting parameter added.  The text representation can be used later for output purposes as",
"	long the dates and times have not been manipulated.",
"	<br><br>",
"	Such manipulations include any form of arithmetics (e.g. adding a day (+1) or hour (+1/24) ) or processing them with functions such as __reschedule(__).",
"	Even adding a 0 (0 days) to the date voids the text representation and the date turns into a plain date.",
"	<br><br>",
"	"
 ]
	,

"Description 03:Plain Dates" : [
"",
"	This is the simpler case.  Plain dates contain the digital date (and/or time of day) without any associateid text representation.",
"	The easiest way to describe a date or time value is using one of the following functions:",
"",
"	=== 200, 800, noframe_1stcolbold",
"	Function name 	| Description",
"	__date(__)    	| Depending on the literal value provided, it returns a date, date and time, time only, or blank date.",
"	__pure date(__) | Works like date, but ignores any time of day information.  Output is either a date or blank date.",
"	__date time(__) | Works like date.  If input is not a blank, and if no time of day is provided, then 00:00:00 (midnight) is assumed as time of day.",
"	__time(__)	| This function will only use the time information.  If the paramter contains a date only, then a blank date wil be returned.",
"	===	",
"",
"	Dates turn into plain dates with original text representation voided."
 ]
	,



"Examples 03:" : [
"	d1[] = \"14. July 2021\";",
"	d2[] = \"now\";",
"	d3[] = \"20:15:00\";",
"	d4[] = \"\"; // Blank date",
"	",
"	echo(\"date     (): \", date(d1[]), \", \", date(d2[]), \", \",date(d3[]), \", \",date(d4[]), \", \", type detailed(date(d1[])) );",
"	echo(\"time     (): \", time(d1[]), \", \", time(d2[]), \", \",time(d3[]), \", \",time(d4[]), \", \", type detailed(time(d1[])) );",
"	echo(\"pure date(): \", pure date(d1[]), \", \", pure date(d2[]), \", \",pure date(d3[]), \", \",pure date(d4[]), \", \", ",
"			type detailed(pure date(d1[])) );",
"	echo(\"date time(): \", date time(d1[]), \", \", date time(d2[]), \", \",date time(d3[]), \", \",date time(d4[]), \", \", ",
"			type detailed(date time(d1[])) );",
"",
"	echo;",
"	echo(date(\"31. March 2021\"), \" / \", type detailed(date(\"31. Dezember 2021\")) );",
"	echo(date(\"2020 / 12 / 31 15:00\")+1);		// Date and time",
"	echo(date time(\"2020-12-31\"));			// Add a time (default 00:00:00)",
"	echo(time(\"2020-12-31 15:00\"));			// Time",
"	echo(time(\"2020-12-31 15:00\")+1/24);		// Time, 1 hour later",
"	echo(pure date(\"31. Dezember 2021\")+1);		// Numeral"
 ]
	,
    "Output 03:":		"automatic"



  },



  "Booleans" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types booleans" ],
    "Keywords":			[ "boolean", "booleans"  ],
"Description 01:Voids" : [
"",
"	The boolean data type takes two values: <i>true</i> and <i>false</i>.  Both values are reserved Beyond4P keywords. ",
"	In Beyond4P, the values must be specified in lower case letters and without quotation marks. ",
"",
"" ],
"Examples 01:" : [
"	echo(true, \" / \", type(true));        // Boolean true",
"	echo(True, \" / \", type(True));        // This is a literal value (T is upper case.)",
"	echo(5 > 6, \" / \", type(5 > 6));      // Boolean false "
 ]
	,

    "Output 01:":		"automatic"

  },





  "Voids" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types voids" ],
    "Keywords":			[ "void", "voids"  ],
"Description 01:Voids" : [
"",
"	The void data type typically indicates an invalid value returned from a function or a variable with undefined values.",
"	The following table lists few approaches how to obtain a void value intentionally.",
"",
"	=== 200, 800, noframe_1stcolbold",
"	Method	 		| Description",
"	__null(__)    		| Call the null function",
"	Undefined array member	| Create an array implicity, e.g. by assigning a[1] = 1;  Read-accessing a[0] will return <i>void</i>",
"	Reading JSON data	| Intermediate nodes carry no values and are <i>void</i>.  End nodes with value 'null' are also interpreted as <i>void</i>.",
"	===	"
 ]
	,

"Examples 01:" : [
"	a[1] = 1;",
"	echo( a[0] );",
"	echo( null() );",
"	echo( type(null()) );"
 ]
	,

    "Output 01:":		"automatic"

  },



  "Parameter sets" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets" ],
    "Keywords":			[ "parameter set", "parameter sets"  ],
"Description 01:Parameter Sets" : [
"",
"	Parameter sets is be considered as the sixth Basic Data Type which allows to hold 0, 1 or more elements.",
"	Each element is again a value of any of the six Data Types, including nested parameter sets.",
"",
"	In the program code, sets can be defined with any number of values or expressions inside braces { } and separated with commas. ",
"",
"	=== 300, 700, noframe_1stcolbold, noheader",
"	Number of elements	| At least zero (empty set)",
"	Empty sets		| Empty parameter sets { }are not the same as blank or void values",
"	Mixed data types	| A parameter set may contain data of different types, e.g. { 1, Abc, true, date(31.12.2020) }",
"	Nesting			| Parameter sets support nesting, e.g. { { 1, 2 }, { 3, 4 }, 5 }",
"	Nested empty sets	| Nested empty sets are allowed.  E.g. { {} } is not the same as { } or { { {} } }.",
"	Sequence of elements	| The sequence of elements is preserved, i.e. {a,b,c,d} and {d,c,b,a} are different.<br>Comparing them with '=' returns true (ordering does not care), but with '==' returns false (elements must be in same order).",
"	Mulitple identical elements | Parameter sets may contain multiple identical elements, e.g. { a, b, a, a, c, c }.  You can use the __trim(__) function to eliminate duplicates.",
"	Protection		| In contrast to variable array members and structure members, parameter sets provide no dedicated protection rules.",
"	Embedding		| A paramter set can be embedded into another parameter set, e.g. a[] = {1,2}; b[] = {a[]};",
"	__Parameter Set Indexing__	| One element can be extracted by indexing.  1st element begins wtih 0. Example:  a[] = {a,b,c,d}{1}; Here, the 1st element is accessed, a[] gets value 'b'.",
"	__Negative indexing__	| Negative indexing supported here. a[] = { a,b,c,d,e }{-2} assigns 'd' to a[].",
"	__Extracting subsets__	| Specify multiple index values and ranges to extract subsets.",
"	Arithmetics		| A broad range of arithmetic operators are available to manipulate parameter sets.",
"	===	"
 ]
	,

"Examples 01:" : [
"	a[] = { 1, a, 2, {b,c}, true, date(today) };",
"	echo( a[], \" / \", type(a[]) );",
"	echo( \"First element: \", a[]{0}, \" and last element: \", a[]{1} );"
 ]
	,

    "Output 01:":		"automatic"

  },


  "Parameter sets - Indexing" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets indexing" ],
    "Keywords":			[ "parameter set indexing", "length of parameter sets" ],
"Description 01:Parameter Sets - Simple Indexing" : [
"",
"	<i>Simple indexing</i> is used to retrieve single elements from the parameter set.  Indexing begins with 0 which refers to the 1st",
"	parameter set element.  The index value is specified in braces and shall not be confused with a parameter set as such.",
"	<i>Cascaded indexing</i> for retrieving elements from nested parameter sets is also supported. ",
"",
"	<br><br>",
"	Following rules apply to the indexing parameter sets:",
"	* The index must always be a numeric value.",
"	* Specifying just braces {} without an index will retrieve number of elements (nested elements count 1) of the parameter set.",
"	* Indexing begins with 0 (zero).",
"	* The value will be rounded in case it does not contain an integer value.  Example: <b>a[]{2.99}</b> accesses the same member as <b>a[3]</b>.",
"	* __Negative indexing__ is supported. -1 refers to the last element. -2, -3, etc. refer to the previous elements.",
"	* Blanks are returned when accessing with index values which lie out of bounds.  Example: <b>Hello{5}</b> returns a blank value.",
"	* Updating individual characters on the left hand side of assignments not possible.  Exmaple: <b>a[]{3} = 123;</b>",
"",
"" ],
"Examples 01:" : [
"	echo( { a,b,c,d      } {0} );                     // Access the 1st element",
"	a[] = { a,b,c, {d,e,f}, g };                      // Assign a parameter set to variable a[]",
"	echo( \"Last element            : \", a[]{-1} );    // Retrieve the last element",
"	echo( \"Next element to the left: \", a[]{-2} );    // Retrieve the 2nd last element",
"	echo( \"Cascaded indexing       : \", a[]{3}{2} );  // retrieve 3rd element, and inside the subset the 2nd element (cascaded indexing)",
"	echo( \"# elements in           : \", a[]{} );      // Number of elements",
"	echo( \"# elements in nested set: \", a[]{-2}{} );  // Number of elements in subset (cascaded indexing)",
"	echo( \"Out of bounds case      : \", a[]{99} );    // Empty is returned if index lies out of bounds"
 ]
	,

    "Output 01:":		"automatic",

"Description 02:Parameter Sets - Simple Indexing in Write Accesses" : [
"",
"	<i>Simple indexing</i> also works with write accesses in assignments.  The target variable must contain an existing parameter set.  Values of other types",
"	are not allowed and will cause error messages.  Any data type may be assigned. For example, a numeric element can be replaced by a literal or parameter set",
"	(a subset).  Using multiple indexes as allowed for read accesses is not possible (e.g. [a]{1,2} = {A,B};).",
"" ],
"Examples 02:" : [
"	a[] = { a,b,c, {d,e,f}, g };                      // Assign a parameter set to variable a[]",
"	a[]{1} = B;",
"	a[]{-1} = {G,H,I};",
"	echo( \"Modified value in a[] = \", a[] );"
 ]
	,

    "Output 02:":		"automatic"

  },




  "Parameter sets - Extracting Subsets" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets extracting subsets" ],
    "Keywords":			[ "parameter sets extracting subsets" ],


"Description 01:Parameter Sets - Extracting Subsets" : [
"",
"	Instead of specifying single index values to retrieve single elements, subsets can be retrieved by listing muliple values and/or ranges.",
"	The range operator '..' is available to specify a range.  The result will always be returned in a parameter set, even if the subset",
"	specified results in just one element.",
"" ],
"Examples 01:" : [
"	a[] = { a,b,c, {d,e,f}, g };                          // Assign a parameter set to variable a[]",
"	echo( \"4 elements              : \", a[]{3,1,2,1} );   // Retrieves 4 elements (2 of them repeating here)",
"	echo( \"2nd to 2nd last         : \", a[]{1..3} );      // Use a range",
"	echo( \"2nd to 2nd last         : \", a[]{1..-2} );     // Same output",
"	echo( \"2nd to 2nd last         : \", a[]{-4..3} );     // Same output (-4 = 4th last or 2nd element)",
"	echo( \"1st element             : \", a[]{0..0} );      // Return 1st element, but in a subset and not alone",
"	echo( \"Combinations            : \", a[]{2..4,1} );    // Combination of simple values and ranges"
 ]
	,

    "Output 01:":		"automatic"
  },



  "Parameter sets - Value Ranges" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets value ranges" ],
    "Keywords":			[ "parameter set value ranges"],
"Description 01:Parameter Sets - Simple Values" : [
"",
"	Simple parameter set values are 0, 1 or more values of any types, regardless if values, variables, expressions or subsets, embedded inside braces",
"	and separated with commas. Example:  {} (empty set),  { 1, a, {} } (contains 2 values and nested a empty set), and { {1,2},{3,4} } describing a",
"	nested parameter set which looks like a 2-dimensional matrix and can be used as such."
 ]
	,


"Description 02:Parameter Sets - Value Ranges (Numerals)" : [
"",
" 	Simple parameter sets become cumbersome when describing a sequence of incrementing values, e.g. { 1,2,3,4,5,6,7,8,9,10 }, especially much bigger",
"	ones.  One way to do this is with a loop, but is cumbersome.  Alternatively, value ranges can be specified.  A range consists of a starting value",
"	and an ending value with '..' inbetween, e.g. { 1..10 }.  The increment is 1, unless a <i>second value</i> in the middle is specified, e.g. { 2..4..10 }",
"	to describe the 2nd value.  It may be bigger (for counting up), smaller (for counting down), but not equal to the 1st value (error message occurs).",
"",
"	<br><br>",
"	A mixup of numerals and other types inside a range specification is invalid."
 ]
	,

"Examples 02:" : [
"	print(\"Start with the classic way : \");",
"	a[] = {};",
"	for (i[]=1, i[]<=10, i[]++) a[] += {i[]};",
"	echo(a[]);",
"",
"	echo(\"And the easy way           : \", {1 .. 10});",
"	echo(\"Steps of 2.5               : \", {1 .. 3.5 .. 10});",
"	echo(\"Steps of -1: Right way     : \", {10 .. 9 .. 1});",
"	echo(\"Steps of -1: Wrong way     : \", {10 .. 1}); // Returns empty set",
"	echo(\"Combination of 2 ranges    : \", {2..4..10, 20..40..100} );",
"	echo(\"Build a 3x3 matrix         : \", {{11..13},{21..23},{31..33}} );"
 ]
	,

    "Output 02:":		"automatic",


"Description 03:Parameter Sets - Value Ranges (Literals)" : [
"",
"	Value ranges are also supported for literals.  The literal values may consist of one or more characters.  The intial value, optionally <i>second value</i>",
"	and final values must contain literals with same number of characters and <u>only one character in the same position changing</u>.",
"	An exception applies if the literal contains numeric digits.  Here, up to 8 digits are allowed.  This allows counting from smaller numbers (fewer digits)",
"	to larger numbers (more digits).  Minus signs are not considered as part of numbers. A mixup of literals and other types inside a range specification is invalid.",
"	",
"	<br>",
"	Following exampls are invalid: ",
"	<br>{1 .. '5'}  (Type mixup)",
"	<br>{Option A .. option C } (1st and last characters are different)",
"	<br>{Option A .. Option   } (final value has fewer characters),",
"	<br>{Option A .. Option AA} fails because final value has more characters, and",
"	<br>{Point -3 .. Point 3  } fails because minus sign is an extra character.",
"	<br>Valid examples: See below",
"" ],
"Examples 03:" : [
"	echo(\"Start simple               : \", {a..z});",
"	echo(\"Every 2nd letter           : \", {a..c..z});",
"	echo(\"1 letter in string         : \", {'Article A:' .. 'Article F:'} );",
"	echo(\"Combination of 2 ranges    : \", {2..4..10, 'Article A:' .. 'Article F:'} );",
"	echo(\"Numbers in literals        : \", {'Chapter 9:' .. 'Chapter 12:'} );",
"	echo(\"Numbers in literals        : \", {'Chapter 09:' .. 'Chapter 12:'} );"
 ]
	,

    "Output 03:":		"automatic",


"Description 04:Parameter Sets - Value Ranges (Dates)" : [
"",
"	Unique to Beyodn4P, Value ranges are also supported for dates and times.  If the value consists of",
"	both date and time value, then the range may only be applied either on the date (with time kept",
"	unchanged) or time (with date kept unchanged).",
"",
"	<br><br>",
"	For dates, the default increment is +1 day.  For times, the default increment is +1 hour.  Use the <second value>",
"	to influence the interval.  Both positive and negative intervals are allowed.  Time counting must not pass",
"	across midnights to cover additional days.",
"",
"" ],
"Examples 04:" : [
"	echo(\"Dates                       : \", { date(30.03.2016) .. date(02.04.2016) });",
"	echo(\"Dates, 3 day intervals      : \", { date(01.04.2016) .. date(04.04.2016) .. date(10.04.2016) });",
"	echo(\"Today to yesterday - bad    : \", { date(today) .. date(today)-1 });",
"	echo(\"Today to yesterday - OK     : \", { date(today) .. date(today)-1 .. date(today)-1 });",
"	echo(\"Times, 1 hour intervals     : \", { time(\"12:15:00\")..time(\"15:15:00\") });",
"	echo(\"Times, 5 minute intervals   : \", { time(\"12:15:00\")..time(\"12:20:00\")..time(\"12:30:00\") });",
"	echo(\"30 seconds back - bad       : \", { time(now) .. time(now)-30/(24*60*60) });",
"	echo(\"30 seconds back, 10s interv.: \", { time(now) .. time(now)-10/(24*60*60) .. time(now)-30/(24*60*60) });",
"	echo(\"Changing dates              : \", { date(\"05.06.2016 10:00:00\")..date(\"08.06.2016 10:00:00\") });",
"	echo(\"Changing times, seconds     : \", { date(\"05.06.2016 10:00:00\")..date(\"05.06.2016 10:00:01\")..date(\"05.06.2016 10:00:03\") });",
"",
""
 ]
	,

    "Output 04:":		"automatic"

  },


  "Parameter sets - Value Repetitions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "data types parameter sets value repetitions" ],
    "Keywords":			[ "parameter set value repetitions", "value repetition", "value repetitions"],
"Description 01:Parameter Sets - Value Repetitions" : [
"",
"	Large parameter sets with same values repeating can be built up with value repetitions.  Repetitiosn are specified by numeric values following",
"	a colon symbol and following the paramter set element to repeat.  Multiple repetitions may be specified inside a parameter set value.",
"" ],
"Examples 01:" : [
"",
"	echo({ 5:0 } );              // Generates { 0,0,0,0,0 }",
"	echo({ 2:3,3:2 } );          // Generates { 3,3,2,2,2 }",
"	echo({ 0.9:A } );            // Generates { A }  Rounded up",
"	echo({ 0.1:A } );            // Generates { }  Rounded down",
"	echo({ 2:Hello } );          // Generates { Hello,Hello}",
"	echo({ 0:Hello } );          // Generates { }",
"	echo({ -2:Hello } );         // Generates { }",
"	echo({ 3:{a,b} } );          // Generates { {a,b},{a,b},{a,b} }",
"	echo({ 2:{3:1} } );          // Generates { {1,1,1},{1,1,1} }",
"	echo({ 2:{1..4} } );          // Generates { {1,2,3,4},{1,2,3,4} }"
 ]
	,

    "Output 01:":		"automatic"


  }




 	
,

  "UNICODE Character Set" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "UNICODE character set" ],
    "Keywords":			[ "UNICODE", "character set" ],
"Description 01:Introduction" : [
"",
"	Beyond4P supports the full UNICODE character set which includes",
"",
"	* The Basic Multilingual Plane (codes 0 ... 65,535), as well as",
"	* 16 additional UNICODE planes (codes 65,536 ... 1,114,111).",
"",
"	In contrast to various other programming languages, Beyond4P considers every UNICODE character as one single",
"	character.  For example, 'Caf&eacute;' counts 4 characters.  The full character set is available to define",
"	variable names, table names, table header names, user function names, path and file names, etc.",
"	Internally, in order to conserve memory needs for large data, all text data is stored and handled in UTF-8 format.",
"",
"	<br><br>",
"	Note that Latin, Greek and Cyrillic characters share the same letter, e.g. capital letter 'A'.  Attempting to compare these",
"	different chracters among them indicate that these characters are different.  As an additional example, ",
"	the greek <i>mu</i> &mu; and the <i>micro</i> &micro; symbols are different, too.",
""
 ]
	,

"Examples 01:" : [
"	inhabitants [ Zürich ] = 402000;",
"	Пётр Чайкoвский [ famous concert ] = Nutcracker; // Piotr Tschaikowski",
"	echo( inhabitants [ Zürich ] );",
"	echo( Пётр Чайкoвский [ famous concert ] );"
 ]
	,
    "Output 01:":		"automatic",



"Description 02:Line Separator Symbols" : [
"",
"	Beyond4P is able to load text files containing both \"carriage return + line feed\" (CR+LF) characters common in Windows systems",
"	and \"line feed only\" (LF) common in UNIX/LINUX/MACOS systems.  Internally, Beyond4P considers <i>new line</i> as",
"	a single character with ANSI/UNICODE 10.  In the language, the reserved keyword 'new line' represents this symbol.",
"	Unless specified differently, contents saved in Windows systems will use the CR+LF character pair.",
"",
"	<br><br>",
"	The legacy Macintosh \"carriage return only\" (CR) serving as line separator is not supported.",
""
 ]
	

  },



  "Loading and Saving Files" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "loading files" ],
    "Keywords":			[ "loading files" ],
"Description 01:Loading Files" : [
"",
"	Beyond4P checks all files (programs and data) opened for <i>Byte Order Marks</i> (BOM) at the beginning of the file.  The BOM is a UNICODE character and used to differentiate between",
"	UTF-16 big endian, UTF-16 little endian and UTF-8 file formats.  All formats are supported, whereas UTF-8 is by far the most common UNICODE data storage format",
"	as it is compatible to various legacy systems supporing 8-byte character sets only.",
"",
"	<br><br>",
"	Data transparency: The byte order marks will be recognized and then discarded, i.e. not passed on as special characters to the application.",
"	<br><br>",
"",
"	How BOM's are checked in files loaded or opened:",
"	* If the 2 byte sequence FE FF (hexadecimal) is found, then the text file is in UTF-16 big endian format. ",
"	* If the 2 byte sequence FF FE (hexadecimal) is found, then the text file is in UTF-16 little endian format.",
"	* If the 3 byte sequence EF BB BF (hexadecimal) is found, then the text file is in UTF-8 format.",
"	* Some files contain multiple identical BOMs. They have been sighted in export files from relational databases.",
"",
"	In case no BOM is found, following checks will be applied throughout the first ca. 4000 – 8000 bytes in the file (and not the entire file for performance reasons):",
"	* NULL-characters / 00 (hexadecimal) in even numbered positions (first byte in file is position 0): File is UTF-16, big endian format.  <br>Example: 00 31   00 30   00 20   20 AC   00 0D   00 0A  (10 € followed by new line sequence CR+LF). <br>Even for <i>difficult</i> contents such as pure Chinese text, the UTF-16 will be identified from space symbols (00 20), numeric digits and CR+LF symbols.",
"	* NULL-characters / 00 (hexadecimal) in odd numbered positions: File is UTF-16, little endian format.  <br>Example: 31 00   30 00   20 00   AC 20   0D 00   0A 00  (10 € followed by new line sequence CR+LF)",
"",
"	If the criteria above do not apply, then the file will be checked for typical UTF-8 patterns in the first 4000-8000 bytes, provided the file contains non-ANSI characters.",
"",
"	* Presence of non-ANSI symbols which make up typical UTF-8 byte patterns.  These are 2, 3 or 4 symbols with specific binary patterns.",
"	* Presence of non-ANSI symbols which do not match with UTF-8 byte patterns, e.g. simple 8-bit text in a ISO 8859-1 or WIN 1252 format with single non-ANSI characters",
"	* If the 1st criteria applies, but the 2nd does not, then the file is in UTF-8 format.",
"	* If the 2nd criteria applies, but the 1st does not, then the assumption will be non-UNICODE file format WIN 1252 which is the West European 8-bit character set.",
"",
"	If the input file is in HTML format, then the \"charset=…\" commands will be checked accordingly.  JSON files are assumed in UTF-8 format by default.",
"	Ambiguities may still apply in the following case:",
"	* 1 line of UTF-16 text containing foreign characters only and new line sequence, e.g. one sentence in Greek, Cyrillic or Chinese (without digits, spaces, new lines).",
"	* 8-bit text file without non-ANSI character in the first 4000-8000 bytes (lots of English text in a huge file, a foreign word such as Café follows in a concluding sentence at the end of the file.",
"",
"	Ambiguities need to be resolved with the system variable <b>local settings [ input file character set ]</b>.",
"	As long no clear character format has been identified (e.g. UTF-16 or UTF-8), then the local settings will be referenced.  The initial default value is win1252 (American and West European character set).",
"",
"	<br><br>",
"	Supported character sets summarized<br>",
"",
"	=== 200, 300, 500",
"	Character Set | Format | Description",
"	ANSI 		| 8 bits, 7 of them used 	| Traditional ANSI characters.  All non-ANSI characters, including foreign characters, the Euro symbol, etc. are converted into question marks. <br>Examples: E  e",
"	iso8859-1	| 8 bits			| ANSI characters plus West European character set in the range between 0xA0 (160) and 0xFF (255). <br> This format does not support Windows proprietary character range between 0x80 (128) and 0x9F (159) which affects the Euro symbol (€). <br>Examples: E  e  É  é",
"	win1252		| 8 bits, <br> default setting for Windows | Same as above, but includes Windows proprietary character range so additional punctuation symbols as well as the Euro symbol (€) will be handled correctly. <br>Examples: E  e  É  é  €",
"	utf-8		| 8 bits			| UNICODE format.  Characters can take 1, 2, 3 or 4 byes.<br>Examples: E  e  É  é  €  Ə  ə  中国  𐌄 (also applicable in next rows below)",
"	utf-16		|16 bits (little endian)	| UNICODE format. Every character contains precisely 2 bytes, starting with the least significant byte.  Surrogate pairs are used for characters outside Basic Multilingual Plane.",
"	utf-16 big endian | 16 bits (big endian)	| UNICODE format like above, but the two bytes are swapped. Surrogate pairs are used for characters outside Basic Multilingual Plane.",
"	===",
"",
"	Note: Microsoft Excel does not understand utf-16 big endian, but understands the remaining UNICODE formats.  Use this format only if the recipient (e.g. a UNIX server) operates on big endian format only.",
"",
""
 ]
	,

"Description 02:Saving Files" : [
"",
"	The chosen file format either depends on the format specified in a parameter in the __table save(__) function call, ",
"	or it refers to the default setting stored in the __system variable__ <b>local settings [ output file character set ]</b>. If not modified by the user, ",
"	this file contains the value UTF-8. Files saved in UNICODE-format (UTF-8 and UTF-16 formats) will always begin start with corresponding Byte Order Marks.",
"	This allows other applications to recognize and interpret the contents correctly.  This does effectively apply to Excel when reading comma or tab separated",
"	file formats (.csv format).<br>",
"	<br>Text files under Windows contain \"carriage return + line feed\" line breaks. ",
"	<br>Text files under LINUX contain \"line feed\" line breaks.",
"	<br>You can change the setting with by setting system variable runtime settings [ crlf ] to true (enabled) or false (disabled)",
"",
""
 ]
	

  },


  "CSV File Format" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "CSV" ],
    "Keywords":			[ "CSV" ],
"Description 01:CSV File Format" : [
"",
"	The CSV (Comma Separated Values) is a simple structured text file format existing since the nostalgic 1970's along with the introduction of FORTRAN 77 and is supported by",
"	Beyond4P, along with HTML/MHTML, XML and JSON.",
"",
"	<br><br>",
"	THe biggest drawback is the ignorance towards country settings.  CSV generated from Excel files use symbols such as",
"	* List separator (could be commas, semicolons, tab stops, etc.)",
"	* Decimal point (as used in US, GB, CH) or decimal comma (as used in DE)",
"	* Thousand separator (various symbols and blanks exist)",
"",
"	The files can be loaded with and without specifying the list separators.  If no list separator is specified, then Beyond4P tries to automatically detect the",
"	applicable separators by checking for commas, semicolons and tabs.",
"",
"	Regarding decimal symbols, the standard function __table load(__) will check for numerals in text and CSV files (but not HMTL files and likes) with decimal ",
"	commas and convert them to decimal points.  The new function __table load unchanged(__) will not do the conversion.  You may need this if you need to",
"	discriminate between actual numbers and other numeric data separated with commas but not considered as regular numeric data. ",
"	<br/>Consider using the __clean numeral(__)",
"	function to prepare numbers containing commas (and possibly more, such as thousand separators, currency symbols, etc.).",
"	<br/>Consider using __table save with local decimal separator(__) to save CSV files using the decimal separator symbol applicable with your country settings (comma or point).",
"	<br/>Consider using __table save with decimal comma(__) to make sure all numbers use decimal commas.",
"	<br>The original function __table save(__) saves numbers with decimal points, regardless of the applicable country settings.",
"	",
"	<br><br>",
"",
"	Notice on files with fixed column widths: The best is to load these files with \"new line\" as separator symbol so the table contains one item per row.",
"	Then create additional columns with dedicated data items using the __left(__) / __middle(__) / __right(__) functions where you can specify numeric column positions, ",
"	and remove redundant white space symbos with the __trim(__) function.",
"	"
 ]
	
  },





  "Console Input / Output" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "console" ],
    "Keywords":			[ "console" ],
"Description 01:Console Output" : [
"",
"	Even in Windows 7, 8 and 10, the good old console (started with \"cmd\" or \"msdos\" or \"powershell\") contains archaeological software artefacts dating back to 1981",
"	when the IBM PC has been launched.  Luckily, the recent Windows releases support UTF-8 output to the console.  However, the supported character sets",
"	are limted to the following:",
"",
"	* Basic Latin",
"	* Latin-1 Supplement",
"	* Latin Extended A",
"	* Greek (for your fraternity abbreviations)",
"	* Cyrillic (Russian)",
"	* A set of additional symbols (also found in win1252 character set) including the Euro currency sign",
"",
"	Unsupported symbols will automatically be shown as question mark or with a placeholder box.",
""
 ]
	,

"Description 02:Console Input" : [
"",
"	Another relict from 1981: Unfortunately, Microsoft has not done its homework regarding UNICODE input from the keyboard and we need to accept the facts established",
"	in the year when Ronald Reagan was elected as the President, surely a better choice than since 2016, and foreign characters appeared more foreign at that time than today, too.",
"	Non-ANSI symbols (accents, umlauts, Euro currency symbol, etc.) are converted with an antiquated MS-DOS character set.  Beyond4P resolves this issue by automatically",
"	converting entered characters into UNICODE.",
""
 ]
	
  },



  "Case Sensitivity" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "case sensitivity" ],
    "Keywords":			[ "case sensitivity", "upper case", "lower case" ],
"Description 01:Case Sensitvity and Conversion" : [
"",
"	Beyond4P is a case sensitive language.  Case conversions support the important UNICODE character blocks where",
"	upper/lower case conversion is meaningful.  Accents, Umlauts and other diacrytics will be preserved in case conversions.",
"	The case conversion is does not follow any specific locales, for example removing accents for capital letters or",
"	special ruling for the turkish letters &#x0130; / i / I / &#x0131;.  The lower case sharp-s &#x00DF; will not be converted to",
"	an equivalent upper case character, nor will it be substituted by double-S.",
"",
"	=== 300, 300, 300",
"	UNICODE Block | Code Range | Example",
"	Basic Latin | 00 - 7F (Hex) | A / a",
"	Latin 1 Supplement | 80 - FF (Hex) | &Auml; / &auml;",
"	Latin Extended A | 100 - 1FF (Hex) | &#x0102; / &#x0103;",
"	===",
"	"
 ]
	
  },




  "HTML Entities" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "entities" ],
    "Keywords":			[ "entities", "html entities" ],
"Description 01:Entities" : [
"",
"	Tables in supported HTML / MHTML, as well as softquoted literals (referenced in program code with single quotation marks) support entity references.  Examples:",
"	=== 100, 100, 600",
"	Entity		| Character	| Explanation",
"	&amp;euro;	|	€	| Euro sign (case sensitive, i.e. &Euro; will not be converted)",
"	&amp;#8364; 	|	€	| \", represented with decimal UNICODE number",
"	&amp;#x20AC;	|	€	| \", represented with hexadecimal UNICODE number",
"	&amp;#X20ac;	| 	€	| Same. The letters X and of hexadecimal digits are not case sensitive",
"	===",
"	"
 ]
	
  }






,

  "Comments" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "comments" ],
    "Keywords":			[ "comments" ],
"Description 01:Introduction to Comments" : [
"	Documenting comments is very similar as in C/C++. The language supports following comment symbols:",
"",
"",
"	=== 120, 120, 480, simple",
"	Types		| Examples | Description",
"	Line comment	| // | Comment starting with double slashes and effective until end of line. The symbols for comment blocks /* and */ are ignored inside line comments.",
"	Comment block	| /* ... */ | Commented code section. <br/>/* begins commented section<br/>*/ ends commented sections<br/>Commented section is not ended prematurely with line comments.<br/>Nested comments are not supported, e.g. /* … /* … */ … */",
"	===",
"",
"	You may wonder why obvious names such as 'if', 'while' and 'for' are not considered as similar reserved keywords.  In Beyond4P, the control flow statements",
"	are actually procedure names which then influence executing further statements or blocks.  Therefore, you can actually use 'if' as the given function."
 ]
	,
"Examples 01:" : [
"	// This is a commment",
"	// Bla Bla /* Bla Bla",
"	echo( This statement is outside a comment block );",
"	// Bla Bla */ Bla Bla"
 ]
	,
    "Output 01:":		"automatic",

"Description 02:Github Markdown files" : [
"	Beyond4P <i>understands</i> markdown files (with filenames ending '.md') where it only executes code lines which inside the code blocks.  All other contents",
"	outside the code blocks are treated like comments.  Code blocks must be delimited with three accent-grave symbols ```. Multiple such code blocks in one",
"	markdown file are supported.  Presently, Beyond4P does not check for possible text such as language names after these symbols, e.g  <b>```beyond4p</b>.",
"" ],
"Examples 02:" : [
"	# This is a markdown header",
"	And some text to describe it",
"	```program code",
"	echo( This statement is inside a code block );",
"	```",
"	# This is the next header",
""
 ]
	,
    "Output 02:":		"This statement is inside a block"


  }


,

  "Function Library" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Function Library" ],
    "Keywords":			[ "function library" ],
"Description 01:Introduction to Function Library" : [
"",
"	Beyond4P provides a large and comprehenisve library of different functions.¨",
"	Use the navigator bar to deep-dive into them.",
"",
""
 ]
	
   },


  "Control Flow Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Control Flow Functions" ],
    "Keywords":			[ "Control Flow Functions" ],
"Description 01:Introduction to Control Flow Functions" : [
"",
"	Beyond4P provides a wide variety of control flow functions which include conditional branches and loops.",
"	In contrast to other programming languages, trivial features such as the __if(__) statement is actually",
"	a Beyond4P function which influences execution the next statement or block.",
"",
"	<br><br>",
"",
"	In case you miss the <b>goto</b> statement, there is a good reason for this.  The highly structured",
"	Beyond4P interpreter would have faced risky challenge if that statement would have been impleemented.",
""
 ]
	
   },

  "Loops" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Loops" ],
    "Keywords":			[ "Loops" ],
"Description 01:Introduction into Loops" : [
"",
"	Beyond4P provides a standard __do(__), __while(__) and __for(__) functions as they exist in quasi all",
"	common programming languages.  In addition, various <b>for all...</b> loops are available to work through",
"	tables and/or parameter sets.",
""
 ]
	
   },


  "Branches" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Branches" ],
    "Keywords":			[ "Branches" ],
"Description 01:Introduction into Branches" : [
"",
"	Branches include __if(__), __once(__), and __switch(__) and __check(__) combined with __case(__) functions.",
""
 ]
	
   },



  "Other Control Flow Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Other Control Flow Functions" ],
    "Keywords":			[ "Other Control Flow Functions" ],
"Description 01:Other Control Flow Functions" : [
"",
"	Inclcudes: __with table(__) to provide a context allowing partial table references.",
""
 ]
	
   },



  "User-Defined Procedures and Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "User Defined Procedures and Functiions" ],
    "Keywords":			[ "User-defined procedures and functions", "user-defined procedures", "user-defined functions", "user procedures", "user functions" ],
"Description 01:User-Defined Procedures and Functions" : [
"",
"	Beyond4P supports standard procedures which are in fact used to defined user-specific procedures and functions. ",
"	Procedures are defined as functions which do not provide a return value and must be called as a procedure.",
"	Functions are defined to always provide return values and must be called as functions where the return value must be used further.",
"	A combination of both is allowed which provides flexibility to use defined code either as a procedure or function.",
"",
"	<br><br>",
"	Additional function names may be defined for the same user code.  In this case, the local variable <b>function name[]</b> will be",
"	available to identify the function name used.",
"",
"",
"	<br><br>",
"	Inside the user-defined procedures and functions, following local variables are available, but cannot be deleted using __delete(__) function:",
"",
"	=== 300, 700, bold_column_1",
"	Name of local variable | Description",
"	function name[] | Name of called function.  This is insofar useful if __additional function names__ have been defined for the same code",
"	<i>parameter name</i>[] | Name of parameter provided.  Example: <b>hello[]</b> is defined if one of the parameters is called <b>hello</b>.",
"	parameter <i>n</i>[] | Numbered parameter provided.  If the number of parameter is not limited, then all remaining parameters are numbered, with 1 as 1st parameter.",
"	parameter count[] | Contains the number of parameters passed.  This is useful if the defined function allows for flexibility regarding number of parameters passed.",
"	===",
""
 ]
	
   },


  "Start or include Beyond4P Programs" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Start or include Beyond4P Programs" ],
    "Keywords":			[ "start programs", "include programs" ],
"Description 01:Introduction" : [
"",
"	Beyond4P provides __start(__) to start other Beyond4P programs.  Execution of this calling program continues when the Beyond4P program has ended.",
"	The __include(__) behaves similarly like __start(__), but memorizes the loaded program including the defined functions.  This features is useful",
"	to define and include user specific function libraries which can be re-used in different Beyond4P programs.",
""
 ]
	
   },



  "Type Conversion and Formatting Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Type Conversion Functions" ],
    "Keywords":			[ "type conversion" ],
"Description 01:Type Conversion Functions and Formatting Functions" : [
"",
"	A set of functions are available to convert data in one type (e.g. __literals__) into other types (e.g. __dates__ and __numerals__).",
"	Converting values to __literal__ type supports a broad library of smart formatting features in order to output numbers, dates, etc. ",
"	in a desirable format.",
""
 ]
	
   },




  "Mathematics and Statistics" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Mathematics and Statistics" ],
    "Keywords":			[ "mathematics and statistics" ],
"Description 01:Mathematics and Statistics Functions" : [
"",
"	Beyond4P provides a broad range of advanced mathematics and statistics functions.",
""
 ]
	
   },



  "Basic Math Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "basic math functions" ],
    "Keywords":			[ "basic math functions" ],
"Description 01:Basic Math Functions" : [
"",
"	Beyond4P provides various functions to check numeric values and carry out basic mathematis functions.",
""
 ]
	
   },


 "Transcendental Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "transcendental functions" ],
    "Keywords":			[ "transcendental functions" ],
"Description 01:Transcendental Functions" : [
"",
"	Transcendental functions include advanced mathematical functions covering logarithmic, exponential, trigonomietric and hyperbolic functions.",
""
 ]
	
   },



 "Series Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "series functions" ],
    "Keywords":			[ "series functions" ],
"Description 01:Series Functions" : [
"",
"	This section covers all functions which can process value series of variable sizes.",
""
 ]
	
   },	

"Matrix Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "matrix functions" ],
    "Keywords":			[ "matrix functions" ],
"Description 01:Matrix Functions" : [
"",
"	Beyond4P provides a library of powerful matrix functions.  While vectors are modeled as 1-dimensional __parameter sets__ containing __numerals__,",
"	matrices are modeled as __parameter sets__ (rows) containing __parameter sets__ containing __numerals__ (columns).",
"",
"	Example: <b>{{ 1, 2, 3 }, { 4, 5, 6 }}</b> is a matrix consisting of 2 rows and 3 columns:<br><br>",
"",
"	| 1  2  3 |<br>",
"	| 4  5  6 |<br>",
"",
"	<br>",
"",
"	These matrix functions are a supplement to __matrix arithmetics__ which make use of so called __deep operators__.",
"	You won't find a matrix addition function (like <i>madd(a[],b[])</i>) because it is realized with <b>a[] +^^ b[]</b>.",
"",
"	<br><br>",
"",
"	In addition to Matrix Functions which are part of the mathematical function library, __Matrix Manipulations__ provide additional",
"	matrix functions where the contents may be of any data type.  These functions do not apply any arithmetics on the values.",
"",
""
 ]
	
   },	

 "Statistics Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "statistics functions" ],
    "Keywords":			[ "statistics functions" ],
"Description 01:Statistics Functions" : [
"",
"	This section covers all statistics functions.",
""
 ]
	
  },



 "Finance and Business Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "finance functions" ],
    "Keywords":			[ "finance functions", "business functions" ],
"Description 01:Number Introduction to Finance and Business Functions" : [
"",
"	This section various functions needed for financial calculations, business and capacity planning.",
""
 ]
	
  },




 "Parameter Set Functions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "parameter set functions" ],
    "Keywords":			[ "parameter set functions" ],
"Description 01:Parameter Set Functions" : [
"",
"	This section describes various functions used to process or check parameter sets.",
"	<br>Additional powerful functions using parameter sets extensively are __series functions__, __matrix functions__, ",
"	__statistics functions__ and __conditional combination functions__.",
""
 ]
	
  },



"Set Search and Extraction Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "parameter set search and extraction" ],
    "Keywords":			[ "parameter set search functions", "parameter set extraction functions" ],
"Description 01:Introduction to Parameter Set Search and Extraction Functions" : [
"",
"	This subsection describes various functions to search for parameter set patterns and extract subsets from parameter sets.",
""
 ]
	
  },



 "Matrix Manipulation Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "matrix manipulation functions" ],
    "Keywords":			[ "matrix manipulation functions", "matrix manipulations" ],
"Description 01:Introduction to Matrix Manipulation Functions" : [
"",
"	Beyond4P provides a library of powerful matrix functions.  While vectors are modeled as 1-dimensional __parameter sets__ containing __numerals__,",
"	matrices are modeled as __parameter sets__ (rows) containing __parameter sets__ containing __numerals__ (columns).",
"",
"	Example: <b>{{ 1, A, 3 }, { B, 5, F }}</b> is a matrix consisting of 2 rows and 3 columns:<br><br>",
"",
"	| 1  A  3 |<br>",
"	| B  5  F |<br>",
"",
"	<br>",
"",
"	In addition to these functions, a different section called __Matrix Functions__ provide arithmetic functions on matrixes containing",
"	numerals, for example matrix multiplication, inversion and calculating determinants.",
""
 ]
	
  },



"Date and Time Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "date and time functions" ],
"Description 01:Introduction to Date Functions" : [
"",
"",
"	Beyond4P provides some powerful functions to process date and time information (particularly the variable type __date__) as well as stopwatch functions.",
"",
"	The sections are:",
"	* __Date functions__",
"	* __Time functions__",
"	* __Stopwatch functions__",
"",
"	The following important date functions are found in the section __Type Conversion Functions__ and connvert data of other types, e.g. __literals__, to __dates__.:",
"	* __date(__)",
"	* __pure date(__)",
"	* __date time(__)",
"	* __time(__)",
"	* __pure time(__)",
""
 ]
	
  },

"Date Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "date functions" ],
"Description 01:Introduction to Date, Time and Stopwatch Functions" : [
"",
"",
"	Beyond4P provides some powerful functions to process date .",
"",
"	<br><br>",
"",
"	The following important date functions are found in the section __Type Conversion Functions__ and connvert data of other types, e.g. __literals__, to __dates__.:",
"	* __date(__)",
"	* __pure date(__)",
"	* __date time(__)",
"	* __time(__)",
"	* __pure time(__)",
""
 ]
	
  },


"Time and Stopwatch Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "time and stopwatch functions" ],
"Description 01:Introduction to Time and Stopwatch Functions" : [
"",
"	Beyond4P provides some powerful functions to process time information (particularly the variable type __date__ with time info contained)",
"	as well as stopwatch functions to measure the performance of your applications.",
""
 ]
	
  },


"Sleep and Wait Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "sleep and wait functions" ],
"Description 01:Introduction Sleep and Wait Functions" : [
"",
"	The following functions suspend program execution for a specified time or until a specific time has been reached.",
"	The delay will pause Beyond4P's process and lets other application run at full speed.",
""
 ]
	
  },


"String Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "string functions" ],
    "Keywords":			[ "literal functions", "string functions" ],
"Description 01:Introduction to String Functions" : [
"",
"	This section describes procedures and functions for character and string manipulations.",
""
 ]
	
  },


"String Search and Extraction Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "string search and extraction" ],
    "Keywords":			[ "string search functions", "string extraction functions" ],
"Description 01:Introduction to String Search and Extraction Functions" : [
"",
"	This subsection describes various functions to search for string patterns and extract substrings from stings.",
""
 ]
	
  },


"Character Encoding and Decoding":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "character coding" ],
"Description 01:Introduction to String Search and Extraction Functions" : [
"",
"	This subsection describes various functions to search for string patterns and extract substrings from stings.",
""
 ]
	
  },



"Table Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "table functions" ],
"Description 01:Introduction to Table Function" : [
"",
"	This section summarizes all table functions.",
""
 ]
	
  },


	
"Creating and Deleting Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "table creating deleting" ],
"Description 01:Introduction" : [
"",
"	This subsection contains basic functions to create and delete tables.",
""
 ]
	
  },


"Accessing Table Information":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "accessing table info" ],
"Description 01:Introduction" : [
"",
"	This subsection contains basic table functions to access following information",
"",
"	* Existence of specified table",
"	* Lengths",
"	* Widths",
""
 ]
	
  },

"Accessing Table Contents":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Accessing table contents" ],
"Description 01:Introduction" : [
"",
"	This subsection contains basic table functions to access contents.",
""
 ]
	
  },


"Loading and Saving Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Loading and saving tables" ],
"Description 01:Introduction" : [
"",
"	The procedures and functions described next cover loading and saving tables with a broad variety of data formats.",
""
 ]
	
  },


"Checking and Processing Headers":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Checking headers", "Processing headers" ],
"Description 01:Introduction" : [
"",
"	This subsection various functions which check table headers.",
"	It is highly advisable to check the input data to ensure that the corresponding headers and structures",
"	are available and error messages can be issued very early rather than somewhere in the middle of data processing steps.",
""
 ]
	
  },


"Searching Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Searching tables" ],
"Description 01:Introduction" : [
"",
"	The functions described next provide efficient means to search for data inside tables.",
"",
"",
""
 ]
	
  },



"Processing Table Columns":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Processing table columns" ],
"Description 01:Introduction" : [
"",
"	The functions described next provide efficient means to process table columns, i.e. ",
"	inserting, deleting, rearranging, processing, etc.",
"",
"",
""
 ]
	
  },


"Processing Table Rows":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Processing table rows" ],
"Description 01:Introduction" : [
"",
"	The functions described next provide efficient means process table rows, i.e.",
"	inserting, deleting, rearranging, manipulating, etc.",
""
 ]
	
  },



"Processing Table Contents":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Processing table contents" ],
"Description 01:Introduction" : [
"",
"	The functions described next provide efficient means process table contents.",
""
 ]
	
  },


"Renaming, Copying and Splitting Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Copying and spitting tables" ],
"Description 01:Introduction" : [
"",
"	The functions described next provide efficient means to copy and split tables.",
""
 ]
	
  },


"Checking and Comparing Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Checking and comparing tables" ],
"Description 01:Introduction" : [
"",
"	The functions described next provide efficient means to check tables for consistency and duplications as well",
"	as a simple-to-use function to compare tables and generate comparison reports.",
""
 ]
	
  },


"Looking up Other Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Looking up Other Tables" ],
"Description 01:Introduction" : [
"",
"	The functions described next provide efficient lookup features to retrieve selected information from other",
"	tables.",
""
 ]
	
  },

"Pivoting and Conosolidating Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Pivoting and consolidating tables" ],
"Description 01:Introduction" : [
"",
"	The functions described in this sections are building blocks to do powerful pivoting and consolidating tables.",
"	All functions have been optimized to deliver maximum performance, even with very large tables.  The functions",
"	described in the following sections cover follwing aspects:",
"",
"	* Transposing contents (i.e. contents in 1st column become row headers)",
"	* Serializing horizontally laid out data",
"	* Spreading serialized data out horizontally (opposite of above), and",
"	* Consolidating tables (boiling tables down to fewer rows with specific consolidation actions serving as ingredients)",
""
 ]
	
  },



"Combining Multiple Tables":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Combining Multiple Tables" ],
"Description 01:Introduction" : [
"",
"	The functions described next cover the art of combining two (or more) tables using the fine arts of <a href=\"https://en.wikipedia.org/wiki/Relational_algebra\" target=\"_blank\">relational algebra</a>",
"	where different algebraic rules can be applied to rows and columns.",
"",
"	<br><br>",
"",
"	In a simple example, two tables with members of two clubs (e.g. tennis and squash) need to be merged into one where the last and first names of the",
"	members shall act as matching identifiers.  In case no person has a membership in both clubs, no overlap applies, and the list will simply be",
"	appended where the data are aligned to the right columns, using header names as orientation.  The columns in both tables do not need to be aligned",
"	before the merger.  If one or more persons possess memberships in both clubs, then the information will be consolidated where the same ",
"	__ consolidation actions__ rules are available as used by __table consolidate__.  As an example, the account receivable (e.g.",
"	indoor court reservation fees to be balanced) can be added up whereas the preferences at the club bar can be consolidated with <b>append once</b>",
"	so the preference for tonic water at one club and beer at the other club will appended into \"tonic water, beer\".",
"",
"	<br><br>",
"",
"	If no identifier columns are defined in the functions described next, then every row will be considered unique.  Merging the table is treated appending two tables,",
"	with aligning the data into the right columns.	 ",
"",
"	<br><br>",
"",
"	The following table summarizes the 25 functions in a 5 x 5 matrix with specifc rules to be applied on rows as wll as columns.",
"	The table contains illustrations on how the rows are combined (shades of red / orange / yellow) and how columns are combined (shades of",
"	gray and light blue).  The syntax of the function name does first describe the operation on the rows (e.g. __table merge__) followed by",
"	the operation on the columns (e.g. __table merge extend columns(__)).  If no extension like <b>... extend columns</b> is specified, then",
"	no additional columns are added in the target table and the data in the source table not fitting in the target table structure will not be taken over.",
"",
"	",
"		<br/><img src=\"Images/Description_Combining_Multiple_Tables.jpg\" alt=\"Combining Multiple Tables\"><br/><br/>",
"",
"	The term <i>exclusivity</i> is also known as <i>symmetric difference</i> and <i>disjunctive union</i>.",
"",
"" ],
"Description 02:Additional Functions" : [
"",
"	Following table operations are also described in this section:",
"	* Multiplying tables",
"	* Dividing tables (binary division in relational algebra)",
"	* Arranging tables sideways.",
"",
""
 ]
	
  },







"Directory and File System Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "directory and file system" ],
    "Keywords": 		[ "short error messages on directories and files"],
"Description 01:Introduction to Directory and File System Functions" : [
"",
"	This subsection describes various functions to access and process files and directories.  Following key features ",
"	are included.",
"",
"	* Accessing, searching and manipulating directories (create, change to, rename, remove directories)",
"	* Accessing, searching and manipulating files (directory listings, copy files, rename files, delete files)",
"	* Disk functions (e.g. disk size info)",
"	* Internet access (download files)",
""
 ]
	,

"Description 02:Path and File Names" : [
"",
"	Under Windows, the path names are a chain of directory and subdirectory names separated with backslash '\\' symbols.  Under LINUX and MACOS,",
"	the forward slash '/' is used.  Unless specified otherwise do add quotation marks to (sub-) directory and file names if they contain spaces.",
"	Avoid using symbols not supported or recommended by the operating systems, e.g. '<', , '&', '>' and ':'.",
"",
"	<br><br>",
"",
"	Beyond4P tolerates both slash symbols and does the operating system conversions automatically. Even a mix of both symbols are OK. Following examples are valid:",
"	* C:/Program Files\\Beyond4P.exe",
"	* \\usr\\local/bin\\Beyond4P",
"",
"	<br><br>",
"",
"	If the specified directory or file name contains no path name in front, then the current drive and working directory are assumed.",
"",
"	<br><br>",
"",
"	<u>Attention:</u> Directory and file names are case sensitive in LINUX and MACOS systems, but not in Windows.",
""
 ]
	,
"Description 03:Exception Handling" : [
"",
"	Various procedures and functions contain <b>... silently</b> as ending part of their names.  This suffix",
"	lets Beyond4P to issue return values which are either \"OK\" or contain a short error message.  Without the",
"	suffix, an exception happens, program execution will stop and enters __interactive mode__.",
"",
"	=== 250, 250, 500",
"	Return values for file functions	| Return values for directory functions | Description",
"	OK					| OK					| Successful execution",
"	Path not found				| Path not found			| Specified directory path not found or invalid",
"	File not Found				| Directory not found			| File / directory not found",
"	File access denied			| Directory access denied		| File / directory access denied. Insufficient privileges.",
"	File write-protected			| (n/a)					| File is write-protected.  Check protection settings.",
"	(n/a)					| Directory not empty			| Directory is not empty (contains files and/or sub-directories)",
"	File locked				| Directory locked			| File / directory is locked by other applications. Close the other application.",
"	File already existing			| Directory already existing		| File / The file already exists (e.g. attempt to overwrite with file copy function). For files, use the equivalent function name containing the suffix <b>overwrite</b>.",
"	File error				| Directory error			| Invalid file / directory name or file locked by other application.",
"	File invalid chars			| (n/a)					| File name contains invalid characters",
"	Can't move files across devices		| Can't move files across devices	| Can't move files across devices (with __file rename(__) function)",
"	File found directory expected		| Directory found file expected		| Specified directory name refers to an existing file, and vice versa",
"	===",
""
 ]
	
  },



"Basic Directory and File Functions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "basic directory and file functions" ],
"Description 01:Introduction to Basic Directory and File Functions" : [
"",
"	This subsection describes various functions to search to accesss directories and files.",
""
 ]
	
  },


"Listing and Searching Directories and Files":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "listing directories and files" ],
"Description 01:Introduction to Listing Directories and Files" : [
"",
"	This subsection describes various functions to obtain list of existing filse and directories, as well as searching for files and directories.",
""
 ]
	
  },

"Manipulating Directories and Files":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "deleting directories and files" ],
"Description 01:Introduction to Manipulating Directories and Files" : [
"",
"	This subsection describes various functions to create, copy, rename and delete files and directories",
""
 ]
	
  },


// ________________________________________________________________________________________ "/


"Cross-Functional Info":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Cross-functional info" ],
"Description 01:Introduction" : [
"",
"	This section contains various information which apply to different functions across the function library,",
"	for example applicable sorting and consolidating options.",
""
 ]
	
  },


"Sorting and Ranking Options":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Sorting options", "Ranking options" ],
"Description 01:Introduction" : [
"",
"	The sorting options are used (amongst others) by following functions:",
"	* __table sort columns(__)",
"	* __table sort rows(__)",
"	* __table sort selected rows(__)",
"	* __table rank rows(__)",
"	* __table rank selected rows(__)",
""
 ]
	,
"Description 02:Overview of Available Options" : [
"",
"	=== 200, 800, bold_column_1",
"	Sorting / Ranking Option 	| Description",
"	alphabetic			| Alphabetic order by UNICODE character set.",
"	alphabetic down			| Opposite direction of above",
"	alphabetic ignore case		| Alphabetic order, but ignores case (e.g. 'the Hague' comes before 'Uruguay')",
"	alphabetic down ignore case	| Opposite direction of above",
"	alphabetic ignore blanks	| Same as alphabetic. Blanks (incl. new line, tabs, space) are ignored.  'St. Moritz' and 'St.Moritz' are equivalent.",
"	alphabetic down ignore blanks	| Opposite direction of above",
"	alphabetic ignore both		| Same as alphabetic, ignoring both case and blanks",
"	alphabetic down ignore both	| Opposite direction of above",
"	numeric				| Sorts by numbers.  Non-numeric contents are interpreted like zero.  Smallest number comes first.",
"	numeric down			| Opposite direction of above",
"	date				| Sorts by dates.  Fields containing no qualified dates are interpreted like blank dates.  See rules below the table.",
"	===",
"",
"	Rules on literals:",
"	* Blank literal '' comes first",
"	* One space symbol ' ' (UNICODE 32) comes next.",
"	* Sorting is done based on UNICODE character codes.",
"	* Sorting takes no cultural implications into consideration (e.g. Spanish: LL follows L).",
"	* Numbers are also treated as literals: 0100 comes before 10.",
"",
"	Rules on numerals:",
"	* For contents beginning a number: The 1st number will be recognized.",
"	* For contents beginning with non-numeric symbols: Interpreted as zero.",
"",
"	Rules on dates:",
"	* Blank dates come first.",
"	* If year is missing, current year is assumed.",
"	* If day is missing, the 1st day of month is assumed.",
"	* Month names in key languages like \"Jan\", \"feb\", \"März\", \"avril\", \"May\", \"juni\", etc. are recognized as months and sorted accordingly.",
"	* Local settings are used as rules to resolve country dependent date formats like 01/02/2015 (day and month ordering: 2. Jan 2015 or 1. Feb 2015).  Local settings are in the system variables and can be changed.",
"	* Time values in the date are ignored.  E.g. \"14.07.2016 10:00\" and \"14.07.2016 11:00\" are treated as identical values",
"",
"	Rules on dates and times:",
"	* Blank dates come first.",
"	* Date values without time come before date values with time (e.g. \"00:00:00\") if date are on the same day.",
"	* Time values are not ignored",
"",
"	Rules on times:",
"	* Blank dates come first.",
"	* Date values are ignored.  \"14.07.2016 10:00” and “15.07.2016 10:00” are treated as identical values",
"",
"	Following example shows a ranking based on the different options applied."
 ]
	,

"Examples 02:" : [
"	include( Support Library );",
"	",
"	table initialize ( t,",
"	{ { Scheme, alphabetic, alphabetic down, alphabetic ignore case, alphabetic down ignore case, numeric, numeric down, date, date down, time, time down },",
"	    \"02-Dec-2020 10:00\", \"02-Nov-2020 11:00\", \"05\", \"1\", \"Dec\", \"apr 15\", \"-1\", \"\", \"begin\" } );",
"",
"	for all parameters( [t:1..,0], option[] )  table rank rows( t, option[], Scheme, option[], 113 ); // 113 - Same ranking share same ranking position",
"	table transpose (t);",
"	table list (t);		"
 ]
	,

    "Output 02:": "automatic"

  },



"Consolidation Actions":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "consolidation actions" ],
"Description 01:Introduction" : [
"",
"	The sorting options are used (amongst others) by following functions:",
"	* __table consolidate(__)",
"	* __table merge(__) function family",
""
 ]
	,
"Description 02:Overview of Available Consolidation Actions" : [
"",
"	The consolidation actions does only take place if a matching row further down in the table (or source table if 2 tables are combined) needs",
"	to be consolidated to the target fields.  No actions are applied if only one row exists with same identifer contents. ",
"",
"	=== 200, 800, bold_column_1",
"	Consolidation Action		| Description",
"	none				| No consolidation: The destination fields will not be overwritten.<br>At the end of the consolidation run, the destination field contains the data from the first row belonging to the group.",
"	overwrite			| Source field overwrites destination field. <br>At the end of the consolidation run, the destination field contains the data from the last row belonging to the group.",
"	overwrite if blank		| Source field overwrites destination field if the destination field is still blank. See <sup>1</sup>",
"	overwrite except blank		| Source field overwrites destination field if the soruce field is not blank. See <sup>1</sup>",
"	blank				| Destination field will be blanked.  Useful to void contents no longer needed after consolidation.",
"	zero				| Destination field will be set to 0. Useful to void contents no longer needed after consolidation.",
"	delete				| This column will be deleted after the consolidation run.  Useful to get rid of contents no longer needed.",
"	append				| Append string contents from source fields to destination fields.  A separator string will be inserted if available.",
"	append once			| Like above, but contents are only appended if not yet found in the destination string.",
"	must match			| Checks source and destination fields.  If they differ, then <b>(Inconsistent)</b> will be written.",
"	blank if different		| Checks source and destination fields.  If they differ, then the destination fields will be blanked.",
"	min abc				| Choose the entry in the lower alphabetc sorting order (e.g. abc preferred over def). Blanks have highest priority. ",
"	min abc ignore blanks		| Choose the entry in the lower alphabetc sorting order (e.g. abc preferred over def). Blanks have lowest priority. See <sup>1</sup>",
"	max abc				| Choose the entry in the higher alphabetc sorting order (e.g. def preferred over abc). Blanks have lowest priority.",
"	min				| Choose the entry with the smaller value. Blanks and non-numeric contents are treated as zero.",
"	min ignore blanks		| Choose the entry with the smaller value. Blanks have lowest priority. Non-numeric contents are treated as zero. See <sup>1,2</sup>",
"	min ignore zero			| Choose the entry with the smaller value.  Blanks and non-numeric contents and zero have lowest priority. See <sup>2</sup>",
"	max				| Choose the entry with the greater value. Blanks and non-numeric contents are treated as zero.",
"	max ignore blanks		| Choose the entry with the greater value. Blanks have lowest priority. Non-numeric contents are treated as zero. See <sup>1,2</sup>",
"	max ignore zero			| Choose the entry with the greater value.  Blanks and non-numeric contents and zero have lowest priority. See <sup>2</sup>",
"	sum				| Calculates the sum: Adds source fields to destination fields.",
"	sum blank if zero		| Calculates the sum: Adds source fields to destination fields. If destination field is 0, it will be set to blank.",
"	product				| Calculates the product: Multiplies source fields to destination fields.  Blanks and non-numeric contents are treated as zero.",
"	product ignore blanks		| Calculates the product: Multiplies source fields to destination fields.  Blanks are ignore, but non-numeric contents are treated as zero. See <sup>1,2</sup>",
"	product ignore zero		| Calculates the product: Multiplies source fields to destination fields.    Blanks and non-numeric contents and zero are ignored.  See <sup>2</sup>",
"	average				| Calculates the average (sum divided by number of rows consolidated). Blanks and non-numeric contents are treated as zero.",
"	average ignore blanks		| Calculates the average (sum divided by number of rows consolidated). Non-numeric contents are treated as zero. See <sup>1,2</sup>",
"	average ignore zero		| Calculates the average (sum divided by number of rows consolidated).  Blanks and non-numeric contents and zero are ignored. See <sup>2</sup>",
"	count				| Count all fields.  Is always 1 or bigger.",
"	count ignore blanks		| Count non-blank fields only. See <sup>1</sup>",
"	count ignore zero		| Count non-zero fields. 0, blanks and non-numerals are ignored.",
"	count positive			| Count if value is > 0. 0, blanks and non-numerals are ignored.",
"	count positive or zero		| Count if value is >= 0.  Blanks and non-numerals are treated as 0 and will be counted.",
"	count negative			| Count if value is < 0. 0, blanks and non-numerals are ignored.",
"	count negative or zero		| Count if value is <= 0.  Blanks and non-numerals are treated as 0 and will be counted.",
"	===",
"",
"	<sup>1</sup> Fields are considered blank if they are absolutely blank, i.e. containing zero characters.  Fields containing white spaces (spaces, tabs, new lines, etc.) are not considered blank.<br>",
"	<sup>2</sup> If none of the fields qualify for calculation (e.g. min ignore blanks where all fields are blank), then the result will be zero.",
""
 ]
	

  }





,

  "Functions and Procedures" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Functions and Procedures" ],
"Description 01:Introduction" : [
"",
"	Functions and procedures are subroutines which can be called using their name.  For simplicity, all such subroutines will be referred to as",
"	<i>functions</i> throughout the B4P documentation, regardless if they are called up as procedures (without using the return value provided)",
"	or as functions (with return values being used).  B4P provides an extensive library of standard functions, with focus on processing",
"	sophisticated tables and data structures.  In addition, you can define your own __user functions__ or even create own libraries containing",
"	user functions.",
"",
"	<br><br>",
"",
"	Different from quasi all other programming languages, B4P function names may consist of multiple words with spaces inbetween.",
"	Function names are case sensitive and always specified as as unquoted literals, i.e. quotation marks are not allowed in order to refer",
"	to a fancy function name.  Because function names are unquoted literals, the number of spaces (or tabs) between the individual words is",
"	irrelevant, but must be at least one.  The first two function names listed below are equivalent, but the remaining ones are not.  ",
"",
"	* <b>table process(...)</b>",
"	* <b>table&nbsp;&nbsp;&nbsp;process&nbsp;&nbsp;(...);</b> // Same as 'table process'",
"	* <b>tableprocess(...)</b> // 'tableprocess' differs from 'table process'",
"	* <b>Table process(...)</b> // Upper case letter",
"	* <b>table_process(...)</b> // <i>Snake case</i>: Underscore and other symbols differ from spaces.",
"	* <b>Table-process(...)</b> // <i>Kebab case</i>: Likely wrong. Attempts to subtract return value of <b>process(...)</b> from the string 'Table'.",
"",
"	<br><br>",
"",
"	Functions may require no, a fixed number or a variable number of __function parameters__ with different __function parameter directions__.",
"",
"	<br><br>",
"",
"	The difference between procedures and functions is that procedures do not provide return values but functions do.  Where allowed,",
"	functions can also be called as procedures.",
"",
"	=== 200, 600, 200, bold_column_1 bold_column_3",
"	Function Nature		| Description					| Exmaples",
"	Function		| The function will always provide a return value and can only be called inside expressions where the return value is used further. | a[] = abs( 1.5 );<br>echo( sqrt( 81 ) );",
"	Procedure		| The function will not provide return values and must be called as procedures.  If no parameters are supplied, then the function name can be used alone with semicolon at the end. | echo;<br>echo();<br>echo(Hello);",
"	Procedure or function	| The function can be called as procedrues or functions. Use of return value is voluntary. | table rename headers(...);<br>a[] = table rename headers(...);",
"	Control flow functions	| __Control flow functions__ require a succeeding statement or code block which will be executed as specified by these functions.  The __if(__) statement is one of them. | if (a[]=1) echo(\"is 1\");",
"	===	",
""
 ]
	
   },


  "Function Parameters" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Function Parameters" ],
"Description 01:Introduction" : [
"",
"	Depending on their specifications, B4P functions can take a fixed or variable number of parameters.  For variable number of parameters,",
"	the minimum required, maximum allowed (or no limitation), and increments (e.g. min 2, max 11, increments of 3 means allowing ",
"	2, 5, 8 or 11 parameters) are defined.",
"",
"	Function parameters can be values, variables (including references to variables), expressions, table references and __code pices__.",
"	Details are ruled in the respective function definitions.",
"",
"	<br><br>",
"",
"	The ability to pass __code pieces__ as parameters into functions, which are then executed by the function once or repeatedly on when needed,",
"	are unique to B4P and not common in other programming languges. This feature is actually used in control flow funtions (e.g. __if(__),",
"	__while(__), etc.) which are, in other languages, defined as fixed keywords and are inherent parts of the programming language.  ",
"	In addition, this feature allows convenient operations through tables without specifying loops, e.g. with the __table process(__) function.",
"",
"	<br><br>",
"",
"	Depending on the specific functions, they may acceept parameters with values of any type (e.g. numerals only), a combination of them, or",
"	or any type.  Type checking of the function parameters happen before the actual function is executed.  Type mismatches will be report",
"	as exceptions (error messages).  Various functions dealing with tables do also accept __table columns as function parameters__ which is a flexible parameter",
"	type and accepts one of the following: individual header names, individual column numbers or several of them provided in a __parameter set__ variable.",
"",
"",
"	<br><br>",
"",
"	B4P supports different __parameter directions__: Input, output, input/output, __variable references__ and __code pieces__.",
"	Functions may require no, a fixed number or a variable number of __function parameters__.",
"",
""
 ]
	
   },



  "Function Parameter Directions" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Function parameter directions", "parameter directions" ],
"Description 01:Introduction" : [
"",
"	B4P distinguishes among following function parameter directions which are described next.",
"",
"	=== 200, 150, 150, 200, 200, bold_column_1",
"	Direction			| Constants 	| Expressions 	| Variables			| Table references",
"	Input parameters		| allowed	| allowed	| allowed (must be defined)	| allowed",
"	Output parameters		| not allowed	| not allowed	| allowed (may be defined)	| allowed",
"	Input / output parameters	| not allowed	| not allowed	| allowed (must be defined)	| allowed",
"	References			| not allowed	| not allowed	| allowed (must be defined)	| not allowed",
"	__Code pieces__			| 		| 		| See section on __code pieces__   | ",
"	===",
""
 ]
	,
"Description 02:Input Parameters" : [
"",
"	The parameters supplied to the function are values.  They can be constants, existing __variables__, __table references__,",
"	and any form of right-hand expressions containing calculations and/or other function calls.  Variables passed as paramters",
"	must be defined (i.e. values assigned) prior to calling the function.",
""
 ]
	,
"Examples 02:" : [
"	a[] = World;",
"	echo( \"Hello \", a[], ' ', abs(-1)+2+3 );"
 ]
	,

    "Output 02:": "automatic",

"Description 03:Output Parameters" : [
"",
"	The parameters must either be a __variable__ or __table reference__, similar to left-hand side of assignment statements.",
"	Constants and calculated expressions are not allowed.  Before the function is called, variables which are not yet existing,",
"	will be defined automatically. After the function call has been completed, the value will be written back to the variable or table.",
""
 ]
	,
"Examples 03:" : [
"	a[] = find( 'Say Hi!', { Ha, Hä, He, Hi, Ho }, 0, which[] );",
"	echo( which[] ); // 3, because Hi is in position 3 in the parameter set"
 ]
	,

    "Output 03:": "automatic",

"Description 04:Input / Output Parameters" : [
"",
"	The parameters must either be an existing __variable__ or __table reference__, similar to left-hand side of assignment statements.",
"	Constants and calculated expressions are not allowed.",
"	Before the function is called, the value will be retrieved from the variable or table.  After the function call has been completed,",
"	the value will be written back to the table.",
"" ],
"Examples 04:" : [
"	table initialize( t, {{ Hi, He }} );",
"	a[] = Ho;",
"	exchange( [t:0,0], a[] );",
"	echo( [t:..,0], \" and \", a[] );"
 ]
	,

    "Output 04:": "automatic",

"Description 05:References" : [
"",
"	Some functions take over the reference to the variables provided in the function parameters.  References provide following benefits:",
"	* Higher performance (no payload data, e.g. big parameter sets, are copied in before the call and copied back after the call)",
"	* Direct access to the variable contents, especially in __user procedures__ and __user functions__",
"	* Access to member variables (__structure__ and __array__ members and their sub-members if available)",
"	* Access to variable properties, e.g. __variable protection__ settings.",
"",
"	The following code example shows how the user-defined procedure <b>my funct</b> accesses a member variable and defines an additional",
"	member variable.",
""
 ]
	,
"Examples 05:" : [
"	define procedure( my func, { { a, all, reference } } )",
"	{",
"	    echo(a[one]);",
"	    a[two] = TWO;",
"	}",
"	",
"	b[one] = ONE;",
"	my func( b[] );",
"	echo(b[two]);"
 ]
	,

    "Output 05:": "automatic",
"Description 06:Code Pieces" : [
"",
"	Passing code pieces as function parameters is a unique feature in B4P.  Code pieces can either be provided directly or as a literal string.",
"	When the function is called, the code piece is checked for correct syntax.  While the function is running, the code pieces provided may be",
"	called multiple times, or in specific cases not at all.",
"",
"	<br><br>",
"	See section on __code pieces__ for further details."
 ]
	
  },





  "Function Parameter Types" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Function parameter types" ],
"Description 01:Introduction" : [
"",
"	B4P supports different parameter types (e.g. literal, etc.) as well as more specialized parameter types.",
"",
"	=== 200, 800, bold_column_1",
"	Parameter Types		| Description",
"	All			| Accepts ",
"	Numeral			| Accepts numerals and expressions returning numeral values",
"	Literal			| Accepts unquoted, softquoted and quoted strings and expressions returning strings",
"	Boolean			| Accepts <b>true</b>, <b>false</b> or expressions returning boolean values, e.g. comparisons",
"	Date			| Accepts dates and/or time values or expressions returning date/time values.",
"	Date or literal		| In this case, literals will be converted to dates automatically, e.g. \"29.Feb. 20\" to 2020-02-29, or \"today\" to today's date",
"	Parameter set		| Accepts parameter sets or expressiosn returning parameter sets",
"	Combinations of above	| Various functions accept values of different types",
"	Table columns		| Parameter to specify one or multiple table columns in a flexible way. See section on __table columns as function parameters__.",
"	Parameter set or literal| Various functions accept either parameter sets or literals.  See section on __parameter set or literal__  for details",
"	All types		| Accepts values of all types, including void",
"	Valid types		| Accepts values of all types, except void",
"	Variable		| __Code piece__, expecting a variable name",
"	Comparison expression	| __Code piece__, expecting a comparison expression",
"	Expression		| __Code piece__, expecting an expression",
"	Statements		| __Code piece__, expecting a statement, multiple statements or a block of statements (inside braces)",
"	===",
"",
"	Special parameter types and rulings are desrbied in the next section.",
""
 ]
	
   },


  "Parameter Set or Literal (Func. Param. Type)":
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "parameter set or literal" ],
    "Keywords":			[ "parameter set or literal" ],
"Description 01:Introduction" : [
"",
"	Various functions accept either parameter sets or literals when expecting one or multiple strings, for example file names",
"	as supported by various file functions. The rules are described below",
"",
"	Whenever a function expects a __function parameter__ for table columns, the following types are supported and automatically",
"	put into parameter sets.",
"",
"	=== 200, 500, 300, bold_column_1",
"	Type			| Description				| Example",
"	Quoted literals		| The content of the entire string is interpreted as one string value | \"Last,First Name\" is such an example",
"	Quoted literals		| \"\" Empty string, will be treated as one blank string | \"\" translates to {\"\"}",
"	Softquoted literal	| Contents separated with commas are broken down into individual strings. Spaces around commas are ignored. | 'Last Name, First Name' results in two values: {'Last Name','First Name'}.",
"	Softquoted literals	| '' Empty string, will be treated as no string | '' translates to { } (empty set)",
"	Unquoted literal	| Treated like quoted literals (containing no commas, but multiple consecutive spaces collapse to 1 space) | Last Name, Last&nbsp;&nbsp;&nbsp;Name (both are equialent)",
"	Parameter set		| Parameter sets contain a colection of values | { 1, Last Name, \"Value [EUR]\" }",
"	===",
"",
"	<br><br>",
"	The following code example demonstrates this parameter type ruling using a user-defined function.  The user-defined function gets all",
"	values in form of parameter sets and prints the contents.",
""
 ]
	,

"Examples 01:" : [
"	define procedure( demonstrate, { { parameter 1, to parameters } }, 1, unlimited )",
"	{",
"	    for (i[] = 1, i[] <= parameter count[], i[]++)",
"	    {",
"		var name[] = 'parameter ' + literal(i[]);",
"	    	print( var name[][], \"  (\", var name[][]{},\" items) \" );",
"	    }",
"	    echo;",
"	}",
"",
"	demonstrate( A, B );",
"	demonstrate( Hello World,  Hello   World  ); // Both are same",
"	demonstrate( \"A,B\", \" A, B \" ); // Both are different",
"	demonstrate( 'A,B', ' A , B '); // Both are same",
"	demonstrate( \"\", '', '  ' ); // Blank, empty, empty",
"	demonstrate( 'Hello World,  Hello   World  ,\"   Hello   World   \"');",
"	demonstrate( { Hello   World, '  Hello   World  ',\"   Hello   World   \"}); // Note the differences",
"",
"	echo;",
"",
"	define additional procedure( demonstrate 2, demonstrate, ",
"	    { { parameter 1, to parameters members to literal } }, 1, unlimited );",
"	",
"	demonstrate   ( { 1, 2, '3' } );",
"	demonstrate 2 ( { 1, 2, '3' } ); // Note: All numbers are converted to literals",
""
 ]
	,
    "Output 01:": "automatic"
   },



  "Table Columns (Func. Param. Type)" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Table columns" ],
    "Keywords":			[ "table columns as function parameters", "Shifted Table Column Specifications" ],
"Description 01:Introduction" : [
"",
"	Whenever a function expects a __function parameter__ for table columns, the following types are supported:",
"",
"	=== 200, 500, 300, bold_column_1",
"	Type			| Description				| Example",
"	Numeral			| Specifies a __table column number__, beginning with 0.  __Negative indexing__ is allowed, i.e. -1 is last column in the top row, counting leftward. | 0 (left most column)<br> -2 (2nd. last column)",
"	Quoted literals		| The content of the entire string is interpreted as one header name | \"Last,First Name\" refers to one header name<br>\"\" is a blank header name",
"	Quoted literals		| \"\" Empty string, will be treated as one blank header name | \"\" translates to {\"\"}",
"	Softquoted literal	| Contents separated with commas are broken down into individual header names. Spaces around commas are ignored. | 'Last Name, First Name' results in 2 headers: 'Last Name' and 'First Name'.",
"	Softquoted literals	| '' Empty string, will be treated as no header name | '' translates to { } (empty set)",
"	Unquoted literal	| Treated like quoted literals (containing no commas, but multiple consecutive spaces collapse to 1 space) | Last Name, Last&nbsp;&nbsp;&nbsp;Name (both are equialent)",
"	Parameter set		| Parameter sets contain a colection of header names and/or column numbers | { 1, Last Name, \"Value [EUR]\" }",
"	===",
"",
"	Various functions specific rules may apply:",
"	* Header names must exist",
"	* Header names may exist (missing ones may be created as additinal columns in the table)",
"	* Header names must not exist (e.g. to check if specific header names are <i>not</i> used in a specific table",
"	* Column numbers are allowed, or not allowed",
"	* Column numbers may only refer to existing colums, or alternatively all columns even if not yet existing",
"",
"	<br>",
"	<u>Note</u>: If Table headers contain numbers, the put the numbers into quotation marks.",
""
 ]
	,
"Description 02:Shifted Table Column Specifications" : [
"",
"	In some cases, you want to refer to neighboring columns to the left or to the right of a column for which the header name is presently",
"	known. In this case, put the header name into <u>single</u> quotation marks so it will be regarded as a softquoted literal, and",
"	add one or multiple '&lt;' or '&gt' symbols before the name starts, but inside the single quotation marks.  Multiple consecutive",
"	symobls can be cascaded to refer to nearby columns which are not immediate neighbors.",
"",
"	* &lt; = Refer to the next column to the left.  Example:  '&lt;First Name'",
"	* &gt; = Refer to the next column to the right.  Example:  '&lt;State or Province'",
"	* &lt;&lt; = Refer to 2 columns to the left left.  Example:  '&lt;&lt;First Name'",
"	* &gt;&gt; = Refer to 2 columns to the left right..  Example:  '&lt;&lt;State or Province'",
"	* &gt;&gt; = The two shift operations facing to opposite directions neutralize each other, regardless how they are arranged",
"",
"	",
"	<u>Attention</u>: The &lt; and &gt; symbols must be the 1st characters after the quotation marks.  If spaces lie inbetween, then these symbols are considered as part of header names.<br>",
"	<u>Attention</u>: Shifting does not happen in quoted literals, e.g. \"&gt;Last Name\". It assumes the header name containing the &gt; symbol.<br>",
"	",
"	<br><br>",
"	Attempting to left-shift beyond the first column (column 0) will assert exceptions.  Attempting to right-shift beyond the last column is OK as long",
"	the function allows it.  Otherwise exceptions will be asserted, too.",
""
 ]
	,
"Examples 02:" : [
"	table initialize( t,  { { Col A, Col B, Col C, Col D, Col E, Col F },",
"	                        { Val A, Val B, Val C, Val D, Val E, Val F, Val G } } );",
"",
"	echo( table read column selected rows ( t, Col B, true ) ); // Val B",
"	echo( table read column selected rows ( t, '<Col B', true ) ); // Val A",
"	// echo( table read column selected rows ( t, '<<Col B', true ) ); // would assert exception",
"	echo( table read column selected rows ( t, '<>Col B', true ) );	// Val B",
"	echo( table read column selected rows ( t, '>Col E', true ) ); // Val F",
"	echo( table read column selected rows ( t, '>>Col E', true ) ); // Val G"
 ]
	,
    "Output 02:": "automatic"
   },



  "Code Pieces (Func. Param. Type)" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Code Piece" ],
    "Keywords":			[ "code pieces" ],
"Description 01:Introduction" : [
"",
"	Passing code pieces as function parameters is a unique feature in B4P.  Code pieces can either be provided directly or as a literal string.",
"	When the function is called, the code piece is checked for correct syntax.  While the function is running, the code pieces provided may be",
"	called multiple times, or in specific cases not at all.",
"",
"	<br><br>",
"",
"	Code pieces provided in literal strings must be referenced with a preceding colon (:) symbol in order to avoid interpreting the string",
"	value or expression as actual code to execute.",
"",
"	Code pieces come in 4 different flavors:",
"",
"	=== 200, 600, 200, bold_column_1 bold_column_3",
"	Code Piece Type			| Description																					| Syntax Examples",
"	Comparison expression		| Expression to compare something without value on left hand side.<br>The parameter inside the __case(__) function is a comparison expression.					| &gt;30<br>3..4<br>A  (equals A)",
"	Expression			| Any form of B4P expression as expected on right hand side of assignments<br>The parameter inside the __while(__) function is an expression which must return a boolean result.	| a[]+1<br>abs(-1)",
"	Variables			| Expression on left hand side of assignments, which are destination variables, but not tables.<br>The __dim(__) function makes use of this. 	| a[]<br>[table:Name,1]",
"	Statements			| 1 or more statements, separated with semicolons. Braces are allowed.<br>The __for(__) function expects two such statements.			| a[]=b[]+2;<br>{ echo(test); c[]=1 }",
"	===",
""
 ]
	,
"Description 02:Comparison Expressions" : [
"",
"	A comparison expression is part of an expression where one left-hand value is compared with one or more other right-hand values.  While the a regular",
"	expression contains left-hand value, comparison operator and right values, the comparison expression leaves out the left-hand value out.",
"	<br><br>",
"",
"	__case(__) and __compare select(__) are two common functions which utilize comparison expressions.",
"",
"	<br><br>",
"	<u>Attention</u>: Extra arentheses are required when specifying individual values, multiple values spearated with commas, ranges, and when using following comparison operators in front: = and &lt;&gt;.  The reason is",
"	that with out parentheses, the comparison tries to hijack all further parameters separated with commas as their own right-hand values to compare, too.<br>",
"	No extra parentheses are required when the comparison expression is in the last function parameter or is the only one function parameter.<br>",
"	No extraparentheses are required if the comparison expression begins with following operators: &lt;, &lt;=, &gt;, &lt;=, ==, and !=.<br>",
"	No extra parentheses are required if the comparison expression is provided in a string value.",
""
 ]
	,
"Examples 02:" : [
"	p[] = { 2, 3, 5, 7, 10, 11, 13, 17, 23, 31, 37, A, a, Hello };",
"",
"	for all parameters( p[], var[] )",
"	{	",
"		result[] = compare select( var[], other, ",
"				(11,37),      is 11 or 37, // Parentheses required if no operator put in front",
"				==13, 	      thirteen, 	",
"				(=+a),        1st letter in alphabet, // Parentheses required with = and <>",
"				('H*'),	      Begins with H,",
"				>15,          greater than 15,",
"				(3..5,10),    \"is one of 3..5, 10\" );",
"		print(var[],\": \", result[],\"  / \");",
"",
"		// Demonstrate the same with comparison expressions in strings.  Note the colons used in front.",
"",
"		c[] = '(3..5,10)';",
"		result[] = compare select( var[], other, ",
"				:literal(11)+\",37\", is 11 or 37,    // Expression returning a string",
"				:'==13',      thirteen,     // Softquoted string: No difference to quoted string",
"				:'=+a',       1st letter in alphabet, ",
"				:\"'H*'\",      Begins with H, // See note below !",
"				:\">15\",       greater than 15,",
"				:c[],         \"is one of 3..5, 10\" ); // Referring to a variable",
"		echo(result[]);",
"	}",
"",
"	// Note :\"'H*'\" with nested quotation marks:  Expression inside requires a single quotation mark to",
"	// let the comparison expression support wildcard symbols.",
"",
""
 ]
	,
    "Output 02:": "automatic",

"Description 03:Expressions" : [
"",
"	A expression is a a value, a fuction call or a calculation which returns a value.",
"	The individual functions may impose additional requirements, for exmplae that the expression must return boolean",
"	values <b>true</b> or <b>false</b>.",
"",
"	<br><br>",
"",
"	The __while(__) loop function is a good example where the expression inside is calculated several times while the",
"	function is executed.  In addition, various functions containing <b>... selected rows ...</b> in their names make",
"	use expressions as code pieces.",
"",
"	<br><br>",
"",
"	<u>Attention</u>: Parentheses are required when the expression coontains a comparison operator using = or &lt;&gt.  The reason is that",
"	these two comparison operators may expect more than one value separated with commas and they would, if parenthese are not used,",
"	hijack the remaining function parameters as additional values to compare.",
"	No extra parentheses are required when the expression is in the last function parameter or is the only one function parameter.<br>",
"	No extra parentheses are required if the expression begins with following operators: &lt;, &lt;=, &gt;, &lt;=, ==, and !=.<br>",
"	No extra parentheses are required if the expression is provided in a string value.",
""
 ]
	,
"Examples 03:" : [
"	table initialize( primes, ",
"	  { Number, 2, 3, 5, 7, 10, 11, 13, 17, 23, 31, 37, A, a, Hello } );",
"",
"	table process selected rows( primes, ([Number]=11,37),   echo( [Number],\": \", \"is 11 or 37\" ) );",
"	table process selected rows( primes,  [Number]==13,      echo( [Number],\": \", \"thirteen\" ) );",
"	table process selected rows( primes, ([Number]='H*'),    echo( [Number],\": \", \"Begins with H\" ) );",
"	table process selected rows( primes, ([Number]=3..5,10), echo( [Number],\": \", \"is one of 3..5,10\" ) );",
"",
"	echo; // Do the same with expression in strings.  No parentheses needed-",
"",
"	c[] = '[Number] = 3..5,10'; //",
"	table process selected rows( primes, :c[], echo( [Number],\": \", \"is one of 3..5,10\" ) );",
"",
"	c[] = \"[Number] = 'H*'\";",
"	table process selected rows( primes, :c[], echo( [Number],\": \", \"Begins with H\" ) );"
 ]
	,
    "Output 03:": "automatic",

"Description 04:Variables" : [
"",
"	Variable are expressions which must refer directly to a variable.  Any other forms of expressions such as constants, calculations,",
"	function calls, table references, etc, are forbidden and assert exceptions.  However, variable members (in __structures__ and __arrays_",
"	are allowed).",
"",
"	__dim(__), __structure(__), __array(__) and __protect(__) are common functions which utilize this variant of code pieces.",
""
 ]
	,
"Examples 04:" : [
"	var 1[] = my array;",
"	var 2[] = 'my array[]';",
"",
"	   array(  var 0[],   {hog, bat, pig} );",
"	// array(  var 1[][], {dog, cat, rat} );   // This one is wrong",
"	   array( :var 2[],   {dog, cat, rat} );   // This one is OK",
"	",
"	echo( var 0[1] ); // bat",
"	echo( my array[1] ); // cat"
 ]
	,
    "Output 04:": "automatic",

"Description 05:Statements" : [
"",
"	Statements may consist of one single statement, multiple statements separated with semicolons, and blocks.  Blocks are one or more",
"	statements encapsulated with { ... } braces.",
"",
"	<br><br>",
"",
"	The __for(__) and __table process(__) are common functions making use of statements.<br>",
"",
"	<u>Attention: </u>Don't confuse with C/C++: The three parameters inside the for-function must be separated with commas, not semicolons.  And use semicolons instead of commas to separate statements.<br>"
 ]
	,	
"Examples 05:" : [
"	// Demonstrates direct use of code and code in string using colon",
"",
"	next[] = \"a[]++; print( Next )\";",
"	for ( a[] = 1; print( Start ), a[] < 5, :next[] )",
"	{",
"	    echo( \" \", a[] );",
"	}"
 ]
	,
    "Output 05:": "automatic"


  },


  "Expressions to Select Rows" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Expressions to select rows" ],
"Description 01:Introduction" : [
"",
"	<i>Expressions to select rows</i> are a variant of code pieces containing expressions, but provide additional flexibility.  These expressions",
"	are typically used in funtions with names containing <b>... selected rows ... </b> where expressions are applied to chosses specifc rows to",
"	include in the data processing.",
"",
"	<br><br>",
"	Like expressions specified as code pieces, these expressions can be coded directly or provided as strings wiht preceding colon (:) symbols.",
"",
"	<br><br>",
"	The expressions may return values of following types:",
"	=== 200, 800, noheader, noframe bold_column_1",
"	boolean		| Row will be included if the result is <b>true</b> for the corresponding row.",
"	numeral		| One specific row, addressed with the row number, will be addressed.  __Negative indixing__ is allowed, e.g. -1 refers to the last row.",
"	parameter set	| The parameter set must contain numerals (row nubmers) or may be an empty set if no rows shall be selected.  __Negative indexing__ is allowed, i.e. -1 refers to the last row.",
"	===",
"",
"	<u>Note:</u>The expression will be calculated only once and not for every row if it has returned a numeral or parameter set.",
""
 ]
	,
"Examples 01:" : [
"	table initialize ( table,",
"	{ { Animal, leg count }, { Worm,  0}, { Bird, 2 }, { Dog, 4 }, { Fly, 6 }, { Tick, 8 } } );",
"",
"	table process selected rows( ",
"		table, ([Animal]=Tick,Bird), ",
"		echo( \"row nr.: \", row(),\"  Animal: \", [Animal], \" has \", [leg count], \" legs\" ) );",
"",
"	echo;",
"	table process selected rows( ",
"		table, -1, // -1 -> Row 5 (Negative indexing)",
"		echo( \"row nr.: \", row(),\"  Animal: \", [Animal], \" has \", [leg count], \" legs\" ) );",
"",
"	echo;",
"	table process selected rows( ",
"		table, {1,3,-2},  // -2 -> Row 4 (Negative indexing)",
"		echo( \"row nr.: \", row(),\"  Animal: \", [Animal], \" has \", [leg count], \" legs\" ) );"
 ]
	,
    "Output 01:": "automatic"

  },

  "Indirect Parameter Passing" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Indirect parameter passing" ],
"Description 01:Introduction" : [
"",
"	Some functions which only use input parameters support <i>indirect parameter passing</i> where instead of providing",
"	the function parameters directly, the function parameters are put into a __parameter set__ and then pass as one",
"	single function parameter instead.",
"",
"	<br><br>",
"	In the function descriptions, the support for indirect parameter passing is described under the item <i>Restrictions</i>",
"	where you find a statement where indirect parameter passing is either enabled or disabled. ",
"",
"	<br><br>",
"	In general indirect parameter passing is not enabled whenever the functions include output parameters, ",
"	input/output parameters, references and/or code pieces.  Indirect parameter passing is also not allowed for",
"	__control flow functions__ and __user-defined functions__.",
"" ],
"Examples 01:" : [
"	table create( table1, table 2 ); // The direct way",
"",
"	indirect[]= { table 1, table 2 }; // The indirect way",
"	table create( indirect[] );",
"	echo(\"Created two tables in both cases\" );",
""
 ]
	,
    "Output 01:": "automatic"

  }


,

  "Interactive Mode" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "interactive" ],
    "Keywords":			[ "interactive", "interactive mode" ],
"Description 01:Interactive Mode" : [
"",
"	Interactive mode allows you to run any Beyon4P command and expression interactively, start programs and inspect variables.  Additional commands, such as",
"	executing system commands, are also supported.  Following cases will activate interactive mode:",
"",
"	=== 240, 760, noframe_1stcolbold, noheader",
"	Command line option -i	| Starting Beyond4P with the command lien option <b>-i</b> will activate interactive mode immediately.",
"	Exception asserted | Most exceptions (e.g. parsing syntax and run-time errors) will start interactive mode so you can inspect the actual circumstances of the error, e.g. by looking at variables and table contents.",
"	Function 'interactive' called | Specify <b>interactive;</b> inside your program if execution should stop here so you can do some inspections or manipulations.  Type <b>return</b> to continue running that program.",
"	===",
"",
"	In interactive mode, the default prompt <b>'&gt;&gt; '</b> will appear.  You are able to change the default prompt with the <b>prompt</b> function call.",
"",
"	=== 240, 360, 400, noframe_1stcolbold",
"	Command type | Explanation | Examples",
"	Beyond4P statements | All Beyond4P assignments, procedure and function calls and transactions | echo ( Hello World ) <br/>a[] = 5; echo(a[])<br/> for (i[ ] = 1, i[ ] <= 3, i[ ]++) echo (i[ ])<br/> start(My program.b4p);<br/> include(Zip Library);<br/>exit;",
"	Beyond4P expressions | Start the command with an equal sign '=' followed by an expression to calculate.  The resulting value and type will be shown. | = 5+3 <br/>",
"	Special Beyond4P commands | start <b/> return | Starts a Beyond4P program <br/> Continues running the Beyond4P program at the next statement after the 'interactive' call.",
"	System commands | System commands as provided by the operating system must precede with a dollar sign '$' | $ dir (Windows) or $ ls (Linux) for directory listing<br/>cd subdirectory <br/>start excel.exe",
"	===",
"",
"	<u>Note on changing drives and/or directories:</u> You can change the current directory of Beyond4P using the '$ cd' (or '$ chdir') command.  Since changing directory in a child process started with the system",
"	command has no effect on the calling process like Beyond4P running, Beyond4P is smart enough to capture 'cd' (and 'chdir') commands and change to the specified directory",
"	accordingly. Whenever Beyond4P captures a change drive or directory command, it will provide a response of success or failure.",
"",
"	<br/><br/>",
"	Following restrictions apply where drive names and paths will not be captured:<br/>",
"	- Window sonly: Commands like '$ D:\\' are supported to change drives.<br/>",
"	- If the command contains multiple commands and the change directory command is not the first one, then it will not be captured.  Example:  \"$ dir ; cd ..\".<br/>",
"	- Input redirection are also not captured, e.g. \"cd < directory_nam.txt\"<br/>",
"	- Change drive directory commands in started batch scripts (and Beyond4P scripts) will not be captured, too. e.g. \"START change_dir.bat\", or \"Beyond4P change_dir.b4p\".<br/>",
""
 ]
	,

"Description 02:Recommended Procedure and Function Calls for Interactive Mode" : [
"",
"	=== 240, 760, noframe_1stcolbold, noheader",
"	prompt (...)	| Customize the prompt.  The settings will be memorized.  Specify an expression as a literal which returns a literal.  Example: prompt( \"working directory() + '>> '\" )",
"	prompt ('')	| Reset customized propt to '>> '",
"	list variables  | List all variables",
"	list system variables | List all system variables",
"	list global variables | List all global variables",
"	list local variables | List all local variables",
"	list functions | List available functions",
"	explain functions | Explain avaialble functions",
"	inspect | Inspect a variable, inclding all member variables (arrays, structures)",
"	view | View a table in a browser or Excel.",
"	==="
 ]
	

  }


,

  "Table of Contents" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Table of Contents" ],
    "Keywords":			[ "Reference Manual" ],
"Description 01:Table of Contents" : [
"",
"	See the navigator bar for full table of contents.",
""
 ]
	
  },


  "Introduction" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "introduction" ],
"Description 01:Introduction to B4P" : [
"",
"	<b> B4P a Low-Code Solution for data analysts to dramatically improve their performance in extracting insights from big data.</b>  B4P is a powerful data integration and analytics engine with built-in programming language, and is purpose-built for high speed processing and analysis of large, complex data sets (tens of millions of rows) from multiple diverse data sources to produce rapid insights in easily understood form in Excel or other standard visualization tools. ",
"",
"	<br><br>",
"",
"	<br/><img src=\"Images/B4P_General_Overview.png\" alt=\"B4P Overview\"><br/>",
"",
"",
"	=== 250, 600, noframe_1stcolbold, noheader",
"			| <b> data files </b>:  Excel, XLS, CSV, XML, JSON, HTML, Zip, Text, others..",
"			| <b> databases </b>:   Exports from corporate databases (Salesforce, Oracle, SAP, Access, ..)",
"			| <b> web data </b>:    Any source of structured data on the web(Wikipedia, ...)",
"			| <b> other data </b>:  PDF (via Tabula), Statistical data sets (R, SAS, SPPSS, Stata)",
"	===",
""
 ]
	,

	

"Description 02:Distinct Language Features" : [
"",
"	<b> B4P includes an <i>interpreted language</i> with powerful syntax, highly flexible data structures, and a large function library which enables immediate results with a minimum of code. </b>  Programs containing just a few statements can perform sophisticated operations such as merging two tables with very different data arrangements and formats.  The following key features makes the B4P language distinct from other popular programming languages:",
"",
"	<br><br>",
"",
"	=== 240, 760, noframe_1stcolbold, noheader",
"	Interpreted	| The __run-time machine__ is designed to __echo(__) interpret and process the code with very high performance. One performance aspects includes checking and tokenizing the code before starting to run.",
"	Fully portable across system platforms | B4P runs on WINDOWS, LINUX and MAC-OS.  You can develop your apps so they run on all platforms without changing the code. B4P provides harmonized functions for directory, file and system function calls, as well as system variables such as user names, key system directory names, etc.",
"	Names with spaces and special characters | You are allowed to use spaces and special characters in function names, variable names, table names, column header names, etc.  <b>max value[]</b> and <b>'1%'[]</b> are valid variable names. This allows you to use typical column headers, e.g. \"Total Costs\", without modifying them or putting quotations around. A valid function call could be \" table create (customer table, supplier table, … ); \" Function names like \"table process selected rows\" is easier to read than \"TableProcessSelectedRows\"",
"	Variables | All simple variables end with brackets <b>[]</b>  Example: <b>value[]</b>. If you forget them, then the name is just a text value.<br/>You can create child variables with any nesting, <br/>e.g. <b>animal[dog]=poodle; animal[cat]=tiger; animal[dog,leg count]=4;</b>.<br/>You can also define arrays, e.g. <b>matrix[2,3]</b>",
"	Values | Numbers are values, text are values, too.  In the example <b>a[] = bull dog ;  b[] = ' bull   dog ';</b> a[] is assiged with <i>'bull dog'</i> containing one space between the two words, whare as b[] is assigned with <i>' bull   dog '</i> where all spaces are preserved.  Without quotation marks, outside spaces and repeated spaces betwen words are ignored.",
"	Full UNICODE support | Every character counts as 1 character, regardless if ANSI (like 'e'), inside the Basic Multilingual Plane (like &eacute; and &euro;), or in one of the other UNICODE planes (e.g. &#x1F609;).",
"	Basic variable types | They are <i>numeral</i>, <i>literal</i>, <i>boolean</i>, <i>date</i> (manages date, time and both), <i>parameter set</i>, and <i>void</i>.",
"	Parameter sets | Very powerful type to combine any number of variables and nested parameter sets into one parameter set.<br>Example: <b>names[] = {Abel, Beata, Charly};</b>",
"	Dynamic weak typing | B4P uses dynamic weak typing.  The type is set once a value is assigned. Example: <b>a[] = 1;</b> automatically declares a[] as a numeric variable. <br>The type will change if something non-numeric is assigned, eg. <b>a[] = Hello;</b>.",
"	Tables | Tables are the heart of B4P.  Typically referenced as <b>[table name : row , column ]</b>.<br/>If a conext with table name and row number is given, e.g. inside a loop, then a simple reference like <b>[column]</b> is sufficient.<br>Example: <b>table process</b>( membership list, <b>echo</b>( [Family Name], \", \", [First Name] );",
"	Accessing multiple values in tables | Powerful schems are available to access individual cells, entire rows or parts of them, entire columsn or parts of them, or combination of all.",
"	Powerful table processing function library | A large number of procedures and functions is available to analyze, process and combine tables as you wish.  These functions deliver highest machine performance.",
"	Transactions | Very smart assignments for variables and table rows. You can replicate variables including all child members, or combine two variables including their member variables.",
"	Function parameters accept code pieces | Unlike in other languages, some functions accept pieces of code such as expressions and statements as input parameters.  These codes may be executed several time. <br/>Good example: <b>table process</b>( members, [full name] = [1st name] + ' ' + [last name] );",
"	Variable count function parameters | Some functions accept a variable number of parameters, with minimum, maximum and incrementals given.",
"	User definable procedures and functions | You can defined own procedures and functions.  Functions provide return values whereas procedures don't.  You can assign multiple function names to the same user-defined code. In this case, the pre-defined local variable <b>function name[]</b> allows to identify the function name used to call the code.",
"	Indirect parameter passing | Some procedures and functions allow one <i>parameter set</i> variable to be used to provide all function parameters in one.<br/>Example: a[] = { 2,3,4 }; <b>echo</b>( <b>min</b>( 2,3,4 ), ' and ', <b>min</b>( a[] ) ); // Output in both cases is 2.",
"	Deep unary and binary operators | Deep operators (supplemented with the circumflex '^' symbol) can be used to calculate with elements inside parameter sets. <br/>Example: { 1,2,3 } +^ { 4,5,6 } results in { 5,7,9 }.  However, { 1,2,3 } + { 4,5,6 } results in {1,2,3,4,5,6} instead.  Deep operations are analogous to vector and matrix operations.",
"	Control flow | Unless in other programming languages, control flow features like __if(__), __for(__), __while(__), __return__, etc. are actually procedure and function calls.  Something as simple as <b>if</b> takes one boolean value as function parameter and decides whether to execute or skip the next statement or code block.  In fact, this is made possible because procedures and functions can accept code pieces as it is required for functions like <b>for</b>.",
"	Portable directory paths | B4P accepts both '/' and '\\' for path separators. They will be adjusted automatically to match with the operating system requirements.",
"	===",
"	"
 ]
	,

"Description 03:Think Big to be Successful" : [
"",
"	You can unleash the full power of B4P if you are thinking big.  Writing a complete end-to-end solution (with loops, variable assignments, comparisons",
"	of individual values, etc.) is straighforward to learn with no special programming background.  Other languages like Python can do similar processing, but requires one to learn object-oriented programming, and does not scale for complexity.",
"	",
"",
"	=== 60, 940, noframe_1stcolbold, noheader",
"	Hint 1 | Use the rich B4P function library to process these tables and big data.  Large tables will be analyzed and processed at naked machine performance.<br/>",
"	Hint 2 | Use deep operations (vector and matrix operations) to process large amount of data inside tables and parameter sets.<br/>",
"	Hint 3 | Think how you can formulate your code in a very compact manner without compromising comprehensibility.  Doing great things with 5-20 lines of code is within reach.<br/>",
"	==="
 ]
	
  }


,

  "Licensing" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "licensing" ],
    "Keywords":			[ "licensing","unlock" ],
"Description 01:Licensing Scheme" : [
"",
"	Without possessing a license, B4P will start in a demo mode and exploit the full performance.  The demo mode is useful for evaluations,",
"	demo, education and doing small projects.  However, following restrictions apply:",
"",
"	=== 240, 760, noframe_1stcolbold, noheader",
"	Table size restrictions when saving	| Tables can only be saved if the table contains not more than 300 rows and not more than 40 columns.",
"	Number of savings 			| During a running B4P session, at most 5 tables can be saved.  The number of tables (and not files) also applies when using the procedure <b>table save multiple</b> to save two or more tables in one file.",
"	===",
"",
"	Table size restrictions do not apply while processing tables internally, i.e. you are able to load large amounts of data and do data processing and",
"	analysis, but need to condense your output accordingly inorder to meet the size limitations.",
"	<br/><br/>",
"	Individual licenses for one machine, a specific domain or site licenses will be provided on request.",
""
 ]
	
  },

  "Starting B4P" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "starting" ],
    "Keywords":			[ "installing","installation", "starting","launching", "command line options" ],
"Description 01:Installation" : [
"	A separate presentation is available which guides through the installation of B4P under Windows and Linux."
 ]
	,
"Description 02:Starting B4P from Windows" : [
"",
"	=== 240, 760, noframe_1stcolbold, noheader",
"	Start menu					| Click on the start menu and select \"B4P\".",
"	Desktop icon					| If activated during installation, then click on the desktop icon.",
"	Click on B4P ap (.b4p file)			| In a file explorer or on the desktop, double-click on a .b4p-file to run it directly.  Windows will automatically start B4P with that file when running .b4p files.",
"	Command line 					| Enter \"B4P\" alone or followed by B4P app file.  In Windows, the <b>Path</b> environment variable includes looking for B4P. Example: <b>B4P HelloWorld.b4p</b",
"	==="
 ]
	,

"Description 03:Starting B4P from Linux" : [
"",
"	=== 240, 760, noframe_1stcolbold, noheader",
"	Command line	| Enter <b>/usr/local/bin/b4p</b>.  To start a specific B4P application sript, then add the file name as command line parameter.  Example: <b>/usr/local/bin/b4p HelloWorld.b4p</b>",
"	Shebang		| If the file contains <b>#!/usr/local/bin/b4p</b> in the 1st row, and the B4P file contains Linux-compliant line breaks (line feeds without carriage return symbols), then B4P will be started automatically as the interpreter when executing the specified file.  The file must be configured as executable, e.g. with the command <b>chmod 755 *.b4p</b>",
"	==="
 ]
	,

"Description 04:Starting B4P from MacOS" : [
"",
"	The same rules apply as for Linux."
 ]
	,

"Description 05:Command Line Arguments" : [
"",
"	Additional information, for example file names, can be added as further command line arguments.  Inside the B4P app, the command line arguments are accessible by referencing the global variable <b>command line arguments[]</b> which is configured as an array of literals."
 ]
	,

"Description 06:Starting Behvavior" : [
"",
"	If B4P is started from the start menu, desktop icon or entered command without specifiying an application script, then B4P undertakes the following steps:",
"",
"	=== 40, 860, noframe_1stcolbold, noheader",
"	1.	| Look in the current working directory for the file name \"main.b4p\".  If found, then B4P starts this application script.",
"	2.	| Look in the starting directory (a memorized directory name you can inspect and change with the __starting directory(__) function) for \"main.b4p\".  If found, then the current working directory will be changed to the that starting directory (unless command line option -d is used) and the \"main.b4p\" will be started.",
"	3.	| If \"main.b4p\" cannot be found at all, then interactive mode will be started.",
"	===",
"",
"	If B4P is started with an application script, the following steps will be undertaken:",
"",
"	=== 40, 860, noframe_1stcolbold, noheader",
"	1.	| The current working directory will be set to the directory where the application script is located (unless command line option -d is used)",
"	2.	| The application script will be started immediately.",
"	===",
"",
"" ],
"Description 07:Command Line Options (Switches)" : [
"",
"	Following command line options influence B4P startup behavior. These options are not added to the global variable array <b>command line arguments[]</b>.",
"",
"	=== 40, 960, noframe_1stcolbold, noheader",
"	-d	| Suppress changeing the current working directory to the directory where the B4P app is started.",
"	-i	| Start B4P and enter interactive mode immediately. You can execute any B4P statement as a command. In addition, you can inspect variables and execute operating system commands. You can start B4P apps by typing <b>start (filename.b4p)</b>.",
"	-w	| Suppress B4P welcome text. <br><u>Attention 1:</u> Also the license info text (e.g. demo mode only if no valid license exists) will be hidden.<br><u>Attention 2:</u> Important B4P library files (e.g. \"Support Library\") will not be loaded automatically.<br>The system variable <b>runtime settings[verbose]</b> is set to <b>quiet</b>. This feature is useful for batch scripts which shall run fast and not outputting unnecessary text.",
"	-x	| Skip the \"<i>Press [Enter] to end the program</i>\" before B4P is exiting.  Useful for running B4P apps from batch scripts.",
"	-q	| Starts the B4P program with runtime <b>settings[verbose]= quiet</b> to suppress any unnecessary output.",
"	-I	| MacOS / Linux only: Starty B4P in installation mode where the welcoming text and loading library files are skipped.  Not recommended for normal applicaction use.",
"	===",
"",
"	Invalid command line parameters will provide descriptive error messages and stop B4P.<br><br>",
"	Command line arguments may be freely ordered and specified as combined or individual parameters.  See below."
 ]
	,

"Examples 07:5 ways to start B4P with the same command line options" : [
"	b4p -wx myprogram.b4p	// All 5 variants are equivalent.",
"	b4p myprogram.b4p -wx",
"	b4p myprogram.b4p -xw",
"	b4p -w -x myprogram.b4p",
"	b4p myprogram.b4p -w -x"
 ]
	,

     "See also": [ "Interactive Mode" ]

  }


,

  "Locales" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "Locales" ],
    "Keywords":			[ "list of Locales", "locale" ],
"Description 01:Introduction" : [
"",
"	Beyond4P is able to support different locales (regional and language specific settings) which are managed in ",
"	a file called \"List of locales.csv\".  This file comes along with the installation package and will be referenced automatically",
"	whenever locale information is needed to carry out a particular function, e.g. converting a __date__ to a __literal__.",
"",
"	<br><br>",
"	The locale settings influence information processing such the following described below:",
"",
"	* Region-specific number formats (choice of decimal and thousand separator symbols)",
"	* Date formats (e.g. MM/DD/YYYY or DD/MM/YYYY as default)",
"	* Weekday and month names in different languages",
"	* Using the right list separator for loading and saving CSV files for interaction with Excel (some countries-specific installations use comma, others use semicolon)",
"	* Currency names and symbols",
""
 ]
	,
"Description 02:Specifying locales" : [
"	Locales typical comprise of a combination of abbreviated language name followed by country name with an underscore symbol inbetween, e.g. \"de_CH\" for",
"	<b>German language, Switzerland</b>.  You may also specifc country or language names only, however they create ambiguitiess with countries where more than",
"	one language is spoken (or better: supported, e.g. Canada), and languages which are spoken in several countries (e.g. English).",
"",
"	<br><br>",
"	For all functions asking for <i>locale</i> parameters, you can specify the locale, the language or the country.  No case sensitvity applies, meaning that",
"	both \"en_US\" and \"EN_us\" are accepted, as well as \"USA\" and \"usa\".  If only the language or the country is chosen, then the first match applies.",
"	Therefore, make it a habit to specify locales precisely using the pair of abbreviations.",
"",
"	<br><br>",
"	Special values:",
"	* none = Apply no locale specific context",
"	* local = Apply presently appliable settings, either set during program installation, or modified with __set locale(__) function call.",
"",
""
 ]
	,
"Description 03:Functions asking for locales" : [
"",
"	* __literal(__), __softquoted literal(__): 2nd function parameter",
"	* __set locale(__): 1st function parameter (must be a locale value, not country or language name alone=)",
""
 ]
	,
"Description 04:Supported locales" : [
"",
"	=== 100, 100, 100, 700",
"	Locale		| Language	| Country		| Explanation",
"	none		| none		| none			| Suppresses thousand separator, date is in universally recognized YYYY-MM-DD format",
"	en_US		| English	| USA			| Decimal point, 1000-comma, M/D/YYYY",
"	en_GB		| English	| Great Britain		| Decimal point, 1000-comma, DD/MM/YYYY",
"	en_CA		| English	| Canada		| Decimal point, 1000-comma, DD/MM/YYYY",
"	en_DE		| English	| Germany		| Decimal comma, 1000-point, DD/MM/YYYY, weekday and month names are in English",
"	en_CH		| English	| Switzerland		| Decimal comma, 1000-point, DD/MM/YYYY, weekday and month names are in English",
"	en_AT		| English	| Austria		| Decimal comma, 1000-point, DD/MM/YYYY, weekday and month names are in English",
"	en_FR		| English	| France		| Decimal comma, 1000-space, DD/MM/YYYY, weekday and month names are in English",
"	en_SE		| English	| Sweden		| Decimal comma, 1000-space, YYYY-MM-DD, weekday and month names are in English",
"	en_IN		| English	| India			| Decimal point, 1000-comma, D/M/YYYY, weekday and month names are in English, <br>Note: Different thousand-separation scheme applies in India: 12,34,567.89 ",
"	in_IN		| Indian	| India			| Decimal point, 1000-comma, D/M/YYYY, <br>Note: Different thousand-separation scheme applies in India: 12,34,567.89",
"	de_CH		| German	| Switzerland		| Decimal point, 1000-apostrophe, DD.MM.YYYY",
"	de_DE		| German	| Germany		| Decimal comma, 1000-point, YYYY-MM-DD",
"	de_AT		| German	| Austria		| Decimal comma, 1000-space, DD.MM.YYYY",
"	de_IT		| German	| Italy			| Decimal comma, 1000-point, DD.MM.YYYY, weekday and month names are in German",
"	fr_CA		| French	| Canada		| Decimal point, 1000-space, YYYY-MM-DD, weekday and month names are in French",
"	fr_FR		| French	| France		| Decimal comma, 1000-space, DD.MM.YYYY",
"	fr_CH		| French	| Switzerland		| Decimal comma, 1000-space, DD.MM.YYYY, weekday and month names are in French",
"	fr_BE		| French	| Belgium		| Decimal comma, 1000-space, D/MM/YYYY, weekday and month names are in French",
"	it_IT		| Italian	| Italy			| Decimal comma, 1000-point, DD/MM/YYYY",
"	it_CH		| Italian	| Switzerland		| Decimal point, 1000-apostrophe, DD.MM.YYYY, weekday and month names are in Italian",
"	es_ES		| Spanish	| Spain			| Decimal point, 1000-comma, D/MM/YYYY",
"	es_US		| Spanish	| USA			| Decimal point, 1000-comma, M/D/YYYY, weekday and month names are in Spanish",
"	sv_SE		| Swedish	| Sweden		| Decimal comma, 1000-space, YYYY-MM-DD",
"	===",
""
 ]
	

  }


,

  "Path and File Names" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "path names" ],
    "Keywords":			[ "path name", "path names", "file name", "file names" ],
"Description 01:Introduction to portable Path Names" : [
"",
"	The different operating systems (Windows, LINUX, MACOS) use different conventions to specify drives, directory path names",
"	and file names.  Directory separators (slash or backslash) is one example.  FUll case sensitivity of path and file names in LINUX and MACOS",
"	environments is another example. Beyond4P supports some measures in order to make path and file naming more portable for the applications.",
"",
"	* Both directory separator symbols \"/\" (UNIX/ / LINUX style) and \"\\\" (WINDOWS style) are supported.  They will be changed to the right symbol automatically before accessing directories and files in the present operating system.",
"	* Returned directory and file names, e.g. in directory listings, __file search(__) function, etc. will use the directory separator native to the operating system (e.g. \"/\" under LINUX).",
"	* Under LINUX and MACOS, the file names are fully case sensitive.",
"	* Under Windows, case sensitivity only applies to creating new directory and file names.",
"	* Please avoid using following special symbols in file names:",
"	** : Colon - Used to specify drives in Windows environments",
"	** \", ' quotation marks - Not valid as part of file name.  Quotation marks may be needed at command level to specify path and file names containing spaces, but not to be done in Beyond4P code.",
"	** *, ? wildcard symbols",
"	** , comma - Beyond4P uses commas to specify multiple file names, e.g. in the __directory listing(__) function",
"	** & ampersand - Typically a control symbol for operating system command shells",
"	** &lt;, &gt;, | - Rediction and piping",
"	** /, \\ - Directory separators",
"	* Further OS-specific restrictions on path and file names may apply",
"	* __Wildcard symbols__ are resolved by Beyond4P and not by the operating system.",
""
 ]
	

  }


,

  "Reserved keywords" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "reserved keywords" ],
    "Keywords":			[ "keywords" ],
"Description 01:Introduction to reserved keywords" : [
"	Beyond4P has only six reserved symbols.  If not put into quotation marks, these special symbols are automatically converted into special characters or values.",
"",
"",
"	=== 120, 120, 360, noframe",
"	Keyword 	| Meaning | Description",
"	tab		| Tabulator | Converts to a tab character (ANSI and UNICODE 9)",
"	new line	| Line Break | Converts to CR+LF (Windows) or LF (LINUX) to continue on the next line",
"	escape		| Escape chracter | Converts to an escape character (ANSI and UNICODE 27)",
"	true		| Boolean true  | 'true' as boolean type, not literal",
"	false		| Boolean false | 'false' as boolean type, not literal",
"	else		| 'else' in code syntax | To be used in association with <b>if</b>, <b>switch</b> and other control flow functions",
"	===",
"",
"	You may wonder why obvious names such as 'if', 'while' and 'for' are not considered as similar reserved keywords.  In Beyond4P, the control flow statements",
"	are actually procedure names which then influence executing further statements or blocks.  Therefore, you can actually use 'if' as the given function."
 ]
	,
"Examples 01:" : [
"	echo( type(true) );",
"	echo( 1st line, new line, 2nd line );"
 ]
	,
    "Output 01:":		"automatic",
"Examples 02:" : [
"	echo( 1, tab, 2, tab, 3 );"
 ]
	,
    "Output 02:":		"automatic",
    "OS differences":		[ "LINUX uses a different representation of 'new line' than Windows." ],
    "See also":			[ "Flow control functions" ]

  }


,

  "Variables" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "variables" ],
    "Keywords":			[ "variables", "base variables", "base variable", "member variable", "member variables" ],
"Description 01:Introdction to Variables" : [
"",
"	Beyond4P provides a unique model to manage variables. ",
"",
"	<br><br>",
"",
"	Different from other programming languages, probably looking a bit outlandish, but intended for a good reason, all variables are specified",
"	with brackets at the end. Example: <b>Last Name[]</b> is a legitimate variable name (Note the two words).  Referencing a variable is",
"	a combination of an expression providing a literal followed by these two brackets.  This flexibility, not available in other languages,",
"	allows you to assign table header names, tale contents, and any literal values, etc. as variable names.",
"",
"	Following naming rules apply:",
"",
"	* The naming rule applies to __base variables__ as well as member variables in __structures__.",
"	* Variable names may consist of multiple words and any character is allowed.",
"	* Use quotation marks to preserve multiple blanks or accept special symbols inside variable names.  Valid example: <b>' (1.)'[]</b>",
"	* Non-ANSI characters are allowed, e.g. <b>Caf&eacute;[]</b>",
"	* Blank variable names are also allowed, e.g. <b>''[]</b>.  Attention: Inside __structures__, blank member names will be referred as default member variables.",
"	* Any expression returning a literal is allowed, e.g. <b>(\"Hel\" + \"lo\")[]</b> references the variable <b>Hello[]</b>.",
"	* Indirect variable referencing is allowed, e.g. <b>a[][]</b> access variable using the name as specified in variable <b>a[]</b>. ",
"" ],
"Description 02:Scoping - Global and Local Variables" : [
"",
"	Beyond4P variables are created (also known as <i>declared</i>) at their first assignments.  For example, <b>a[] = 1;</b> creates the variable",
"	<b>a</b> and assigns the numeric value 1 to it.  ",
"	If the variable is created outside procedure or function definition blocks and the Beyond4P is the initial",
"	program started (i.e. the program file is not called by another Beyond4P program using the __start(__) function), then the variable will be a global",
"	variable visible all time until deleted.  Otherwise, if the variable is created inside a procedure of function definition block, of if the running",
"	programm was called by another Beyond4P program, then new variables will be created as local variables.  Local variables are only visible in the",
"	current program resp. function definition block and are not visible if another program or user function is called.  ",
"",
"	<br><br>",
"	Variables may be deleted using the __delete(__) function.  Local variables will be deleted automatically when leaving (returning from) user-defined",
"	procedures and functions or called programs.",
"",
"" ],
"Description 03:Variable Attributes" : [
"",
"	In Beyond4P, every variable stored contains following information:",
"",
"	=== 200, 800, noframe_1stcolbold",
"	Attribute       | Description ",
"	Variable Name   | A literal of choice.  Exception: Array members have no names.",
"	Value		| Stored value (Base Variable)",
"	Data Type       | Distinguishes among __numeral__, __plain numeral__, __date__, __plain date__, __literal__, __softquoted literal__, __quoted literal__, __boolean__, __void__, and __parameter set__. ",
"	Variable Form   | Distinguishes whether the variable is a __simple variable__, an __array__ or a __structure__, or a simple variable containing __zero members__",
"	Members		| Contains all member variables (in __arrays__ and __structures__).  Every member is treated like an individual variable, too.",
"	Member count	| Number of existing members (0 for simple variables)",
"	Protection Setting | Applies rules on accessing and/or modifying these variables, e.g. read-only, prevent deleting, etc.  See function __protect(__)",
"	Locked          | Variables may be temporarily locked during the time while an assignment on that variable is executed or a __reference__ is pointing on this variable.  Locked variables cannot be deleted.",
"	===",
"" ],
"Description 04:Building Variable Trees with Arrays and Structures" : [
"",
"	With Beyond4P, you can create simple variables as well as arrays (containing numbered member variables) and structures (containing named member",
"	variables).  Full nesting flexibility is supported: Arrays and structures may contain further structures and/or arrays as you wish.",
"	In short, the variable storage model is a tree structure which can hold data in the root node (base variable), intermediate nodes (e.g. member",
"	variable also containing sub-members) and leaf nodes (final member variables without further members defined).",
"",
"	=== 200, 600, 200, noframe_1stcolbold",
"	Variable Form | Description | Example",
"	__Simple Variables__ | Simple variables hold one base variable value of any data type (numeral, literal, date, boolean, void and paramter set) and contain no members. | last name[]",
"        __Arrays__           | In addition to the base variable, arrays a defined number of numerically indexed members | member [1], member[3]",
"	__Structures__       | In addition to the base variable, structures contain one or more named member variables | animal[dog], animal[cat]",
"	__Zero Members__     | Very similar to simple variables.  Contains base variable and zero members, but has previously had array or structure members which have been deleted meanwhiel.  The variable form changes to __structure__ if a structure element is added, or to __array__ if an array member is added.",
"	===",
"",
""
 ]
	
  },

  "Simple Variables" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "simple variables" ],
    "Keywords":			[ "simple variables", "simple variable" ],
"Description 01:Simple Variables" : [
"",
"	Simple variables contain only one value and posesses no further member variables in form of structures or arrays.",
"",
"	<br/><br/>",
"	Syntax for a simple variable:  <b>Variable Name [ ]  </b>",
"	<br/><br/>",
""
 ]
	,

"Examples 01:" : [
"	a[] = Hello;",
"	(a[])[] = Hi; // Parentheses required on left hand side, ",
"	              // otherwise seen as \"right hand\" expression and not \"left hand\" expression",
"	(a[] + ' World')[] = Ahoi;",
"	echo(\"a[]     = \", a[] );",
"	echo(\"a[][]   = \", a[][] ); // Here it's OK",
"	echo(\"Hello[] = \", Hello[] );",
"	echo(\"Hello World[] = \", Hello World[], new line );",
"",
"	'1'[] = One; // Even these variable names are valid !",
"	' '[] = Space;",
"	''[] = Blank;",
"	'a[]'[] = aaaah;",
"	echo('1'[], \" \", ' '[], \" \", ''[], \" \", 'a[]'[], new line );",
"",
"	me too[] = Hmm;",
"	me  too[] = Me;   // Unquoted literal ignores redundant spaces, same as 'me too'",
"	'me  too'[] = Mee too;",
"	echo( me too[], \", \", me  too[], \", \", 'me  too'[] );"
 ]
	,
    "Output 01:":		"automatic"


  },

  "Arrays" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "arrays" ],
    "Keywords":			[ "array", "arrays" ],
"Description 01:Arrays" : [
"",
"	Arrays are variables with members which are only referenced numerically using an index value.  Arrays support negative indexing, meaning that -1, -2, etc. references",
"	the last, 2nd last and further array elements.  A variable cannot be an array and a structure at the same time, i.e referencing an array with a member name",
"	causes an error.",
"",
"	<br/><br/>",
"	Syntax for referencing arrays:  <b>Variable Name [ index ]  </b>",
"	<br/><br/>",
"",
"	Following rules apply to the index:",
"	* The index must always be a numeric value.",
"	* Indexing begins with 0 (zero).",
"	* The value will be rounded in case it does not contain an integer value.  Example: <b>a[4.99]</b> accesses the same member as <b>a[5]</b>.",
"	* Negative index values are supported. -1 refers to the last element in the array. -2, -3, etc. refer to the next members above.",
"	* Exceptions are asserted when attempting to read non-existing members",
"	* Arrays will be extended when attempting to write using index values bigger than the current array size.",
"",
"",
"	<br><br>",
"	Following approaches are avialable to create arrays:",
"	=== 200, 800, noframe_1stcolbold, noheader",
"	dim...() function family | Functions such as __dim(__), __redim(__), __dim protect(__) and __redim protect(__) initialize arrays with a specified number of elements and initial values.",
"	array...() | Functions like __array(__) and __array protect(__) create arrays with initial values provided in parameter sets.",
"	Direct referencing | Assigning a simple variable with an index will automatically create an array with members 0...<i>index</i> where the members inbetween are not initialized and return __void__ values.",
"	===",
"",
"	<br><br>",
"	Individual member variables may be deleted using the __delete(__) function.  If a member in the beginning or middle of the arrary is deleted, then all other members move up accordingly.",
"",
"",
""
 ]
	,
"Examples 01:" : [
"	",
"	echo(\"Initialize variable with dim function:\");",
"	dim( a[], 5, '.' );",
"	inspect( a[] );",
"",
"	echo(new line, \"Initialize variable with array function:\");",
"	array( a[], { Ha, He, Hi, Ho, Hu, Ahoi } );",
"	inspect( a[] );",
""
 ]
	,
    "Output 01:":		"automatic",

"Description 02:Nesting" : [
"	Nesting is supported: Every array element may be a simple variable, a further array of any size or a structure.",
"	A (m x n) multi-dimensional array is a nested array with <i>m</i> members and each member containing <i>n</i> sub-members.",
"	Since Beyond4P variable structure is a tree with values possible in both root, intermediate and end nodes, the base variables as well as",
"	member variables of those containing sub-members are preserved.",
"",
"",
"	<br/><br/>",
"	Syntax for referencing nested arrays:  <b>Variable Name [ index1, index2, ... ]  </b><br>",
"	Syntax for referencing nested structures in arrays:  <b>Variable Name [ index, Member Name, ... ]  </b>",
"	<br/><br/>",
"",
""
 ]
	,

"Examples 02:" : [
"",
"	echo(\"Initialize a 2-dimensional array:\");",
"	dim( a[], {2,3}, '0' );",
"	inspect( a[] );",
"",
"	echo(new line, \"Initialize two arrays (2nd one is nested) implicitly:\");",
"	b[2] = true;",
"	b[1,2] = 123;",
"	inspect( b[] );",
""
 ]
	,
    "Output 02:":		"automatic"

  },

  "Structures" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "structures" ],
    "Keywords":			[ "structure", "structures" ],
"Description 01:Structures" : [
"",
"	Structures are variables with members which are referenced by <i>member names</i>.  Structures are useful for following pruposes: 1) managing",
"	your variables in a structured manner, and 2) providing a form of associative storage.  Beyond4P maintains the members in alphabetical order automaatically",
"	and uses a very fast bisectional algorithm to find the specified variable.  For example, max. 16 internal queries are needed to",
"	access a a member with a given member name in a structure containing more than 65,536 members.",
"",
"	<br/><br/>",
"	Syntax for referencing structures:  <b>Variable Name [ Member Name ]  </b>",
"	<br/><br/>",
"",
"	The same rulesa for variable names apply for member names.",
"",
"",
"	<br><br>",
"	Similar to arrays, existing structures may also be referenced with numeric <i>index</i> values.  This is useful when using loops to process",
"	through the structure rapidly.  Please note that the structure is always held in an alphabetic order.  Negative indexing is also supported, where",
"	-1 refers to the last element (last in alphabetical order), and -2, etc., to the next ones above.",
"",
"	<br><br>",
"	Following approaches are avialable to create structures:",
"	=== 200, 800, noframe_1stcolbold, noheader",
"	structure...() | Functions like __structure(__) and __structure protect(__) create structures with intial member names and values provided in two parameter sets.",
"	Direct referencing | Assigning a simple variable with a member name will initialize it with a structure.  This will not be possible if the variable is already an array.",
"	==="
 ]
	,
"Examples 01:" : [
"	",
"	echo(\"Initialize a structure directly\");",
"	a[dog] = Hund;",
"	a[cat] = Katze;",
"	a[gnu] = Gnu;",
"	echo(a[cat]);",
"	inspect( a[] );",
"",
"	echo(new line, \"Initialize with the structure function\");",
"	structure( leg count[], { snake, bird, dog, fly, tick }, { 0, 2, 4, 6, 8 } );",
"	inspect( leg count[] );",
""
 ]
	,
    "Output 01:":		"automatic",

"Description 02:Nesting" : [
"	Nesting is supported: Every structure element may be a simple variable, a further structure or array of any size.^",
"	Since Beyond4P variable structure is a tree with values possible in both root, intermediate and end nodes, the base variables as well as",
"	member variables of those containing sub-members are preserved.",
"",
"	<br/><br/>",
"	Syntax for referencing nested arrays:  <b>Variable Name [ Member Name 1, Member Name 2, ... ]  </b><br>",
"	Syntax for referencing nested arrays in structures:  <b>Variable Name [ Member Name, index, ... ]  </b>",
"	<br/><br/>",
""
 ]
	,

"Examples 02:" : [
"	",
"	echo(\"Initialize a nested structure containing structure and array\");",
"",
"	city[] = Paris;",
"	array( city[district], {ignoe 0, Louvre, Bourse, Temple, Hotel de Ville, etc. } );",
"	city[district,2,area] = 99; // 99 hectars",
"	city[district,2,inhabitants] = 19500;",
"	echo(\"1st  district = \", city[district,1], \"   last district = \", city[district,-1] );",
"",
"	inspect( city[] );"
 ]
	,
    "Output 02:":		"automatic",

"Description 03:Default Members" : [
"",
"	Normally, attempting to access a structure with a non-existing element name will cause an error.  Beyond4P supports default members",
"	which will be returned in case of no matches.  Assign the default value using a blank literal ('') as member name and that's it.",
""
 ]
	,

"Examples 03:" : [
"	",
"	echo(\"Demonstrate default values\");",
"",
"	structure( a[], { cow, horse, pig, sheep, '' }, { Kuh, Pferd, Schwein, Schaf, No translation } );",
"	echo( \"cow : \", a[horse] );",
"	echo( \"goat: \", a[goat] );",
""
 ]
	,
    "Output 03:":		"automatic"

  },


  "Zero Members Variables" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "zero members" ],
    "Keywords":			[ "zero members" ],
"Description 01:Zero Members" : [
"",
"",
"	Zero members avariables are very closely related to simple variables.",
"	The only difference is that these variables have contained __array__ or __structure__ members before, but all members have",
"	been deleted meanwhile.  In some application cases, e.g. loading variables from __JSON__ files, zero members may be useful to distinguish",
"	between loading empty arrys and no arrays at all.",
""
 ]
	,

"Examples 01:" : [
"	",
"	echo(\"Distinguish between simple and zero members variables\");",
"	a[] = Hi;",
"	echo(identify(a[0])); // simple",
"",
"	a[0] = Ho;",
"	echo(identify(a[0])); // array",
"",
"	delete(a[0]);",
"	echo(identify(a[0])); // not found",
"	echo(identify(a[])); // zero members",
"",
"	a[dog] = Hund;",
"	echo(identify(a[])); // structure",
"",
""
 ]
	,
    "Output 01:":		"automatic"

  }



 	
,

  "Verbose Levels" :
  {
    "Documentation":		"General Description", // Required value
    "Feature Names":		[ "verbose" ],
"Description 01:Verbose Level Settings" : [
"",
"	The __system variable__ <b>runtime settings[verbose]</b> rules the amount of additional console output messages to be generated which",
"	could be helpful for developing the code.  The default verbose setting is <b>low</b>.  This setting can be changed anytime.",
"	In addition, if the B4P program is called from command line, the command line switches <b>-q</b> and <b>-w</b> will set this setting to <b>quiet</b>.",
"",
"	Following verbose settings are supported:",
"",
"	<b>quiet</b><br>",
"	* No additional output is generated other than explicitly instructed in the B4P programs, e.g. using __echo(__) or __print(__).",
"	* However, error messages and important warning messages will definitely appear.",
"",
"	<b>low</b>: in addition to 'quiet' (default setting):",
"",
"	* Outputs progress info (percentage figures shown) if selected functions are processing big amount of data (e.g. large tables, large variable trees)",
"	* Short feedback messages on tables and variables loaded and saved (name of file, number of rows, etc.)",
"	* Info about standard B4P library files loaded (e.g. Support Library)",
"	* Some warnings, e.g. obsolete character sets found in input files",
"",
"	<b>medium</b>: in addition to 'low':",
"",
"	* Outputs the function names for the more sophisticated functions (e.g. __table consolidate(__) is included, but __abs(__) is not in order to avoid excessive messages) with first few paramters",
"	* Informs about the intermediate processing steps inside selected functions, e.g. __table load excel file(__)",
"",
"	<b>high</b>: in addition to 'medium':",
"",
"	* In addition to the function names printed out, all parameters provided will also be shown.",
"	* Further information on intermediate processing steps inside selected functions, e.g. __table merge (__)",
""
 ]
	
  }

,

"table compare ..." :
{
	"Function Names":	[ "table compare", "table compare ignore case", "table compare ignore blanks", "table compare ignore both" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		This function compares two tables intelligently and generates a comparison report with a level of detail you can define.",
"		The comparison can either take place using one or more columns for orientation (e.g. last name and first name) and compare",
"		the other values accordingly, or do a fully automatic comparison wihtout orientation.  Comparison includes checking all",
"		changes made, rows added and/or removed.",
"",
"		<br><br>",
"		The function endings <b>...ignore case/blanks/both</b> make comparisons tolerant to upper/lower case and/or spaces between words.",
"",
"		<br><br>",
"		This function is able to deal with tables where the columns and data rows of the two tables are different.",
"",
"		<br><br>",
"		The report contains the the comparison results. See __Table Comparison Reports__ for details.",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"4 - 7",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of existing newer table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "The table referred here is assumed to be the more recent table." ]
		},
		{ "Number": "2.",
		  "Name": "Name of existing older table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "The table referred here is assumed to be the baseline table." ]
		},
		{ "Number": "3.",
		  "Name": "Name of report table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "A new table will created.  If the table already exists, then it will be initialized." ]
		},
		{ "Number": "Opt. 4.",
		  "Name": "Orientation identifier columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
		  "Default value": "{} (none)",
"Description" : [
"		    If the table contains unique identifiers or other columns suitable for identifying the entry and providing orientation, for example a combination of last and first name,",
"			a social security number, a product serial number, company name, etc., then specify them in this function parameter.   It does not matter if",
"			some non-unique orientation values (e.g. 2 persons sharing the same first and last names, or only first names are known) do exist.  ",
"			Overall, use of orientation columns will accelerate the comparison process significantly.  A change of a value in an orientation column is interpreted as a new row added (and a different",
"			row possibly deleted).  ",
"			<br><br>",
"			The same orientation headers or column numbers must exist in both tables.  Otherwise, exceptions will be asserted.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified",
""
 ]
			
		},
		{ "Number": "Opt. 5",
		  "Name": "Reporting option",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Default value": "differences",
"Description" : [
"			Choose one of the following values:",
"			=== 200, 600, noframe_1stcolbold, noheader",
"			entire table		| The report has full table size: It contains all rows and all columns found in both tables, including the equal ones, and the differences are noted in their respective locations. ",
"			entire rows			| The report contains all columns found in both tables, but lists only the rows where the contents differ.",
"			differences			| Shows changes, otherwise blank fields",
"			different columns	| Like above, but deletes all columns where no different data have been found in the rows below below.",
"			different rows		| Like \"differences\", but deletes all rows where no	differences have been encountered.",
"			condensed			| Combination of 'different columns' and 'different rows': Only the rows as well as columns where differences are identified will be shown.",
"			journal				| Sequential change report: 1 difference documented per row with their locations in the old and new table as well as the old and new contents.",
"			==="
 ]
			
		},
		{ "Number": "Opt. 6.",
		  "Name": "Change indication call-back function name",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Default value": "'' (blank / no function provided)",
"Description" : [
"",
"		    If needed, specify the name of a __user-defined function__ which shall be called every time a difference has been identified.",
"			In the function, you can generate and return a custom-formulated way how to describe the difference.",
"			This function is supported in conjunction with all reporting options except <b>journal</b>.",
"",
"			<br><br>",
"			<u>Attention:</u> This function is not called for contents vanished by removal of columns.  Details are described below.",
"			<br><br>",
"			If no function is provided, following rule applies: Show new contents if available (if reporting options is entire table or entire rows), or different. ",
"			Show old contents in brackets [ ] if removed."
 ]
			
		},
		{ "Number": "Opt. 7.",
		  "Name": "Call function only if different",
		  "Direction": "input",
		  "Types": [ "boolean" ],
		  "Default value": "false",
"Description" : [
"			If true: Call change indication function only if the contents are different.<br>",
"			If false: Call change indication function for every cell"
 ]
			

		}
	],
	"Return value":
	[
		{ "Name": "Number of tables created or initialized",
		  "Types": [ "numeral" ],
"Description" : [
"			Returns one of the following values:",
"			=== 200, 600, noframe_1stcolbold, noheader",
"			identical			| Both tables are perfectly identical, including same order of rows and columns.",
"			equal				| Both tables contain same contents, however the rows and/or columns may be in a different order (e.g. sorted and unsorted table compared)",
"			less				| The newer table contains fewer rows and/or columns, but the remaining data is equal",
"			more				| The newer table contains additional rows and/or columns, but the existing data is equal",
"			different			| The newer table is different (contents have changed or both rows have been added and removed)",
"			failed				| An error has occurred. No comparison made.",
"			===",
""
 ]
		  
		}
	],
"Examples" : [
"	include ( Support Library );",
"",
"	table load( t1, \"Examples/Cities.csv\" );",
"	table keep columns ( t1, {City, Country, Inhabitants, Famous attraction, Moving along } );",
"	table keep selected rows ( t1, [Inhabitants]>=1000000 );",
"",
"	echo(\"Original table:\");",
"	table list ( t1 );",
"",
"	echo(\"Create a modified table:\");",
"	table copy table ( t1, t2 );",
"	table sort rows ( t2, City );",
"	table delete selected rows( t2, [City]==Los Angeles);",
"	table delete columns( t2, Country );",
"	table insert columns( t2, Time Zone, \"\", 3 );",
"	table append( t2, {{ Shanghai, 23000000, \"Jing'an Temple\", \"UTC+8\", Bicycle, Bla }} );",
"		// Last entry 'Bla' lies outside the colums with headers and is considered an orphan.",
"	[t2:City,Paris,Famous attraction] = Moulin Rouge;",
"	[t2:City,Paris,Time Zone] = \"UTC+1\";",
"	[t2:City,New York City,Inhabitants] = 8323340;",
"	table list ( t2 );",
"",
"	echo(\"Lets compare these tables:\");",
"	rv[] = table compare( t2, t1, report, City, different rows );",
"	echo(\"Return value from comparing: \", rv[] );",
"",
"	// Split statistics out in order to fit output onto the page.",
"	table split table columns( report, statistics, {Statistics Parameters, Statistics Values} );",
"	table delete blank rows( report );",
"",
"	echo(\"Comparison Report:\");",
"	table list ( report );",
"	echo(\"Statistics:\");",
"	table list( statistics );",
""
 ]
	,
	"Output": "automatic"

},


 "Table Comparison Strategy" :
  {
	"Documentation":		"General Description", // Required value
	"Feature Names":		[ "Table comparison strategy" ],
"Description 01:Introduction" : [
"",
"		The table comparison strategy consist of the following steps:",
"	",
"",
"		<br><br><b>Step 1 - Check column headers</b><br>",
"		The column headers of both old and new tables are checked for matches (commonalities).  ",
"		New column headers seen in the newer table are considered as 'columns added'.",
"		Column headers seen in the older table only are considered as 'columns removed'.",
"		In addition, the columns are checked if they have been shifted or been rearranged.",
"	",
"		<br><br><b>Step 2 - Check orientation identifier columns</b><br>",
"		Orientation columns can be supplied to declare specific columns as orientation or identifiers (such as names, serial numbers, etc.).  ",
"		See __table compare(__), 4th function parameter for details.  Here, the algorithm checks that the orientation columns are existing",
"		in both tables to be compared.",
"",
"		<br><br><b>Step 3 - Match rows with unique orientation identifier headers</b> (Appicable if orientation headers are provided)<br>",
"		The function will match all rows in the new table with their corresponding rows in the old table which have the same contents under the orientation headers.",
"		In case multiple rows are identified (non-unique orientation identifier contents), then the best fitting corresponding line in the old table will be identified.",
"",
"		<br><br><b>Step 4 - Match the remaining rows</b><br>",
"		In case no orientation headers are supplied, or non-unique rows with same orientation identifier values are still existing, then ",
"		these rows will be matched by comparing the remaining columns (or all columns if no orientation identifier has been provided).<br>",
"		<b>1st round</b>: Zero tolerance is applied.  All identical rows are matched.  If matches exist, mate them and consider them as done.<br>",
"		<b>2nd round</b>: Check for rows where all entries <u>except one</u> are equal.  If matches exist, mate them.<br>",
"		<b>3rd round</b>: Check for rows where all entries <u>except two</u> are equal.  If matches exist, mate them.<br>",
"		<b>4th round</b>: Continue like above, opening up the comparison tolerance.<br>",
"		<b>Finally</b>: If all contents in a row are different, then the row in the old table is considered 'removed' and the new row considered 'added'.",
"",
"		<br><br><b>Step 5 - Generate the report</b> according to the chosen reporting option",
"",
"		<br><br><b>Step 6 - Add statistical summary</b><br>",
"		The statistical summary will be added to the right hand side of the report.  In this case, two additionals columns called <b>Statistics Parameters</b>",
"		and <b>Statistics Values</b> are introduced.<br>",
"		",
"		=== 500, 300",
"		Statistics Parameters							| Statistics Values",
"		Columns added									| 0 or higher",
"		Columns removed									| 0 or higher",
"		Columns rearranged								| 0 or higher",
"		Rows equal										| 0 or higher",
"		Rows added										| 0 or higher",
"		Rows removed									| 0 or higher",
"		Rows rearranged									| 0 or higher",
"		Values equal									| 0 or higher",
"		Values added									| 0 or higher",
"		Values removed									| 0 or higher",
"		Values modified									| 0 or higher",
"		Old table found orphan columns					| No or Yes (Yes if data below blank headers exist)",
"		New table found orphan columns					| No or Yes (Yes if data below blank headers exist)",
"		Old table non-unique orientation identifiers	| No or Yes",
"		New table non-unique orientation identifiers	| No or Yes",
"		==="
 ]
		,
	"See also": "Table Comparison Reports"
   },

 "Table Comparison Reports" :
  {
	"Documentation":		"General Description", // Required value
	"Feature Names":		[ "Table comparison reports" ],
"Description 01:Introduction" : [
"	",
"		Two report types are suported: tabular (generated with all reporting options except 'journal') and journal.",
"		All reports also contain a statistics section with the headers 'Statistics Parameters' and 'Statistics Values'.",
"",
"		<br/><img src=\"Images/Function_table_compare.jpg\" alt=\"Function 'table compare'\"><br/>",
""
 ]
		,
"Description 02:Tabular Reports" : [
"",
"		The report contains the columns (with header names) of the newer table plus one additional column called",
"		'Change Remarks'. This column indicates the changes identfied, typically \"Data modified\", \"Row added\", and \"Row deleted\".<br>",
"",
"		<br<br>",
"",
"		Depending on the reporting option chosen, the report may contain fewer rows and/or columns, aiming not to",
"		show unchanged contents considered not interesting.  Deleted contents are shown in brackets.",
""
 ]
		,
"Description 03:Journals" : [
"		",
"		Journals contain a sequential summary of all changes found.  One row is devoted for every change.  It contains the following columns:",
"",
"		=== 500, 500",
"		Header Name										| Contents",
"		Old Table Row Number							| 1 or higher",
"		New Table Row Number							| 1 or higher",
"		Old Table Column Number							| 0 or higher",
"		New Table Columb Number							| 0 or higher",
"		Orientation Identifier header names				| Corresponding data contents",
"		Header Name										| Header name related to change reported",
"		Old Value										| Old contents",
"		New Value										| New contents",
"		Change Remarks									| Row added, Row deleted, Column deleted, Column added, or blank if just contents have changed.",
"		==="
 ]
		,
"Examples 03:" : [
"	include ( Support Library );",
"",
"	table load( t1, \"Examples/Cities.csv\" );",
"	table keep columns ( t1, {City, Country, Inhabitants, Famous attraction, Moving along } );",
"	table keep selected rows ( t1, [Inhabitants]>=1000000 );",
"",
"	echo(\"Original table:\");",
"	table list ( t1 );",
"",
"	echo(\"Create a modified table:\");",
"	table copy table ( t1, t2 );",
"	table sort rows ( t2, City );",
"	table delete selected rows( t2, [City]==Los Angeles);",
"	table delete columns( t2, Country );",
"	table insert columns( t2, Time Zone, \"\", 3 );",
"	table append( t2, {{ Shanghai, 23000000, \"Jing'an Temple\", \"UTC+8\", Bicycle, Bla }} );",
"		// Last entry 'Bla' lies outside the colums with headers and is considered an orphan.",
"	[t2:City,Paris,Famous attraction] = Moulin Rouge;",
"	[t2:City,Paris,Time Zone] = \"UTC+1\";",
"	[t2:City,New York City,Inhabitants] = 8323340;",
"	table list ( t2 );",
"",
"	echo(\"Compare and create journal as output:\");",
"	table compare( t2, t1, report, City, journal );",
"	table delete columns( report, {Statistics Parameters, Statistics Values} ); // Ignore them for now",
"	table delete blank rows( report );",
"	echo(\"Comparison Report:\");",
"",
"	table rename headers( report, { Old Table Row Number, Old Table Column Number, New Table Row Number,",
"		New Table Column Number }, { OR, OC, NR, NC } ); // Abreviate headers to fit on page",
"",
"	table list ( report );"
 ]
	,
	"Output 03:": "automatic"

   },


"Change Indication Function" :
{
	"Function Names":	[ "(This is a user-defined function you need to create)" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		You may define a change indication function which will be called whenever a ",
"		difference during the comparison run has been found.  Parameters supplied include old and new value as well as location in the new table ",
"		(column name and row number).  The return value will placed into the report table.  ",
"		The function allows further flexibility, e.g. reporting changes differently under different columns differently ",
"		(e.g. column \"delivery date\" could be reported as \"same\", \"earlier\", \"later\").",
"",
"		<br><br>",
"		Depending on the last parameter in __table compare(__), this function can either be called for every value pair compared, or",
"		just for value pairs which are different.",
"",
"		<br><br>",
"		You need to create a __user-defined function__ complying with the parameter structure described below and must return a value of any type.",
"		The returned value will be converted to strings automatically after the function calls.",
"",
"	\"Synopsis\": \"define function( my function, {{ old value, literal }, {new value, literal}, {header name, literal}, {row number, numeral}} ) { [statements} }\"",
""
 ]
	,
	"Call as":			"function",
	"Parameter count":	"4",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Old value",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "Value from the older table" ]
		},
		{ "Number": "2.",
		  "Name": "New value",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "Value from the newer table" ]
		},
		{ "Number": "3.",
		  "Name": "Header name",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "Name of header referring to the table column of the values" ]
		},
		{ "Number": "4.",
		  "Name": "Row number",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "Name of header referring to the table column of the values" ]
		}
	],
	"Return value":
	[
		{ "Name": "Change remark",
		  "Types": [ "valid types" ],
"Description" : [
"			Return the value or text you want to see in the comparison report if the values are different (or equal)."
 ]
		  
		}
	],
"Examples" : [
"	include ( Support Library );",
"",
"	define function( foo, {{ old value, literal }, {new value, literal}, {header name, literal}, {row number, numeral}} )",
"	{",
"		if (numeral(new value[])<>0)",
"		{",
"			 return( select if ( new value[] > old value[], \"Older\", \"Younger\" ) );",
"		}",
"		return( old value[] + \" --> \" + new value[] );",
"	}",
"",
"	table initialize( t1,",
"	      { { Name, Age, Town },",
"	        { Ann,  35,  Boston },      { Bea,  45,  Cambridge },",
"	        { Beat, 46,  Chicago },     { Chuck,55,  New Heaven },",
"			{ Emil, 21,  Albany }} );",
"",
"	table initialize( t2,",
"	      { { Name, Age, Town },",
"	        { Ann,  34,  Boston },      { Bea,  46,  Cambridge },",
"	        { Beat, 46,  Chicago },     { Chuck,55,  New Haven },",
"	        { Dale, 65,  Newport }} );",
"",
"	table compare ( t2, t1, report, Name, differences, foo, true );",
"",
"	table delete columns( report, {Statistics Parameters, Statistics Values} ); // Ignore for now",
"	table delete blank rows( report );",
"	echo(\"Comparison Report:\");",
"	table list ( report );",
""
 ]
	,
	"Output": "automatic"
}

,

"table check" :
{
	"Function Names":	[ "table check" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		This function checks the target table against a rules table which contains values, rules (__comparison expressions__) and optionally more advanced verification",
"		expressions. This function can check for the following:",
"		* Contents in selected columns comply with rules specified (e.g. is equal to, contains , etc. )",
"		* Optionally, the number of rows in the target table is checked (for minimum required, maximum allowed, etc.)",
"",
"		This function requires at least 3 parameters: ",
"		* The names of both tables (target and reference etables), and",
"		* The columns to be checked (target data in target table, checking comparison expressions in the reference table).",
"",
"		In the target table, the following four columns will be added with header names as listed below if they are not yet existing.",
"		If they exist, contents will overwritten, and \"Explanations\" appended.",
"",
"		=== 300, 700, noframe bold_column_1, noheader",
"		Row Result			| Comparison result statement related to particular row.  See __checking tables row results__.",
"		Group Result		| Result related to entire group  See __checking tables group results__.",
"		Explanations		| Details about mismatch. In case multiple mismatches, 	exist, only the first mismatch will be explained",
"		Ref Row				| Identified row number in the reference table where the comparison has been made.",
"		===",
"",
"		The reference table contains rows which are being used to check the contents in the target table.  ",
"		For entries in the target table, 1 or more corresponding rows may be specified in the reference table.  ",
"		As long all conditions in the columns are met in at least one of the rows, then the check result is OK.",
"		",
"		<br><br>",
"",
"		<u>Note</u>: The sequential order of the rows in the target table as well as in the reference table do not matter.  ",
"		Grouped rows do not need to lie in blocks of adjacent rows and may be scattered throughout the entire table.",
"",
"		",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"4 - 7",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of target table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "The table will be checked" ]
		},
		{ "Number": "2.",
		  "Name": "Name of reference table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "The table contains the rules to apply for checking" ]
		},
		{ "Number": "3.",
		  "Name": "Columns with data to be checked (both target and reference tables)",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified",
"			* The header names and column numbers are applicable to both target and reference table.",
"			The columns in the target table containing values to be checked will be checked against the corresponding columns in the ",
"			reference table containing comparison expressions. The columns do not need to be in the same location or order if they ",
"			are referenced by their header names.",
"			<br><br>",
"			In the target table, the columns where the data needs to be checked must be selected.  In the reference table, the checking rules ",
"			(contains __comparison expressions__) are located in the corresponding columns.",
""
 ]
			
		},
		{ "Number": "Opt. 4.",
		  "Name": "Columns with Row Match Identifiers (both target and reference tables)",
		  "Direction": "input",
		  "Types": [ "table columns" ],
		  "Default value": "{} (no columns specified)",
"Description" : [
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified",
"			* The header names and column numbers are applicable to both target and reference table.",
"			* Specify '' (softquoted blank) or {} (empty set) to skip this parameter.",
"			In the reference table, only the rows with the same row match header will be compared instead of the entire table."
 ]
			
		},
		{ "Number": "Opt. 5.",
		  "Name": "Columns with Group Identifiers (in the target table)",
		  "Direction": "input",
		  "Types": [ "table columns" ],
		  "Default value": "{} (no columns specified)",
"Description" : [
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified",
"			* The header names and column numbers are applicable to both target and reference table.",
"			* Specify '' (softquoted blank) or {} (empty set) to skip this parameter.",
""
 ]
			
		},
		{ "Number": "Opt. 6.",
		  "Name": "Columns with Group Match Identifiers (target and reference table)",
		  "Direction": "input",
		  "Types": [ "table columns" ],
		  "Default value": "{} (no columns specified)",
"Description" : [
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified",
"			* The header names and column numbers are applicable to both target and reference table.",
"			* Specify '' (softquoted blank) or {} (empty set) to skip this parameter.",
"			All rows with the same Group Identifiers are allocated to one group.",
"			This parameter actually selects the rows in the reference table to be used for comparison.",
""
 ]
			
		},
		{ "Number": "Opt. 7.",
		  "Name": "Columns with Group Match Identifiers (in the reference table)",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "{} (no columns specified)",
"Description" : [
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At most one header name or column number may be specified",
"			* The header names and column numbers are applicable to both target and reference table.",
"			* Specify '' (softquoted blank) or {} (empty set) to skip this parameter.",
"			The contents below this header contains B4P __expressions __ which must reurn boolean results.",
"			These expressions allow more advanced checking and may reference to all columns in the target table using",
"			__partial table references__.",
""
 ]
			
		},
		{ "Number": "Opt. 8.",
		  "Name": "Column with Comparison Directions (reference table) for checking of within a group",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "{} (no columns specified) - Value 'min 0' applies for all rows",
"Description" : [
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At most one header name or column number may be specified",
"			* The header names and column numbers are applicable to both target and reference table.",
"			* Specify '' (softquoted blank) or {} (empty set) to skip this parameter.",
"",
"			In the reference table, the data below this header may contain the following values:",
"",
"			=== 100, 700, noframe_1stcolbold, noheader",
"			min 0		| This row may be checked 0, 1 or multiple times. This option imposes no restrictions on how many time the comparison is made.  It is the default setting if this parameter is not supplied to this function.",
"			equal 0		| This row must not be checked at all.  Error asserted if this row has been matched.  Useful to check for table entries which are not supposed to exist.",
"			min 1		| This row must be checked at least once or more",
"			equal 1		| This row must be checked precisely once",
"			max 1		| This row may be checked 0 or 1 times",
"			==="
 ]
			
		},
		{   "Number":		"Opt. 9.",
			"Name" :		"Expression to select rows",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
"Description" : [
"				Specify the conditions or rules to select the row.  See __expressions to select rows__.<br>",
"				__Partial table specification__ is supported here to reference table columns easily.  Example: <b>[Score]>=5</b>.<br>",
"				<u>Attention</u>: If you are using comparison operators = and <> (instead of == and !=) which allow more than 1 operand on the righ hand side, then make sure you put the entire expression into parentheses.  Otherwise the operators will hijack subsequent function parameters as part of their operands."
 ]
			
		}
	],
	"Return value":
	[
		{ "Name": "Table is OK",
		  "Types": [ "boolean" ],
		  "Description": "true if no mismatches identified.  Otherwise false."
		}
	],
"Examples" : [
"		include ( Support Library );",
"",
"		table initialize( target, {{ Name, Gender}, { Philippe, male }, { Pascale, female }, { Michele, female }} );",
"		echo(\"Target table:\"); table list ( target );",
"",
"		table initialize( reference, { Gender, male, female }  );",
"		echo(\"Reference table:\"); table list ( reference );",
"",
"		res[] = table check( target, reference, Gender );",
"",
"		echo(\"Target table after checking (result = \", res[], \"):\");",
"		table list ( target );",
"",
"		echo(\"Add a mistake.\");",
"		[target:Name,Philippe,Gender] = \"Male\"; // Upper case deviates",
"",
"		res[] = table check( target, reference, Gender );",
"",
"		echo(\"Target table after checking (result = \", res[], \"):\");",
"		table list ( target );",
"",
"		// See following sub-sections for more sophisticated examples."
 ]
	,
	"Output": "automatic"

},

 "Checking Tables - Row and Group Results" :
  {
	"Documentation":		"General Description", // Required value
	"Feature Names":		[ "checking tables row results", "checking tables group results" ],
"Description 01:Row Result" : [
"		The following values may be written into the column named 'Row Result':",
"		=== 200, 800, bold_column_1",
"		Contents written	| Explanations",
"		OK					| Was able to find (at least) one corresponding row in the reference table. All conditions in that row have been met.",
"		Mismatch			| Was able to find (at least) one corresponding row in the reference table. However, no full match in the(se) row(s).",
"		Not in ref list		| Was not able to find a corresponding row in the reference table.",
"		Too many			| Excessive row: The row has been checked by the same row in the reference table where comparison directions imposed an upper limit: equal 0, max 1, equal 1.",
"		==="
 ]
		,
"Description 02:Group Result" : [
"		The following values may be written into the column named 'Group Result':",
"		=== 200, 800, bold_column_1",
"		Contents written	| Explanations",
"		OK					| All rows in the group are OK",
"		No group found		| No corresponding group has been found in the reference table.  Comparisons have not been possible.",
"		Incomplete			| The group in the target table is incomplete, i.e. rows missing as expected in the reference table.  This error message occurs only with comparisons directions imposing lower limits: e.g. min 1, equal 1.",
"		Not OK				| At least one row inside the group contains a mismatch or is an excessive row",
"		NO OK and incomplete| Conditions for both \"Incomplete\" and \"Not OK\" are met.",
"		==="
 ]
		,
	"See also": "table check"
   },


 "Checking Tables - Examples" :
  {
	"Documentation":		"General Description", // Required value
	"Feature Names":		[ "checking tables examples" ],
"Description 01:table check (...) with 3 Parameters" : [
"",
"		<br/><img src=\"Images/Function_table_check_1.jpg\" alt=\"'table check' with 3 function parameters\"><br/>",
"",
"		",
"		In the example below, the fuction call provides 3 parameters: Target and reference table, and checking for",
"		the columns 'Hcp' and 'NTRP' (Golf handcap and tennis rating).  The table entries are OK in following cases:",
"		* A valid tennis rating is provided, and golf handicap does not matter.",
"		* A valid handicap value is provided, but the player shall nto have any tennis rating (blank)",
"		",
""
 ]
	,
"Examples 01:" : [
"	include ( Support Library );",
"",
"	table load( target, \"Examples/Tennis and Golf Players.csv\" );",
"	table list( target );",
"",
"	table keep columns( target, {Name, Sport, Hcp, NTRP} ); // Look how skilled they are",
"	table initialize( ref,",
"	{",
"		// Hcp = Golf Handicap, NTRP = National Tennis Rating Program",
"		{ Sport,    Hcp,     NTRP 	 	        },",
"		{ Tennis,   '*',	 'Lvl ?.0,Lvl ?.5'	},",
"		{ Golf,     '0..54', ''                 }",
"	} );",
"",
"	table check( target, ref, {Hcp, NTRP} );",
"	table list( target );",
""
 ]
	,
	"Output 01:": "automatic",
"Description 02:table check (...) with 4 Parameters" : [
"",
"		In the previous table, the same checks have been applied to both tennis and golf players, and indicate if the target table contains",
"		sports not listed in the reference table.  This is done by specifying common row match identifiers for both tables.  ",
"		In the discussed example it's the column \"Sport\".",
"",
"		<br/><img src=\"Images/Function_table_check_2.jpg\" alt=\"'table check' with 4 function parameters\"><br/>",
"",
"		In the example below, the fuction call provides 4 parameters: Target and reference table, and checking for",
"		the columns 'Hcp' and 'NTRP' (Golf handcap and tennis rating).  The table entries are OK in following cases:",
"		* If the person favors Golf (column 'Sport' conains 'Golf'), then the handicap will be checked.",
"		* If the person favors Tennis, then the NTRP rating will be checked.",
"		* A valid handicap value is provided, but the player shall nto have any tennis rating (blank)",
"",
"		" ],
"Examples 02:" : [
"	include ( Support Library );",
"",
"	table load( target, \"Examples/Tennis and Golf Players.csv\" );",
"	// table list( target ); // See previous section. It's the same table.",
"",
"	table keep columns( target, {Name, Sport, Hcp, NTRP} ); // Look how skilled they are",
"	table initialize( ref,",
"	{",
"		// Hcp = Golf Handicap, NTRP = National Tennis Rating Program",
"		{ Sport,    Hcp,     NTRP 	 	        },",
"		{ Tennis,   '*',	 'Lvl ?.0,Lvl ?.5'	},",
"		{ Golf,     '0..54', ''                 }",
"	} );",
"",
"	table check( target, ref, {Hcp, NTRP}, Sport );",
"	table list( target );"
 ]
	,
	"Output 02:": "automatic",

"Description 03:table check (...) with 6 Parameters" : [
"",
"		Advanced table checking is possible where different groups can be defined in order to apply different checking rules which can even be independent from each other.",
"",
"		<br/><img src=\"Images/Function_table_check_3.jpg\" alt=\"'table check' with 6 function parameters\"><br/>",
"",
"	Let's check some sophisticated tables: A list of electrical equipment for different locomotives which need to be checked against different contents.",
"	* Locomotives:	AC locomotive, Hybrid locomotive (runs on AC power and Diesel), and DE Loco (Diesel)",
"	* 2 Groups: Different rules applicable to DE-Locos and the remaining locos",
"	*  Every locomotive contains equipment like traction converter, motor, gear, etc.",
"	*  Every equipment has different parameters (e.g.: Qty (numbers of units per locomotive), power, speed, weight).",
"",
"	Because the output file contains more columns than they fit in this screen, click on the following hyperlink to open the output as HTML file<br>",
"	<a href=\"Images/Table Check Reference Output 03.html\" target=\"_blank\">Open output as HTML file in a separate tab</a>",
""
 ]
	,
"Examples 03:" : [
"		include ( Support Library );",
"",
"		table load( products, \"Examples/Table Check Target In.csv\" );",
"		table load( ref,      \"Examples/Table Check Reference In.csv\" );",
"",
"		echo(\"Target table: Locomotives with technical data\");",
"		table list( products );",
"",
"		table check ( products, ref, {Power,Speed,Qty}, Equipment, Vehicle Name, Vehicle Type );",
"		",
"		echo(\"Reference table\");",
"		table list( ref );",
"",
"		table save( products, \"Images/Table Check Reference Output 03.html\", HTML );"
 ]
	,
	"Output 03:": "automatic",

"Description 04:table check (...) with 7 Parameters" : [
"",
"	The	function expects an additional column in the reference table which may contain expressions which return Boolean values.  ",
"	The row is considered OK if true is returned, otherwise it's Mismatch.  Blank rows will be ignored.  ",
"	Exceptions will be asserted if the returned value is not Boolean.  ",
"	Partial table specifications refer directly to the columns in the target table and not the reference table.",
"",
"		<br/><img src=\"Images/Function_table_check_4.jpg\" alt=\"'table check' with 7 function parameters\"><br/>",
"",
"	In the reference table, the column [Comments] is checked if it contains 'Safe', provided this is in relation to",
"	Vehicle Type being \"E-Locos\" and \"Equipment\" being \"Control\".  The resulting table now contains 1 additional message:",
"	The \"Control\" for hybrid locomotives contains no remark such as \"Safe Electronics\" in the column \"Comments\".",
"",
"	Because the output file contains more columns than they fit in this screen, click on the following hyperlink to open the output as HTML file<br>",
"	<a href=\"Images/Table Check Reference Output 04.html\" target=\"_blank\">Open output as HTML file in a separate tab</a>",
""
 ]
	,
"Examples 04:" : [
"		include ( Support Library );",
"",
"		table load( products, \"Examples/Table Check Target In.csv\" );		// Same tables as in previous example.  ",
"		table load( ref,      \"Examples/Table Check Reference In.csv\" );	// They will not be listed here again",
"",
"		table check ( products, ref, {Power,Speed,Qty}, Equipment, Vehicle Name, Vehicle Type, Additional Check );",
"",
"		echo(\"Reference table\");",
"		table list( ref );",
"",
"		table save( products, \"Images/Table Check Reference Output 04.html\", HTML );"
 ]
	,
	"Output 04:": "automatic",


"Description 05:table check (...) with 8 Parameters" : [
"",
"	This last example also considers comparison directions as additional rules.  Before that, \"min 1\" has been the standard rule.",
"",
"		<br/><img src=\"Images/Function_table_check_5.jpg\" alt=\"'table check' with 8 function parameters\"><br/>",
"",
"	Because the output file contains more columns than they fit in this screen, click on the following hyperlink to open the output as HTML file<br>",
"	<a href=\"Images/Table Check Reference Output 05.html\" target=\"_blank\">Open output as HTML file in a separate tab</a>",
""
 ]
	,
"Examples 05:" : [
"		include ( Support Library );",
"",
"		table load( products, \"Examples/Table Check Target In.csv\" );		// Same tables as in previous example.",
"		table load( ref,      \"Examples/Table Check Reference In.csv\" );	// They will not be listed here again",
"",
"		table check ( products, ref, {Power,Speed,Qty}, Equipment, Vehicle Name, Vehicle Type, Additional Check, Quantity Check);",
"",
"		echo(\"Reference table\");",
"		table list( ref );",
"",
"		table save( products, \"Images/Table Check Reference Output 05.html\", HTML );"
 ]
	,
	"Output 05:": "automatic"


}

,

"table check duplicates ..." :
{
	"Function Names":	[ "table check duplicates", "table check duplicates ignore case", "table check duplicates ignore blanks", "table check duplicates ingore both",
						  "table check duplicates selected rows", "table check duplicates ignore case selected rows", "table check duplicates ignore blanks selected rows", "table check duplicates ingore both selected rows"],
	"Documentation":	"Function Description",
"Description" : [
"",
"		These functions checks the table for duplicate entries in the orientation identifier headers. ",
"		Contents other than orientation headers will not be checked. Duplication info will be written into dedicated columns specified in the 3rd and 4th parameters.",
"",
"		The different function names distinguish between:",
"		* <b>... ignore case</b>, e.g. \"Data\" and \"data\" are equivalent",
"		* <b>... ignore blanks</b>, e.g. \"Last name\" and \"Lastname\" are equivalent",
"		* <b>... ignore both</b>, e.g. \"Zip Code\" and \"zipcode\" are equivalent",
"		* The function enging <b>selected rows</b> applies duplication check only on the rows where the row selection expression applies.",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"3-5 (4-6 with ...selected rows)",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of existing table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		},
		{   "Number":		"Opt. 2.",
			"Name" :		"Expression to select rows",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
"Description" : [
"				Applicable to <b>table check duplicates ... selected rows</b> only:<br>",
"",
"				Specify the conditions or rules to select the rows.  See __expressions to select rows__.<br>",
"				__Partial table specification__ is supported here to reference table columns easily.  Example: <b>[Score]>=5</b>.<br>",
"				<u>Attention</u>: If you are using comparison operators = and <> (instead of == and !=) which allow more than 1 operand on the righ hand side, then make sure you put the entire expression into parentheses.  Otherwise the operators will hijack subsequent function parameters as part of their operands."
 ]
			
		},
		{ "Number": "2. / 3.",
		  "Name": "Orientation identifier columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			All rows with common contents in the specified columns will be checked for duplicates. Typical use: Unique identifier in a table to check for duplicates.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* 1 or more column number of header names and column numbers may be specified",
""
 ]
			
		},
		{ "Number": "Opt. 3. / 4.",
		  "Name": "Duplicate identifer column",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "{} (none)",
"Description" : [
"			Name of header to identify the matching duplicates. The first set of duplicates is given 0, further sets with 1, 2, etc.",
"			The duplicate identifier count corresponds with the ascending alphabetic order of the orientation columns and longer the sequential top-down order of the table.",
"			<br><br>",
"",
"		    See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At most one header name or column number may be specified",
"			* The header will be created if it does ot yet exist.",
"			* Specify '' (softquoted blank) or {} (empty set) to skip this parameter.",
""
 ]
			
		},
		{ "Number": "Opt. 4. / 5.",
		  "Name": "Duplicate index column",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "{} (none)",
"Description" : [
"			Number of header to note counting index of duplicates.  The first row among the duplicates get index = 0, the following ones 1, 2, etc.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At most one header name or column number may be specified",
"			* The header will be created if it does ot yet exist.",
"			* Specify '' (softquoted blank) or {} (empty set) to skip this parameter.",
""
 ]
			
		},
		{ "Number": "Opt. 4. / 5.",
		  "Name": "Duplicate count column",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "{} (none)",
"Description" : [
"			Name of header to note number of duplicates identified. If for example 3 duplicates have been identified, then the field in the corresponding rows will all be set to 3.",
"",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At most one header name or column number may be specified",
"			* The header will be created if it does ot yet exist.",
"			* Specify '' (softquoted blank) or {} (empty set) to skip this parameter.",
""
 ]
			
		}
	],
	"Return value":
	[
		{ "Name": "Number of duplications identified",
		  "Types": [ "numeral" ],
"Description" : [
"			0 = All rows are unique according to the specifications provided in the function parameters<br>",
"			>0 = Number of duplications identified<br>",
"			-1 = Error identified."
 ]
		  
		}
	],
"Examples" : [
"	include ( Support Library );",
"",
"	table initialize( names,  // Gender neutral first names",
"		{ { First Name, Last Name, Gender },",
"		  { Pascale,   Baker,       Male   },",
"		  { Philippe,  Tanner,      Female },",
"		  { Philippe,  Tanner,      Male   },",
"		  { Dominique, Miller,      Male   },",
"		  { Gabriel,   Baker,       Female },",
"		  { Nicola,    Nilsson,     Female },",
"		  { Philippe,  Tanner,      Male   },",
"		  { Gabriel,   Baker,       Male   },",
"		  { Nicola,    Nilsson,     Male   } } );",
"",
"",
"	table check duplicates ignore case( names, {Last Name, First Name}, Identifier, Index, Count );",
"	table list ( names );",
""
 ]
	,
	"Output": "automatic"
}

,

"table lookup ..." :
{
	"Function Names":	[ "table lookup", "table lookup ignore case", "table lookup top down", "table lookup top down ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function uses data in specified <b>input columns</b> (2nd function paramameter) in the target table (1st param) ",
"	to search for matching data in the <b>seach columns</b> (5th paam) in the lookup table (4th param).  Once a match has been encountered, then the",
"	corresponding <b>output columns</b> (6th param) in the lookup table will be transferred to the <b>target columns</b> (3rd param) in ",
"	the target table.  The function variant <b>table lookup ignore case</b> is self-explanatory.  In case the lookup table contains multiple",
"	matching entries, the first match will always apply..",
"",
"	<br/><br/><img src=\"Images/Function_table_lookup.jpg\" alt=\"Function 'table lookup'\"><br/><br/>",
"",
"	The lookup function contains powerful comparison algorithms which will index the lookup table and accelerate the lookup performance significantly",
"	if it exceeds a size where the time overhead of creating an internal indexation does pay.  This scheme accelerates the lookup procedure",
"	to a search time ratio versus table size (<i>n</i>)being <b><i>O</i></b> ( log(<i>n</i>)) ).",
"	Looking up a table containing ca 16,000 entries requires 14 comparisons only.  For small tables, indexing will be skipped in order to avoid the",
"	initial overhead to do an indexation and the lookup takes place in a top-down approach starting from row 1.",
"",
"	<br><br>",
"	If a large lookup table is considered, but you know that most items looked up lie in to rows (say: roughly first 30 rows), then you may",
"	experience a performance improvement using the function name <b>table lookup top down ...</b> instead.  The output is the same in both cases.",
"",
"",
"	<br>",
"",
"	This functions described here provide the option to select rows (7th function parameter) and counting the lookup matches in the lookup table ",
"	(8th function parameter).",
"",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"6 - 8",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of target table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "The table referred here is assumed to be the more recent table." ]
		},
		{ "Number": "2.",
		  "Name": "Input columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			Specify 1 or more columns in the input table which contains the information to compare with the search columns in the lookup table.<br>",
"			Example: { Family Name, First Name } when looking up a phone directory table.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At least one header name or column number must be specified",
"			* The number of input columns in the target table must equal to the number of search columns in the lookup table",
""
 ]
			
		},
		{ "Number": "3.",
		  "Name": "Destination columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			Specify columns in the input table where to copy the information retrieved from output columns in the lookup table.",
"			The column header names do not need to be the same the corresponding headers in the lookup table.",
"			Example: { Phone Number, Fax Number } when looking up a phone directory table.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names or column numbers may be specified (0 columns means pick up nothing, in case you need to count the lookups only)",
"			* The number of destination columns in the target table must equal to the numer of output columns in the lookup table",
"			* Missing columns will be created.",
""
 ]
			
		},
		{ "Number": "4.",
		  "Name": "Name of lookup table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "The table referred here is assumed to be the more recent table." ]
		},

		{ "Number": "5.",
		  "Name": "Search columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"",
"			Specify 1 or more columns in the lookup table which contains the information to compare with the corresponding inputs columns in the target table.<br>",
"			Example: { Last Name, Given Name } when looking up a phone directory table.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At least one header name or column number must be specified",
"			* The number of search columns in the loookup table must equal to the number of input columns in the target table",
""
 ]
			
		},
		{ "Number": "6.",
		  "Name": "Output columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			Specify columns in the lookup table for the information to be retrieved and copied to the destination columns in the target table.",
"			The column header names do not need to be the same the corresponding headers in the lookup table.",
"			Example: { Phone Number, Fax Number } when looking up a phone directory table.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names or column numbers may be specified (0 columns means pick up nothing, in case you need to count the lookups only)",
"			* The number of output columns in the lookup table must equal to the numer of destination columns in the target table",
"			* Exception: Specify '#row' to retrieve the row number from the lookup table. <br><u>Note</u>: \"#row\" in double quotation marks (quoted literal)is excluded from this exception and treated as a header name.",
""
 ]
			
		},
		{   "Number":		"Opt. 7.",
			"Name" :		"Expression to select rows",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
		    "Default value": "true (all rows selected)",
"Description" : [
"				This function parameter allows you to select the rows in the target table in order to limit the lookups to those rows only.",
"				<br><br>",
"				Specify the conditions or rules to select the row.  See __expressions to select rows__.<br>",
"				__Partial table specification__ is supported here to reference table columns easily.  Example: <b>[Age]>=21</b>.<br>",
"				<u>Attention</u>: If you are using comparison operators = and <> (instead of == and !=) which allow more than 1 operand on the righ hand side , then make sure you put the entire expression into parentheses.  Otherwise the operators will hijack subsequent function parameters as part of their operands."
 ]
			
		},
		{ "Number": "Opt. 8.",
		  "Name": "Counter column",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "{} (no column selected)",
"Description" : [
"			Specify 1 column in the lookup table which shall be used to count the successful lookup made.  This function is useful in order to",
"			get an idea of the data in the lookup table searched frequently, rarely or not at all.  If the column already contains numbers, then",
"			the existing numbers will be incremented, i.e. no reset to zero.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At most one header name or column number must be specified",
"			* If the column is missing in the lookup table, then it will be created.",
"			",
"			<u>Hint:</u> If you need this function parameter, but not the 7th function parameter, then write <b>true</b> into the 7th parameter."
 ]
			
		}
	],
	"Return value":
	[
		{ "Name": "Number of lookups made",
		  "Types": [ "numeral" ],
"Description" : [
"				Every successful lookup (input columns match with search columns are matching) will count 1."
 ]
				
		}
	],
"Examples" : [
"",
"	include (Support Library);",
"",
"	table load( lookup, \"Examples\\Table Lookup Example 1.csv\" );",
"	table initialize( target, { Town, Florence, Venice, Florence, Edinburgh, New York, Hamburg, Florence, Munich, New York } );",
"",
"	count[] = table lookup( target, Town, { Food or Beverage, Recommended, Row Number },",
"							lookup, City, { Meal or Drink, Recommendation, '#row' }, true, Counter );",
"",
"	echo(\"Lookup table:\");",
"	table list( lookup );",
"",
"	echo(\"Target table after lookup (\", count[], \" items found):\");",
"	table list( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table lookup once", "table lookup fast", "table lookup smart", "table lookup smart once", "table integrate", "table expand" ]
},


"table lookup once ..." :
{
	"Function Names":	[ "table lookup once", "table lookup once ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function works very similarly like __table lookup(__), with the only difference that every item in the lookup table can be be retrieved",
"	only once.  If the same lookup values are applied, then it will look for a 2nd match (and so forth).  Once all matching values are checked",
"	off, then no lookup is made.  The search time ratio versus table size is (<i>n</i>)being <b><i>O</i></b> ( log(<i>n</i>)) ).",
"",
"	<br/><br/><img src=\"Images/Function_table_lookup_once.jpg\" alt=\"Function 'table lookup once'\"><br/><br/>",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"6 - 8 (For parameter description and return values: see __table lookup(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"",
"	include (Support Library);",
"",
"	table load( lookup, \"Examples\\Table Lookup Example 1.csv\" );",
"	table initialize( target, { Town, Florence, Venice, Florence, Edinburgh, New York, Hamburg, Florence, Munich, New York } );",
"",
"	count[] = table lookup once( target, Town, { Food or Beverage, Recommended },",
"								 lookup, City, { Meal or Drink, Recommendation }, true, Counter );",
"",
"	echo(\"Lookup table:\");",
"	table list( lookup );",
"",
"	// Note: Florence is looked up 3 times, but only 2 entries exist.  the 3rd lookup stays blank.",
"",
"	echo(\"Target table after lookup (\", count[], \" items found):\");",
"	table list( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table lookup", "table lookup top down", "table lookup fast", "table lookup smart", "table lookup smart once", "table integrate", "table expand" ]
},

"table lookup fast ..." :
{
	"Function Names":	[ "table lookup fast", "table lookup fast ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function works very similarly like __table lookup top down(__), with the only difference that the row number, where the match has been found,",
"	will be memorized.  Further lookups with the same lookup parameters will find the same matching row.  However, if there is no match, then",
"	the lookup continues with the next row below.  Once it has reached the end of the table, it make a 2nd round to look at the rows above",
"	the memorized row number.  You will see some deviating behavior as illustrated below:",
"	",
"	<br/><br/><img src=\"Images/Function_table_lookup_fast.jpg\" alt=\"Function 'table lookup fast'\"><br/><br/>",
"",
"	This feature provides signficant performance improvements if your target table and your lookup table are already sorted in alphabetic",
"	order.  Example: You have one sorted list (e.g. last name, first name) containing empoloyees of a business.  The 2nd list contains a list",
"	of employees deserving a promotion or pay rise.  Both lists are already sorted by names.  You want to look up for details like mailing addresses",
"	from the 1st list.  In this case, the 1st list is the lookup table and the 2nd list is the target table.  with alphabetic ordering in place,",
"	the lookup procedure will run very swiftly, practially with one single pass in the target table and one single pass in the lookup table.",
"	"
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"6 - 8 (For parameter description and return values: see __table lookup(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"",
"	include (Support Library);",
"",
"	table load( lookup, \"Examples\\Table Lookup Example 1.csv\" );",
"	table initialize( target, { Town, New York, New York, Florence, New York, New York, Munich, New York } );",
"",
"	count[] = table lookup fast( target, Town, { Food or Beverage, Recommended },",
"								 lookup, City, { Meal or Drink, Recommendation }, true, Counter );",
"",
"	echo(\"Lookup table:\");",
"	table list( lookup );",
"",
"	// Note: Querying New York after Florence looks for next match afer Florence and is a beer.",
"",
"	echo(\"Target table after lookup (\", count[], \" items found):\");",
"	table list( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table lookup", "table lookup top down", "table lookup once", "table lookup smart", "table lookup smart once", "table integrate", "table expand" ]
},

"table lookup smart ..." :
{
	"Function Names":	[ "table lookup smart", "table lookup smart ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function works very similarly like __table lookup top down(__), with the only difference that lookup table contains",
"	B4P __comparison expressions__ instead of hard values in the search pattern columns.  This feature provides a lot of flexibility because",
"	you can make a much more flexible description of the look-up table using some rules (e.g. __comparison operators__, __value ranges__,",
"	__value selections__).  A match is given for a particular row if the comparisons made in all search pattern patterns returned 'true'.<br>",
"",
"	Examples (Syntax is same as B4P comparison expressions):",
"	=== 300, 700, noheader, noframe, column_1_bold",
"	Building		| Equals to \"Building\"",
"	=Building		| Equals to \"Building\"",
"	<>Building		| Must not equal to \"Building\"",
"	B*				| Example of __wildcard symbols__: Begins with B",
"	1..10,20		| True if between 1 and 10, or equal to 20.",
"	'3..5'			| Equals to \"3..5\"",
"	&gt;10			| Greater than 10",
"	Dog,*at,Fly		| Commas allow for flexible seletion OK for Dog, Cat, Rat, Bat, Fly, Gnat, ...",
"	===",
"",
"	Examples: You have a product portfolio and provide some technical data in the reference table.  The table can be used to identify a suitable",
"	product based on your specification.  Other example:  Describe a bunch of restaurants with table locations, recommended offerings, party",
"	size (number of seats per table), price range for main course, etc., and you can search for a restaurant by preferences.",
"",
"	<br><br>",
"	The search time ratio versus table size is (<i>n</i>)being <b><i>O</i></b> ( <i>n</i>) ) beacause every search is a top-down search.",
"",
"	<br><br>",
"	<u>Hint</u>: If you create the lookup table, start with the most specific selections.  Further down, open up more (using wildcard symbols).",
"	Consider default information (in casse of no matches in the rows above) in the last row: Put '*' in all search pattern columns and write \"All others\" or \"Not found\" in the output column.  ",
"	with this approach, you will capture all searches.",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"6 - 8 (For parameter description and return values: see __table lookup(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"",
"	include (Support Library);",
"",
"	table load( lookup, \"Examples\\Table Lookup Example 2.csv\" );",
"",
"	table initialize( target,",
"		 { { Preference,  Seats Needed, Location },",
"		   { vegi pizza,   6, inside },",
"		   { pizza tonno,  5, outside },",
"		   { hamburger,    2, inside },",
"		   { beer,         1, bar },",
"		   { fries,        2, \"self-service\" },",
"		   { pasta napoli, 8, inside },",
"		   { steak,       10, inside },",
"		   { steak,        3, outside } } );",
"",
"	count[] = table lookup smart ignore case",
"			  ( target,   {Seats Needed, Preference,Location}, { Place to go, Phone, Row },",
"				lookup,   {Table size,   Offering,  Ambience}, { Restaurant Name, Phone Number, '#row' }, true, Counter );",
"",
"	echo(\"Lookup table:\");",
"	table list( lookup );",
"",
"	// Note: Querying New York after Florence looks for next match afer Florence and is a beer.",
"",
"	echo(\"Target table after lookup (\", count[], \" items found):\");",
"	table list( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table lookup smart once", "table lookup", "table lookup top down", "table lookup once", "table lookup fast", "table integrate", "table expand" ]
},

"table lookup smart once ..." :
{
	"Function Names":	[ "table lookup smart once", "table lookup smart once ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function combines the benefits of __table lookup smart(__) and __table lookup once(__).  Every entry in the look-up table is",
"	referenced only once, with one following exception: <u>The last row is exempted from that look-up-once rule</u>, so you can specify ",
"	a default row to capture all searches which have not been successful in the rows above.",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"6 - 8 (For parameter description and return values: see __table lookup(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"",
"	include (Support Library);",
"",
"	table load( lookup, \"Examples\\Table Lookup Example 2.csv\" );",
"",
"	table initialize( target,",
"		 { { Preference,  Seats Needed, Location },",
"		   { vegi pizza,   6, inside },",
"		   { pizza tonno,  5, outside },",
"		   { hamburger,    2, inside },",
"		   { beer,         1, bar },",
"		   { fries,        2, \"self-service\" },",
"		   { pasta napoli, 8, inside },",
"		   { steak,       10, inside },",
"		   { steak,        3, outside } } );",
"",
"	count[] = table lookup smart once ignore case",
"			  ( target,   {Seats Needed, Preference,Location}, { Place to go, Phone, Row },",
"				lookup,   {Table size,   Offering,  Ambience}, { Restaurant Name, Phone Number, '#row' }, true, Counter );",
"",
"	echo(\"Lookup table:\");",
"	table list( lookup );",
"",
"	// Note: Querying New York after Florence looks for next match afer Florence and is a beer.",
"",
"	echo(\"Target table after lookup (\", count[], \" items found):\");",
"	table list( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table lookup smart once", "table lookup", "table lookup top down", "table lookup once", "table lookup fast", "table integrate", "table expand" ]
}


,

"table integrate ..." :
{
	"Function Names":	[ "table integrate", "table integrate ignore case", "table integrate top down", "table integratetop down ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	These functions work very similarly like __table lookup(__), with the exception that the data retrieved from the lookup table will not",
"	be copied back to the target table, but an operation is performed with the data already existing in the target table with the retrieved data",
"	and then written back.  Example: You look up data for some numbers and want to add them to the already existing values in the target table.",
"",
"	<br/><br/><img src=\"Images/Function_table_integrate.jpg\" alt=\"Function 'table integrate'\"><br/><br/>",
"",
"	This functions described here provide the option to select rows (8th function parameter) and counting the lookup matches in the lookup table",
"	(9th function parameter).  Using only the first 6th parameters in this function call will behave in the same way as __table lookup(__).",
"",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"7 - 9 (For description of 1st-6th parameters and return values: see __table lookup(__)",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "Opt. 7.",
		  "Name": "Operation Identifier",
		  "Direction": "input",
		  "Types": [ "parameter set or literal" ],
		  "Default value": "{overwrite, ...} (overwrite applies to all parameters)",
"Description" : [
"				Specify one of the __table integration operation identifiers__<br>",
"				The number of operation identifiers is less than the number of columns specified in the 3rd (output columns) and 6th parameter (destination columns), ",
"				then the default value 'overwrite' is assumed for the remaining columns.  If this parameter contains more elements than columns retrieved, then the exess ones will be ignored.",
"				* Use a literal to specify one value",
"				* Use parameter set to specify multiple values",
"				* Alternatively use a softquoted literal (using single quotation marks) to specify multiple values, separated by commas",
"				* No values can be provided by using empty set {} or blank softquoted literal ''."
 ]
				
		},
		{   "Number":		"Opt. 8.",
			"Name" :		"Expression to select rows",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
			"Default value": "true (all rows selected)",
"Description" : [
"			Same as 7th function parameter in __table lookup(__).<br>",
"			This function parameter allows you to select the rows in the target table in order to limit the lookups to those rows only.",
"			<br><br>",
"			Specify the conditions or rules to select the row.  See __expressions to select rows__.<br>",
"			__Partial table specification__ is supported here to reference table columns easily.  Example: <b>[Age]>=21</b>.<br>",
"			<u>Attention</u>: If you are using comparison operators = and <> (instead of == and !=) which allow more than 1 operand on the righ hand side , then make sure you put the entire expression into parentheses.  Otherwise the operators will hijack subsequent function parameters as part of their operands."
 ]
			
		},
		{ "Number": "Opt. 9.",
		  "Name": "Counter column",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "{} (no column selected)",
"Description" : [
"			Same as 8th function parameter in __table lookup(__).<br>",
"			Specify 1 column in the lookup table which shall be used to count the successful lookup made.  This function is useful in order to",
"			get an idea of the data in the lookup table searched frequently, rarely or not at all.  If the column already contains numbers, then",
"			the existing numbers will be incremented, i.e. no reset to zero.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At most one header name or column number must be specified",
"			* If the column is missing in the lookup table, then it will be created.",
"",
"			<u>Hint:</u> If you need this function parameter, but not the 8th function parameter, then write <b>true</b> into the 8th parameter."
 ]
			
		}
	],
	"Return value":
	[
		{ "Name": "Number of lookups made",
		  "Types": [ "numeral" ],
"Description" : [
"				Every successful lookup (input columns match with search columns are matching) will count 1."
 ]
				
		}
	],
"Examples" : [
"	include ( Support Library );",
"",
"	table initialize( lookup,",
"	{  {  Names, Sports,      Scores },",
"	   {  Abel,  tennis,      10 },          {  Bea,   squash, 14 },",
"	   {  Chuck, racquetball, 13 },          {  Dan,   tennis, 8 },",
"	   {  Eva,   squash,       9 },          {  Finn,  tennis, 12 },",
"	   {  Gini,  racquetball, 12 },          {  Hugo,  squash, 11 } } );",
"",
"	table initialize( target, {{ Sport, Name, Score 1, Score 2, Score 3, Score 4 },",
"		{ racquetball, \"\", 5, 100, 12  },",
"		{ squash,      \"\", 5, 100, 12  },",
"		{ racquetball, \"\", 5, 300, 10  },",
"		{ tennis,      \"\", 5, 100, 12  } } );",
"",
"	// Picks the 1st match and integrates the results",
"	table integrate( target, Sport,  { Name,  Score 1 .. Score 4 },",
"					 lookup, Sports, { Names, 4:Scores }, { overwrite, add, sub, max, average } );",
"",
"	table list ( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table integrate once", "table integrate fast", "table integrate smart", "table integrate smart once", "table lookup", "table expand" ]
},


"table integrate once ..." :
{
	"Function Names":	[ "table integrate once", "table integrate once ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function combines the lookup strategy from __table lookup once(__) with the data integration features of __table integrate(__).",
"",
"	<br/><br/><img src=\"Images/Function_table_integrate_once.jpg\" alt=\"Function 'table integrate once'\"><br/><br/>",
"",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"7 - 9 (For parameter description and return values: see __table integrate(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"	include ( Support Library );",
"",
"	table initialize( lookup,",
"	{  {  Names, Sports,      Scores },",
"	   {  Abel,  tennis,      10 },          {  Bea,   squash, 14 },",
"	   {  Chuck, racquetball, 13 },          {  Dan,   tennis, 8 },",
"	   {  Eva,   squash,       9 },          {  Finn,  tennis, 12 },",
"	   {  Gini,  racquetball, 12 },          {  Hugo,  squash, 11 } } );",
"",
"	table initialize( target, {{ Sport, Name, Score 1, Score 2, Score 3, Score 4 },",
"		{ racquetball, \"\", 5, 100, 12  },",
"		{ squash,      \"\", 5, 100, 12  },",
"		{ racquetball, \"\", 5, 300, 10  },  // Looks up Gini's score",
"		{ racquetball, \"\", 5, 300, 10  },  // Nothing more to look up, orig values unchanged",
"		{ tennis,      \"\", 5, 100, 12  } } );",
"",
"	// Picks the 1st match and integrates the results",
"	table integrate once( target, Sport,  { Name,  Score 1 .. Score 4 },",
"						  lookup, Sports, { Names, 4:Scores }, { overwrite, add, sub, max, average } );",
"",
"	table list ( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table integrate", "table integrate top down", "table integrate fast", "table integrate smart", "table integrate smart once", "table lookup", "table expand" ]
},


"table integrate fast ..." :
{
	"Function Names":	[ "table integrate fast", "table integrate fast ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function combines the lookup strategy from __table lookup fast(__) with the data integration features of __table integrate(__).",
"",
"	<br/><br/><img src=\"Images/Function_table_integrate_fast.jpg\" alt=\"Function 'table integrate fast'\"><br/><br/>",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"7 - 9 (For parameter description and return values: see __table integrate(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"	include ( Support Library );",
"",
"	table initialize( lookup,",
"	{  {  Names, Sports,      Scores },",
"	   {  Abel,  tennis,      10 },          {  Bea,   squash, 14 },",
"	   {  Chuck, racquetball, 13 },          {  Dan,   tennis, 8 },",
"	   {  Eva,   squash,       9 },          {  Finn,  tennis, 12 },",
"	   {  Gini,  racquetball, 12 },          {  Hugo,  squash, 11 } } );",
"",
"	table initialize( target, {{ Sport, Name, Score 1, Score 2, Score 3, Score 4 },",
"		{ racquetball, \"\", 5, 100, 12  },",
"		{ squash,      \"\", 5, 100, 12  },  // Lookup table: Squash entry is below racquetball",
"		{ racquetball, \"\", 5, 300, 10  },  // Looks up Gini's score",
"		{ racquetball, \"\", 5, 300, 10  },  // And again.",
"		{ tennis,      \"\", 5, 100, 12  } } );",
"",
"	// Picks the 1st match and integrates the results",
"	table integrate fast( target, Sport,  { Name,  Score 1 .. Score 4 },",
"						  lookup, Sports, { Names, 4:Scores }, { overwrite, add, sub, max, average } );",
"",
"	table list ( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table integrate", "table integrate top down", "table integrate once", "table integrate smart", "table integrate smart once", "table lookup", "table expand" ]
},


"table integrate smart ..." :
{
	"Function Names":	[ "table integrate smart", "table lookup integrate ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function combines the lookup strategy from __table lookup smart (__) with the data integration features of __table integrate(__).",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"7 - 9 (For parameter description and return values: see __table integrate(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"	include ( Support Library );",
"",
"	table initialize( lookup,",
"	{  {  Names, Sports,      Scores },",
"	   {  Abel,  't*',        10 },          {  Bea,   's*', 14 },",
"	   {  Chuck, 'r*', 	      13 },          {  Dan,   't*', 8 },",
"	   {  Eva,   '*sh',        9 },          {  Finn,  't*', 12 },",
"	   {  Gini,  '*ball', 	  12 },          {  Hugo,  's*', 11 }, { All others, '*', 0 } } );",
"",
"	table initialize( target, {{ Sport, Name, Score 1, Score 2, Score 3, Score 4 },",
"		{ racquetball, \"\", 5, 100, 12  },",
"		{ squash,      \"\", 5, 100, 12  },  // Lookup table: Squash entry is below racquetball",
"		{ racquetball, \"\", 5, 300, 10  },",
"		{ tennis,      \"\", 5, 100, 12  } } );",
"",
"	// Picks the 1st match and integrates the results",
"	table integrate smart ( target, Sport,  { Name,  Score 1 .. Score 4 },",
"							lookup, Sports, { Names, 4:Scores }, { overwrite, add, sub, max, average } );",
"",
"	table list ( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table integrate smart once", "table integrate", "table integrate top down", "table integrate once", "table integrate fast", "table lookup", "table expand" ]
},


"table integrate smart once ..." :
{
	"Function Names":	[ "table integrate smart once", "table integrate smart once ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function combines the lookup strategy from __table lookup smart once(__) with the data integration features of __table integrate(__).",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"7 - 9 (For parameter description and return values: see __table integrate(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"	include ( Support Library );",
"",
"	table initialize( lookup,",
"	{  {  Names, Sports,      Scores },",
"	   {  Abel,  't*',        10 },          {  Bea,   's*', 14 },",
"	   {  Chuck, 'r*', 	      13 },          {  Dan,   't*', 8 },",
"	   {  Eva,   '*sh',        9 },          {  Finn,  't*', 12 },",
"	   {  Gini,  '*ball', 	  12 },          {  Hugo,  's*', 11 }, { All others, '*', 0 } } );",
"",
"	table initialize( target, {{ Sport, Name, Score 1, Score 2, Score 3, Score 4 },",
"		{ racquetball, \"\", 5, 100, 12  },",
"		{ squash,      \"\", 5, 100, 12  },  // Lookup table: Squash entry is below racquetball",
"		{ racquetball, \"\", 5, 300, 10  },  // Looks up Gini's score",
"		{ racquetball, \"\", 5, 300, 10  },  // Reads bottom row (default)",
"		{ racquetball, \"\", 5, 300, 10  },  // And again.",
"		{ tennis,      \"\", 5, 100, 12  } } );",
"",
"	// Picks the 1st match and integrates the results",
"	table integrate smart once( target, Sport,  { Name,  Score 1 .. Score 4 },",
"								lookup, Sports, { Names, 4:Scores }, { overwrite, add, sub, max, average } );",
"",
"	table list ( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table integrate smart", "table integrate", "table integrate top down", "table integrate once", "table integrate fast", "table lookup", "table expand" ]
}


,

"table expand ..." :
{
	"Function Names":	[ "table expand", "table expand ignore case"],
	"Documentation":	"Function Description",
"Description" : [
"",
"	These functions work very similarly like __table integrate(__). Instead of stopping at the first match in the lookup table, this function",
"	family <u>looks up all entries in the lookup table</u>.  The search procedure through the lookup table will always be top-down.",
"	In case 2 or more matching enties are found in the lookup table, then the following happens:",
"	* The row in the target table will be duplicated in the next row below, where the remaining rows below shift down by 1 row.<br>",
"	* The looked-up information from the output columns will be integrated into the corresponding destination columns using the operation defined by the __table integration operation identifiers__.",
"	* Some operation identifiers make use of special rules for dealing with blank contents in the lookup table.",
"	* In case of no matches, the row stays unchanged, i.e. the row in the target table will not be deleted.",
"",
"	<img src=\"Images/Function_table_expand.jpg\" alt=\"Function 'table expand'\"><br/><br/>",
"",
"	This functions described here provide the option to select rows (8th function parameter) and counting the lookup matches in the lookup table",
"	(9th function parameter). ",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"7 - 9 (For parameter description and return values: see __table integrate(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"",
"	include ( Support Library );",
"",
"	table initialize( nute facts, // Nutritional facts, source: ndb.nal.usda.gov",
"	{  {  Food, Ingredient, Portion  },",
"	   {  potato chips,  fat,            0.34  },",
"	   {  potato chips,  carbohydrates,  0.50  },",
"	   {  potato chips,  sodium,         0.08  },",
"	   {  potato chips,  proteins,       0.07  },",
"	   {  potato chips,  others,           ''  }, // Remaining weight subtracted from above (--> operation identifer 'mul')",
"	   {  broccoli,      water,          0.90  },",
"	   {  broccoli,      proteins,       0.03  },",
"	   {  broccoli,      carbohydrates,  0.06  },",
"	   {  broccoli,      others,           ''  }, // Remaining weight subtracted from above (--> operation identifer 'mul')",
"	   {  spring water,  water,          1.00  } } );",
"",
"	table initialize( target, { { Name, Favorite Food, Weight }, ",
"	   { Rafael, Broccoli,    200 }, { Steve, Parmesan cheese, 100 }, ",
"	   { George, Potato chips, 50 }, { Fred,  Spring water,   1000 } } );",
"",
"",
"	echo(\"Target table before looking up with expanding contents:\");",
"	table list ( target );",
"",
"	table expand ignore case( target, Favorite Food, { Ingredient, Weight }, nute facts, Food, ",
"	              { Ingredient, Portion }, { overwrite, mul} );",
"",
"	// Note that food portions are multiplied with the weight of the food.",
"",
"	echo(\"After expanding (listing ingredients and calculating their weights):\");",
"	table list ( target );",
"	",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table expand fast", "table expand smart", "table expand fast smart", "table integrate", "table lookup" ]
},



"table expand fast ..." :
{
	"Function Names":	[ "table expand fast", "table expand fast ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function works similarly to __table expand(__), with the only exception that the additional roes resulting from multiple lookups",
"	are appended at the bottom of the table rather than inserting them below the original row.  For very large target tables, this approach",
"	saves significant becuase no rows will be shifted repeatedly.  Consider sorting the table, e.g. using __table sort rows(__) afterwards, if needed.",
"",
"	<br/><br/><img src=\"Images/Function_table_expand_fast.jpg\" alt=\"Function 'table expand fast'\"><br/><br/>",
"",
"	<u>Attention</u>: Do not confuse with the functions __table lookup fast(__) and __table integrate fast(__) where the 'fast' in the",
"	function name refers to an optimized searching scheme suitable for pre-sorted tables.",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"7 - 9 (For parameter description and return values: see __table integrate(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"	include ( Support Library );",
"",
"	table initialize( nute facts, // Nutritional facts, source: ndb.nal.usda.gov",
"	{  {  Food, Ingredient, Portion  },",
"	   {  potato chips,  fat,            0.34  },",
"	   {  potato chips,  carbohydrates,  0.50  },",
"	   {  potato chips,  sodium,         0.08  },",
"	   {  potato chips,  proteins,       0.07  },",
"	   {  potato chips,  others,           ''  }, // Remaining weight subtracted from above (--> operation identifer 'mul')",
"	   {  broccoli,      water,          0.90  },",
"	   {  broccoli,      proteins,       0.03  },",
"	   {  broccoli,      carbohydrates,  0.06  },",
"	   {  broccoli,      others,           ''  }, // Remaining weight subtracted from above (--> operation identifer 'mul')",
"	   {  spring water,  water,          1.00  } } );",
"",
"	table initialize( target, { { Name, Favorite Food, Weight },",
"	   { Rafael, Broccoli,    200 }, { Steve, Parmesan cheese, 100 },",
"	   { George, Potato chips, 50 }, { Fred,  Spring water,   1000 } } );",
"",
"",
"	echo(\"Target table before looking up with expanding contents:\");",
"	table list ( target );",
"",
"	table expand fast ignore case( target, Favorite Food, { Ingredient, Weight }, nute facts, Food, { Ingredient, Portion }, { overwrite, mul} );",
"",
"	// Note that food portions are multiplied with the weight of the food.",
"	// Additional rows are put to the end of the table.",
"",
"	echo(\"After expanding (listing ingredients and calculating their weights):\");",
"	table list ( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table expand", "table expand smart", "table expand fast smart", "table integrate", "table lookup" ]
},


"table expand smart ..." :
{
	"Function Names":	[ "table expand smart", "table expand smart ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function combines the lookup strategy from __table lookup smart (__) with the data integration features of __table expand(__).",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"7 - 9 (For parameter description and return values: see __table expand(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"",
"		include (Support Library);",
"",
"	table load( lookup, \"Examples\\Table Lookup Example 2.csv\" );",
"	table delete remaining rows ( lookup, -2 ); // Remove last 2 rows (the mom's place and 'not found' row)",
"",
"	table initialize( target, { Seating, inside, balcony, outside, bar } );",
"",
"	count[] = table expand smart ignore case",
"			 ( target,   Seating, {Place to go, Table size}, lookup, Ambience, {Restaurant Name, Table size} );",
"",
"	echo(\"Lookup table:\");",
"	table list( lookup );",
"",
"	echo(\"Target table after lookup (\", count[], \" items found):\");",
"	table list( target );",
"",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table expand", "table expand fast", "table expand fast smart", "table integrate", "table lookup" ]
},




"table expand fast smart ..." :
{
	"Function Names":	[ "table expand fast smart", "table expand fast smart ignore case" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	This function combines the lookup strategy from __table lookup smart (__) with the data integration features of __table expand(__).",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"7 - 9 (For parameter description and return values: see __table expand(__) )",
	"Restrictions":		"Indirect parameter passing is disabled",
"Examples" : [
"	include (Support Library);",
"",
"	table load( lookup, \"Examples\\Table Lookup Example 2.csv\" );",
"	table delete remaining rows ( lookup, -2 ); // Remove last 2 rows (the mom's place and 'not found' row)",
"",
"	table initialize( target, { Seating, inside, balcony, outside, bar } );",
"",
"	count[] = table expand fast smart ignore case",
"			 ( target,   Seating, {Place to go, Table size}, lookup, Ambience, {Restaurant Name, Table size} );",
"",
"	echo(\"Lookup table:\");",
"	table list( lookup );",
"",
"	// Additional rows have been added to the end of the table.",
"",
"	echo(\"Target table after lookup (\", count[], \" items found):\");",
"	table list( target );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table expand", "table expand fast", "table expand fast smart", "table integrate", "table lookup" ]
},


 "Table Integration Operation Identifiers" :
  {
	"Documentation":		"General Description", // Required value
	"Feature Names":		[ "Table integration operation identifiers" ],
"Description 01:Introduction" : [
"",
"		The following table lists all valid operation identifiers which can be used in the 7th function parameter of the",
"		__table integrate(__) and __table expand(__)  function families.",
"",
"		<br><br>",
"",
"		The operation identifier rules how the value or data retrieved from the output column in the lookup table shall be combined",
"		with the existing data in the destination column in the target table.",
"",
"		=== 300, 700, bold_column_1",
"		Operation identifier		| Description",
"		overwrite					| Output data overwrites destination data (same behavior like in the __table lookup(__) function family)",
"		none						| Output data does not overwrite destination data (it may be meaningless, but useful if the operation identifiers provided in variables)",
"		overwrite if blank			| Output data overwrites destination data if existing destination data is blank",
"		overwrite except blank		| Output data overwrites destination data if output data is not blank",
"		append						| Output data is appended to the destination data",
"		append with space			| Output data is appended to the destination data with one space character ' ' inbetween",
"		min abc						| Chooses the first one by alphabetic sorting order.  Note: blank literal has highest order.",
"		min abc ignore blanks		| Chooses the first one by alphabetic sorting order.  Blank values are not preferenced.",
"		max abc						| Chooses the last one by alphabetic sorting order.",
"		min							| Chooses the smaller (numeric) value. Blanks and non-numeric data are treated as 0",
"		min ignore blanks			| Chooses the smaller (numeric) value. Non-numeric data are treated as 0. Blanks are not chosen.",
"		min ignore zero				| Chooses the smaller (numeric) value. Both non-numeric data and 0 are not chosen.",
"		max							| Chooses the bigger (numeric) value.  Blanks and non-numerals are treated as 0",
"		max ignore blanks			| Chooses the bigger (numeric) value.  Non-numeric data are treated as 0. Blanks are not chosen.",
"		max ignore zero				| Chooses the bigger (numeric) value. Both non-numeric data and 0 are not chosen.",
"		add							| Output value is added to destination value.  Blanks and non-numerals are treated as 0",
"		sub							| Output value is subtracted from destination value.  Blanks and non-numerals are treated as 0",
"		mul							| Destination value is multiplicated with the output value. Non-numeral entries are treated as 0.<br><u>Attention</u>: See <sup>1</sup>.",
"		mul ignore blanks			| Destination value is multiplicated with the output value if not blank.  Non-numeric ata are treated as 0.",
"		mul ignore zero				| Destination value is multiplicated with the output value as long the output data is neither blank nor 0.",
"		div							| Destination value is divided by the output value. Result will be 0 if entry is 0 or a non-numeral.<br><u>Attention</u>: See <sup>1</sup>.",
"		inc							| Destination value is incremented by specified value in lookup table.<br>In the next entry, this next higher entry is used for further increase.  Negative values decrease accordingly. <br><u>Attention</u>: See <sup>2</sup>.",
"		dec							| Destination value is decremented by specified value in lookup table.<br>In the next entry, this next higher entry is used for further increase.  Negative values increase accordingly.   <br><u>Attention</u>: See <sup>2</sup>.",
"		average						| Calculates the average of both destination and lookup table value.  Blanks and non-numerals are treated as 0, resulting in dividing the other value by 2.",
"		index						| Inserts the index into destination value, i.e. the current count of inserted rows.  The index starts with 0.  For example, if 3 matches are found in the lookup table, then the index for the 3 rows (2 of them are new) will be 0, 1 and 2.  The related value from the lookup table is ignored here, but you must specify one in order to match the column count.",
"		===",
"",
"		<sup>1</sup> Applicable to  __table expand(__) function family: The identifiers <b>mul</b> and <b>div</b> apply a special algorithm:",
"		The residual value, which is the value in the destination table before the call, is subtracted by the the calculated (i.e. multiplied resp. divided) values",
"		in the previous matches.  Very useful if the lookup table contains a few items with percentages (values 0..1) related to ingredients and the target table",
"		contains the total weight of the food.",
"",
"		<sup>2</sup> Applicable to  __table expand(__) function family: The identifiers <b>inc</b> and <b>dec</b> apply a special algorithm:",
"		Blank entries in look-up table retrieves the residual value (original value in target table added (for <b>inc</b>) or subtracted (for <b>dec</b>) by all previous calculations belonging together).",
"",
""
 ]
		,
	"See also": ["table integrate", "table expand" ]
   }

,

"table transpose" :
{
	"Function Names":	[ "table transpose" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		This functions rarranges table contents from horizontal orientation to vertical orientatio.  All prior row headers will move to the 1st column. ",
"		On the other hand, all data in the 1st column become headers.",
"		<u>Attention:</u> Configuration settings applied wtih __table configure(__) prior to this call will be discarded because the transposed table",
"		is actually a new table.",
""
 ]
	,
	"Call as":			"procedure",
	"Parameter count":	"1-2",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of existing  table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description":
			[ "If only the 1st function parameter is provided, then this table will be transposed.  If another table is named in the 2nd function parameter, then this table remains unchanged." ]
		},
		{ "Number": "Opt. 2.",
		  "Name": "Name of new table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		}
	],
"Examples" : [
"	include ( Support Library );",
"",
"	table initialize( t,",
"		 { { Food,     color,          taste,     best with },",
"		   { Fries,    golden yellow,  salty,     hamburger },",
"		   { Pizza,    colorful,       tasteful },",
"		   { Chianti,  rubin red,      bitter,    pasta, worth enjoying },",
"		   { Tirami sù,crème and brown,sweet } } );",
"",
"	table transpose ( t );",
"	table list ( t );"
 ]
	,
	"Output": "automatic"
}

,

"table serialize ..." :
{
	"Function Names":	[ "table serialize", "table serialize all", "table serialize ignore zero" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		This is a pivot function which moves horizontally spread data (typically looking like schedules across timelines, or other tables with horizontally spread categories)",
"		to a sequential listing with one affected data item per row.",
"		<br><br>",
"",
"		<b>table serialize all</b> will do a full serialization of the table, including all blank fields",
"		<b>table serialize</b> only serialize non-blank fields in order to avoid generating unnecessary rows.",
"		<b>serialize ignore zero</b> will also skip serializing fiels representing zero.  Values such as 0, -0, ., 0.0, .00 are also considered 0, but '0 EUR' is not (text inside).",
"",
"		<br/><img src=\"Images/Function_table_serialize.jpg\" alt=\"Function 'table serialize'\"><br/>",
"",
"		<u>Hint</u>:The opposite action of <b>table serialize</b> is to use __table spread(__) to spread the data horizontally",
"		and then apply __table consolidate(__) to reduce the nubmer of rows to the minimum necessary.",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"5-6",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of existing  table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		},
		{ "Number": "2.",
		  "Name": "Identifier columns to repeat",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"",
"			Specifies all columns which data shall be replicated downwards for all corresponding data being serialized.",
"			This is useful for identifiers and descriptions related to the serialized values so meanings are given to every row.",
"			It is not recommended to include columns containing numbers which need to be added up (or used in a similar way) at a later time because the serialization would affect the final result.  ",
"			Even if you want an easily readable table (e.g. describe once, keep following rows blank), then do not include this header.",
"",
"			<br><br>",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified"
 ]
			
		},
		{ "Number": "3.",
		  "Name": "Column for sequence names",
		  "Direction": "input",
		  "Types": [ "table column" ],
"Description" : [
"			Assign a meaningful sequence name.  Naming examples:",
"			* <b>Months</b> for horizontal headers containing Jan, Feb, Mar, ... Dec",
"			* <b>Years</b> for horizontal headers containing year numbers",
"			* <b>Countries</b> for a set of countries listed horizontally",
""
 ]
			
		},
		{ "Number": "4.",
		  "Name": "Sequence names",
		  "Direction": "input",
		  "Types": [ "parameter set containing literals" ],
"Description" : [
"			These values will be applied as data entries under the column which header name is specified in the 2nd parameter. Examples:",
"			* { Jan, Feb, March, April } for 'Months'",
"			* { '2018', '2019', '2020', '2021' } for 'Years' (Quotation marks required because literals are expected)",
"			* { AT, BE, CH, DE, ES, FR, GB, HU, IT, JP } for 'Countries'",
""
 ]
			
		},
		{ "Number": "5.",
		  "Name": "Category names",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			Categories related to the data in the original table",
"			Examples",
"			* Orders",
"			* Revenues",
"			* Gross Margin",
"",
"			<br><br>",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* At leaset one header name may be specified",
"			* Column numbers are not allowed",
"			* If the columns are not yet existing, then they will be created"
 ]
			
		},
		{ "Number": "Opt 6.",
		  "Name": "Original header template",
		  "Direction": "input",
		  "Types": [ "literal" ],
"Description" : [
"",
"			This literal depicts the first example how the original header looks like where it must contain the word \"[Sequence]\" and (optionally if only 1 category",
"			name provided, otherwise mandatory), the word \"[Category]\".  \"Sequence\" and \"Category\" are case sensitive.",
"",
"			<br>The following table shows a few template examples and examples of the corresponding headers expected in the table",
"			=== 100, 300, 400",
"			Sequence Name		| Original header template	| Example of a valid header in the original table",
"			Years				| \"[Category]/[Sequence]\"	| \"Orders/2018\"",
"			Quarters			| \"[Sequence] [Category]\"	| \"Q1 Orders\"",
"			Countries			| \"[Category] in [Sequence]\"| \"Orders in AT\"",
"			(1 category name)	| \"Year [Sequence]			| \"Year 2018\"",
"			===",
"",
"			The function will actually look for these headers and expects that each of them sequence names and Category names will be mentioned at least once.",
"			Sufficient example for quarters / 3 Category names:",
"			* Q1 Orders, Q2 Revenues, Q3 Earnings, Q4 Orders",
"			Not sufficient example:",
"			* Q1 Orders, Q2 Revenues, Q3 Revenues, Q4 Orders	(\"Earnings\" missing)",
"			* Q1 Orders, Q2 Revenues, Q3 Revenues, Q1 Earnings	(\"Q4\" missing)",
"",
"			The 6th parameter is not required if only 1 category name is specified.  In this case, the function looks for column names equaling to the sequence names, ",
"			e.g. \"2018\", \"2019\", \"Q1\", \"Q2\", \"AT\", \"BE\" related to the various examples above.",
""
 ]
			
		}
	],
	"Return value":
	[
		{ "Name": "Column count",
		  "Types": [ "numeral" ],
"Description" : [
"			Number of columns found with header names comprised of values in 4th, 5th and 6th parameters."
 ]
		  
		}
	],
	"Exceptions": [ "0 Sequence and/ or 0 category names provided", "No columns with data to spread have been found." ],
"Examples" : [
"	include ( Support Library );",
"",
"	// An easy one",
"",
"	table initialize( bils, // Swedisch for 'cars', aka 'automo-bils'",
"		{ { Product, \"2020-Q1\"..\"2020-Q4\" },",
"		  { Sedans,   24, 34, 44, 14 },",
"		  { Pickpus,  11, 21, 31, 21 },",
"		  { Cabrios,  '',  5, 10, '' },",
"		  { SUVs,     35, 25, 45, 55 } } );",
"",
"	echo(\"Car sales in sequential order (including blanks here):\");",
"	table serialize all( bils, Product, Quarter, { \"2020-Q1\"..\"2020-Q4\" }, Cars sold );",
"	table list ( bils );",
"",
"	// Serializing order intake (OI) and revenues (Rev) over quarters",
"",
"	table initialize( kpi, // Key Performance Indicators",
"		{ { Region,   \"OI 2018\", \"Rev 2018\", \"OI 2019\", \"Rev 2019\", \"OI 2020\", \"Rev 2020\"  },",
"		  { Americas, 1000,      950,        1100,      1050,       1200,      1150        },",
"		  { Europe,    800,      700,         900,       950,       1100,      1050        },",
"		  { Antarctica, '',       '',           0,         0,         20,        15        } } );",
"",
"	echo;",
"",
"	echo(\"Key performance indicator values (excluding blanks and zero:\");",
"	table serialize ignore zero( kpi, Region, Year, { \"2018\"..\"2020\" },",
"								 { OI, Rev }, \"[Category] [Sequence]\" );",
"	table list ( kpi );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table spread", "table spread given headers" ]

}

,

"table spread ..." :
{
	"Function Names":	[ "table spread", "table spread accumulating" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		This is a pivot function which spreads vertically listed data horizontally across multiple columns using a key derived from",
"		information in other columns, (e.g. sequence info like dates, quarters, years, states, countries and/or category info like revenues,earnings, etc.).",
"		The columns created in horizontal order will be arranged in case sensitive alphabetic order.  Values to be spreaded must not necessarily be numeric,",
"		unless you use <b>table spread accumulating</b>.",
"",
"		<br/><img src=\"Images/Function_table_spread.jpg\" alt=\"Function 'table spread'\"><br/>",
"",
"		This function creates new headers only if they are not yet existing.  If headers are existing, then data below will be preserved unless overwritten by values being spread.",
"		The function <b>table spread accumulating</b> will add the new values to the existing value instead of overwriting it. You can do multiple calls of this function on the same table.",
"",
"		<u>Hint</u>:To finalize a pivot from vertical horizontal, call __table consolidate(__) as the net function to reduce the number of rows",
"		to the minimum necessary.",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"3-7",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of existing  table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		},
		{ "Number": "2.",
		  "Name": "Column with values to spread",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			   Specify the column which contains the values or any other conetns you want to spread horizontally.",
"",
"			<br><br>",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Exactly 1 header name and column numbers may be specified"
 ]
			
		},
		{   "Number":		"3.",
			"Name" :		"Spreading key expression",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
"Description" : [
"				In order to spread the data horizontally across columns to be created, you need to specify how the new column headers names shall be",
"				formulated for the horizontal data.  This parameter is an expression which is calculated for every table row and should preferably",
"				generate an output value of literal type (string).  Other types, such as numerals (e.g. years) will be converted to strings automatically.",
"				During the horizontal spreading, the applicable value (column specified in 2nd parameter) will be copied to the new columns with these",
"				header names.",
"",
"				<br><br>",
"				__Partial table specification__ is supported here to reference table columns easily.",
"				<br><br>",
"",
"				Simple example if spreading by one column, e.g. year: Specify <b>[year]</b>.<br>",
"				Multiple columns, e.g. quarter and year in separate columns: Specify <b>Q+[Quarter]+' '+literal([year])</b> for values like 'Q1 2022'.<br>",
"				To spread values by 1st letter, consider , which picks the 1st leter and capitalizes it (+ operator on strings).",
"",
"				* For a simple distribution across years, quarters, countries, states, and the actual data is available one column, then specify the corresponding column name in brackets, e.g. <b>[Year]</b>.",
"				* For a distribution of values across years where the full data is available, something like <b>year([Delivery Dates])</b> is proposed.",
"				* For an alphabetical distribution, use something like <br>+[Name]{0}</br> which picks the 1st letter and capitalizes it (unary '+' operator at the beginning).",
"				* For a combination of multiple columns, e.g. category and sequence info, combine two columns, e.g. <b>[KPI]+'/'+literal([Year])</b> or <b>[Quarter]+\"-\"+literal([Yeaer])</b>.",
"",
"				<u>Attention</u>: New columns will only be created if they are not yet existing.  This scheme allows running multiple calls of <b>table spread</b> and <b>table spread accumulating</b>",
"				with different data.  This function does not delete any existing values.  Values already existing will only be overwritten or added up.",
""
 ]
			
		},
		{   "Number":		"Opt. 4.",
			"Name" :		"Pivot limitation expression",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
			"Default value" :	"true",
"Description" : [
"				This is an expression which will be calculated for every table rowo and shall return a boolean value.",
"				If the value is true, then the value will be spread into a dedicated column.  This feature lets you limit the creation of too many columns.",
"				All values excluded will appear in the column for all other values, if defined using the 6th function parameter.",
"",
"				Specify the conditions or rules to select the rows.  See __expressions to select rows__.<br>",
"				__Partial table specification__ is supported here to reference table columns easily.  Example: <b>[Year]>=5</b>.<br>",
"				<u>Attention</u>: If you are using comparison operators = and <> (instead of == and !=) which allow more than 1 operand on the righ hand side , then make sure you put the entire expression into parentheses.  Otherwise the operators will hijack subsequent function parameters as part of their operands.",
"",
"				<br><br>",
"",
"				Examples: Your data contains a column containing years, but want to limit the spreading to 5 years, then specify something like",
"				<b>([Year]=2020..2024)</b>.  Note the required parentheses as explained above so the expression does not hijack following function parameters.",
""
 ]
			
		},
		{   "Number":		"Opt. 5.",
			"Name" :		"Maximum number of columns to add",
			"Direction" :	"code",
			"Types" :		[ "numeral" ] ,
			"Default value" : "(not limited)" ,
"Description" : [
"				You can limit the number of columns to be created in order to prevent overruns.  In this case, only the first n columns (in alphabetic order) will be shown."
 ]
			
		},
		{ "Number": "Opt. 6.",
		  "Name": "Column for all other values",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "(not applicable)",
"Description" : [
"		    This column will be used to allocate all values which cannot be allocate into the specified columns due to limitations",
"			defined by the 4th and/or 5th function parameters.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Max. 1 header name may be specified.",
""
 ]
			
		},
		{ "Number": "Opt. 7.",
		  "Name": "Destination column",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "to the end of the table",
"Description" : [
"			Specify a header name or column number where to insert the new columns added. The specified column and further ones to the right will shift to the",
"			right accordingly.<br>",
"			Negative number are supported for indexing from right to left, however -1 refers to the end of the table, -2 to left of last column, etc.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Only 1 header name or column number may be specified.",
""
 ]
			
		}
	],
	"Return value":
	[
		{ "Name": "Column count",
		  "Types": [ "numeral" ],
"Description" : [
"			Number of new columns added.  The 'column for other values' specified in the 6th function parameter is not included in the counting."
 ]
		  
		}
	],
"Examples" : [
"",
"	include ( Support Library );",
"",
"	// Remember the motor vehicles serialized ...",
"	table initialize( bils, // Swedisch for 'cars', aka 'automo-bils'",
"		{ { Product, \"2020-Q1\"..\"2020-Q4\" },",
"		  { Sedans,   24, 34, 44, 14 },  { Pickpus,  11, 21, 31, 21 },",
"		  { Cabrios,  '',  5, 10, '' },  { SUVs,     35, 25, 45, 55 } } );",
"",
"	echo(\"Car sales in sequential order (including blanks here):\");",
"	table serialize all( bils, Product, Quarter, { \"2020-Q1\"..\"2020-Q4\" }, Cars sold );",
"	table list ( bils );",
"",
"	echo(\"Let's shift to reverse gear: Spread the data\");",
"",
"	count[] = table spread( bils, Cars sold, [Quarter] );",
"	table list ( bils );",
"",
"	echo(\"Number of new columns created. \", count[]);",
"	echo(\"And do a final consolidation and you get the original list.\");",
"	table consolidate( bils, Product, { Quarter, Cars sold, \"2020-Q1\"..\"2020-Q4\" }, { 2:delete, overwrite if blank }  );",
"	table list ( bils );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table spread given headers", "table consolidate", "table serialize" ]

}

,

"table spread given headers ..." :
{
	"Function Names":	[ "table spread given headers", "table spread given headers accumulating" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		These two functions are very similar to __table spread(__) and __table spread accumulating(__) with the only difference that",
"		you specify the column header names directly which shall be included, and not more.  This approach provides full control of the new",
"		columns created, regardless of the data being spread horizontally.",
"",
"		<br/><img src=\"Images/Function_table_spread.jpg\" alt=\"Function 'table spread'\"><br/>",
"",
"		If the destination colums are already existing, then the will be used.  Otherwise, the new columns will be created.",
"		The function <b>table spread accumulating</b> will add the new values to the existing value instead of overwriting it. ",
"		You can do multiple calls of this function on the same table.",
"",
"		<u>Hint</u>:To finalize a pivot from vertical horizontal, call __table consolidate(__) as the net function to reduce the number of rows",
"		to the minimum necessary.",
""
 ]
	,
	"Call as":			"procedure",
	"Parameter count":	"4-6",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of existing  table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		},
		{ "Number": "2.",
		  "Name": "Column with values to spread",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			   Specify the column which contains the values or any other conetns you want to spread horizontally.",
"",
"			<br><br>",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Exactly 1 header name and column numbers may be specified"
 ]
			
		},
		{   "Number":		"3.",
			"Name" :		"Spreading key expression",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
"Description" : [
"				Details: See __table spread(__), 3rd function parameter for details.<br>",
"				During the spreading process, the calculated keys will be compared with the columns specified in the 4th parameter.",
"				Only if the columns exist, then the horiontal spreading takes place.",
""
 ]
			
		},
		{ "Number": "4.",
		  "Name": "Destination Columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			   Specify all column header names for the data being spread.  If it is years, then specify something like  { '2020' .. '2025' },",
"			   noting that all values must be literal.  No additional columns will be created automatically if certain values do not fit into the",
"			   given header names.  However, they can be spread into the 'column for all other values' specified in the 5th function parameter.",
"",
"			<br><br>",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names may be specified",
"			* Column numbers are not allowed",
"			* Header names need to be unique"
 ]
			
		},
		{ "Number": "Opt. 5.",
		  "Name": "Column for all other values",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "(not applicable)",
"Description" : [
"			This column will be used to allocate all values which cannot be allocate into the specified columns listed in the 4th function parameter.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Max. 1 header name may be specified.",
""
 ]
			
		},
		{ "Number": "Opt. 6.",
		  "Name": "Destination column",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "to the end of the table",
"Description" : [
"			Specify a header name or column number where to insert the new columns added. The specified column and further ones to the right will shift to the",
"			right accordingly.<br>",
"			Negative number are supported for indexing from right to left, however -1 refers to the end of the table, -2 to left of last column, etc.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Only 1 header name or column number may be specified.",
""
 ]
			
		}
	],
	"Return value":
	[
		{ "Name": "Column count",
		  "Types": [ "numeral" ],
"Description" : [
"			Number of new columns added.  The 'column for other values' specified in the 6th function parameter is not included in the counting."
 ]
		  
		}
	],
"Examples" : [
"",
"	include ( Support Library );",
"",
"	// Remember the motor vehicles serialized ...",
"	table initialize( bils, // Swedisch for 'cars', aka 'automo-bils'",
"		{ { Product, \"2020-Q1\"..\"2020-Q4\" },",
"		  { Sedans,   24, 34, 44, 14 },  { Pickpus,  11, 21, 31, 21 },",
"		  { Cabrios,  '',  5, 10, '' },  { SUVs,     35, 25, 45, 55 } } );",
"",
"	echo(\"Car sales in sequential order (including blanks here):\");",
"	table serialize all( bils, Product, Quarter, { \"2020-Q1\"..\"2020-Q4\" }, Cars sold );",
"	table list ( bils );",
"",
"	echo(\"Let's add more values: One reservation, to demonstrate ...accumulating\");",
"	table insert columns( bils, Cars reserved );",
"	[bils:Product,Sedans,Cars reserved] = 20;",
"",
"	// Specify 2 columns, and the 'Others' column to put all remaining data.",
"	cols[] = {\"2020-Q1\", \"2020-Q2\"};",
"	table spread given headers ( bils, Cars sold, [Quarter], cols[], Others );",
"	table spread given headers accumulating( bils, Cars reserved, [Quarter], cols[], Others );",
"",
"	echo(\"Note the 44 sedans in 2020-Q1 (24 sold, 20 reserved)\");",
"	table list ( bils );",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table spread", "table consolidate", "table serialize" ]
}

,

"table consolidate ..." :
{
	"Function Names":	[ "table consolidate", "table consolidate selected rows" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		This function condenses the the table by reducing the rows and performing operations in order to aggregate the data so they continue to be",
"		plausible for further use.  More precisely, one or more identifier columns need to be defined. The aim is to reduce the number of rows with",
"		the same data in the identifier columns to 1.  The 2nd and further rows with the same identifier data will be merged into the first applciable",
"		row.  Specific consolidation actions will be applied on selected columns (e.g. overwriting, adding up, etc.).",
"",
"		<br/><img src=\"Images/Function_table_consolidate.jpg\" alt=\"Function 'table consolidate'\"><br/>",
"",
"		<u>Hint</u>:A vertical-to-horizontal pivot operation can be finalized by using this funciton after calling __table spread(__) or __table spread given headers(__).",
""
 ]
	,
	"Call as":			"procedure",
	"Parameter count":	"1-6",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of existing  table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		},
		{   "Number":		"2.",
			"Name" :		"Expression to select rows",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
"Description" : [
"",
"				Applicable to function <b>table consolidate selected rows</b> only.",
"",
"				Specify the conditions or rules to select the rows.  See __expressions to select rows__.<br>",
"				__Partial table specification__ is supported here to reference table columns easily.  Example: <b>[Score]>=5</b>.<br>",
"				<u>Attention</u>: If you are using comparison operators = and <> (instead of == and !=) which allow more than 1 operand on the righ hand side , then make sure you put the entire expression into parentheses.  Otherwise the operators will hijack subsequent function parameters as part of their operands."
 ]
			
		},
		{ "Number": "Opt. 2. / 3.",
		  "Name": "Identifier Columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
		  "Default value": "{} (no columns selected)",
"Description" : [
"			   The identifier columns guide the consolidation process.  All rows containing the same data in the identifier columns will be reduced to 1 row accordingly.",
"			   If the 1st function parameter refers to no columns, then all rows in the entire table will be consolidated to 1 row.  If <b>table consolidate</b> is called",
"			   with onyly 1 function parameter, then the consolidation process takes place without consolidating the remaining columns (i.e. consolidation action 'none' is assumed).",
"",
"			<br><br>",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified",
"			* Specifying no headers (i.e. softquoted empty string '' or empty set {}) will consolidate all table rows to 1 single row.",
"			* Do not repeat the same column",
""
 ]
			
		},
		{ "Number": "Opt. 3. / 4.",
		  "Name": "Columns to consolidate",
		  "Direction": "input",
		  "Types": [ "table columns" ],
		  "Default value": "{} (no columns consolidated)",
"Description" : [
"				Specify the columns where the data shall be consolidated automatically.  The remaining columns in the table will not be consolidated, i.e. the consolidation",
"				action is assumed 'none'.  In this case, the contents in the first row will be preserved.<br>",
"				<u>Note</u>: If all columns (except the identifier columns) need to be consolidated, then specify an asterisk in a softquoted literal using single quotation marks, e.g. '*'. (\"*\" looks for header name = \"*\").",
"",
"			<br><br>",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified",
"			* Specifying no headers (i.e. softquoted empty string '' or empty set {}) will exclude all columns from active consolidation.  Contents in top row will apply.",
"			* Do not specify any columns already referenced in the previous function parameter (identifier columns)",
"			* Do not repeat the same column",
"			* Softquoted literal '*' in single quotation marks: Consolidate all columns in the table except the identifier columns",
""
 ]
			
		},
		{ "Number": "Opt. 4. / 5.",
		  "Name": "Consolidation actions",
		  "Direction": "input",
		  "Types": [ "parameter set or literal" ],
		  "Default value": "'overwrite' if preious parameter is specified, otherwise 'none'",
"Description" : [
"",
"				Specify one of the various __consolidation actions__.<br>",
"				The operation is applied with the data from the next lower applicable row and the destination data in the first applicable row (= target row).",
"				For example, <b>add</b> adds the value from the lower row to the target row.",
"",
"				The number of operation identifiers is less than the number of columns specified in the 3rd (output columns) and 6th parameter (destination columns),",
"				then the default value 'overwrite' is assumed for the remaining columns.  If this parameter contains more elements than columns retrieved, then the exess ones will be ignored.",
"				* Use a literal to specify one value",
"				* Use parameter set to specify multiple values",
"				* Alternatively use a softquoted literal (using single quotation marks) to specify multiple values, separated by commas",
"				* No values can be provided by using empty set {} or blank softquoted literal ''.  'none' is assumed for all consolidating columns here.",
"				* Ideally, the number of consolidation actions shall equal to the number of columns to consolidate (previous function parameter).",
"				* If fewer consolidation actions are listed than number of columns to consolidate, then the last action will apply to all remaining columns.",
"				* If more consolidation actions are listed, then the excessive numbr of actions will be ignored."
 ]
				
		},
		{ "Number": "Opt. 5. / 6.",
		  "Name": "Separator string",
		  "Direction": "input",
		  "Types": [ "parameter set or literal" ],
		  "Default value": "'' (empty string)",
"Description" : [
"				For some __consolidation actions__ (e.g. <b>append, append once</b>), a separator string can be specified to separate the consolidated strings",
"				in a more visible way, for example using a comma or new line."
 ]
				
		}
	],
	"Return value":
	[
		{ "Name": "Number of rows removed",
		  "Types": [ "numeral" ],
"Description" : [
"			>=0 = Number of rows removed<br>",
"			-1 = Error identified."
 ]
		  
		}
	],
"Examples" : [
"",
"	include( Support Library );",
"",
"	table initialize( t,",
"	{ { Highest Score, Name,      Location, Game 1, Game 2, Remarks, Count },",
"	  { 210,           Taylor,    Rome,     32,     20                      },",
"	  { 190,           Tailor,    Prague,   41,     13,     Exceptional win },",
"	  { 190,           Snyder,    Berne,    41,     12,                     },",
"	  { 200,           Tailor,    Miami,    51,     10,     great job       },",
"	  { 230,           Taylor,    Jakarta,  14,     21                      },",
"	  { 230,           Taylor,    Boston,   15,     22                      },",
"	  { 190,           Tailor,    Oslo,     41,     13      great job       } } );",
"",
"",
"	table copy table( t, u );",
"",
"	// '*' in 3rd function parameter selects all columns except 'Name'.",
"	// In this case, the 6 consolidation actions apply to the 6 columns from left to right.",
"",
"	c[] = table consolidate              ( t, Name,'*', {max, append, sum, average, append once, count}, \", \" );",
"	echo(\"All rows consolidated (\", c[], \" rows removed):\");",
"	table list ( t );",
"",
"	c[] = table consolidate selected rows( u, [Name]==Taylor, Name,'*', {max, append, sum, average, append once, count}, \", \" );",
"	echo(\"Only Taylor's rows consolidated (\", c[], \" rows removed):\");",
"	table list ( u );",
"",
""
 ]
	,
	"Output": "automatic",
	"See also": [ "table spread", "table spread given headers", "table serialize" ]
}

,

"table merge ..." :
{
	"Function Names":	[ "table merge", "table merge extend columns", "table merge intersect columns", "table merge subtract columns", "table merge exclusive columns" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		The functions described here merge the contents of the source table into the destination table.  Identifier columns can be defined for both tables in order to",
"		identify the overlapping table rows (e.g. same first and last names).",
"",
"		<br><br>",
"",
"		For the merging process, the principle of <i>union set</i> is applied.  All rows in the source tables which do not share the same identifier data as in the",
"		destination table will be added to the end of the table.  This does also apply  if no identifier columns are specified (e.g. 3rd function parameter not used or {} or '' provided).",
"		In the other case, where rows in the source table share the same identifier data as in the destination table and are considered <i>overlapping</i>, ",
"		the data from the source table row will be consolidated into the destination table row using available __consolidation actions__.  The consolidation actions",
"		work similarly like in the function __table consolidate(__) where exactly two rows are consolidated into one row.",
"",
"		<br><br>",
"",
"		In case the two tables contain multiple equal values in the identifier columns (for example if only the first name has been referred), then every affecting row in the",
"		source table will be consolidated in one row in the destination table and then checked off as 'done'.  If another row in the source table has the same value, then",
"		the next match further below in the destination table will be seeked.  If the source table contains more repeated contents in the identifier column than in the ",
"		destination table, then the remaining rows will be added to the end of the destination table.",
"",
"		<br><br>",
"		The following functions use different approaches to combine the data columns:",
"		=== 250, 750, noframe_1stcolbold, noheader",
"		table merge						| No further columns are added to the destination table",
"		table merge extend columns		| Columns in the source table but not found in the destinationtable will be added to the target table (union set)",
"		table merge intersect columns	| Removes columns from the destination table if they do not exist in the source table (intersection)",
"		table merge subtract columns	| removes columns from destination table if they are found in the source table, but keeps the identifier columns.",
"		table merge exclusive columns	| Removes columns found in both source and destination table, but keeps the identifier columns (exclusive OR).",
"		===",
"",
"		<br/><img src=\"Images/Function_table_merge.jpg\" alt=\"Function 'table merge'\"><br/><br/>",
"",
"		Typical applications:",
"		* Gathering information collected from different sources",
"		* Merger and acquisitions",
"",
"",
"		<u>Note</u>: If the destination table does not yet exist, or if the table is entirely empty (i.e. no header inside), then the data in the source table will be copied into the destination table.",
"",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"2-6 (Max 3 for function names 'table merge subtract/exclusive columns')",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of existing source table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		},
		{ "Number": "2.",
		  "Name": "Name of destionation table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		},
		{ "Number": "Opt. 3.",
		  "Name": "Identifier Columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
		  "Default value": "{} (no columns specified)",
"Description" : [
"			   The identifier columns are used to match common data in both tables.",
"			   Rows with same identifier data in both source and destination tables",
"			   are considered as <i>overlapping</i> rows.  The data in overlapping rows will be consolidated.",
"			   If no columns are specified, then no commonalities are assumed and no rows will be consolidated.",
"",
"			<br><br>",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified.  This applies to both tables (i.e. they must have same header names)",
"			* Use column numbers only if the data in both tables are physically located in the same columns.",
"			* Specifying no headers (i.e. softquoted empty string '' or empty set {}) will consolidate all table rows to 1 single row.",
"			* Do not repeat the same column",
""
 ]
			
		},
		{ "Number": "4.",
		  "Name": "Columns to consolidate",
		  "Direction": "input",
		  "Types": [ "table columns" ],
		  "Default value": "{} (no columns consolidated)",
"Description" : [
"				Specify the columns where the data from the source table shall be consolidated into the destination table.  ",
"				The remaining columns in the table will not be consolidated, i.e. the values in the destination table remain unchanged.",
"				<u>Note</u>: If all columns (except the identifier columns) need to be consolidated, then specify an asterisk in a softquoted literal using single quotation marks, e.g. '*'. (\"*\" looks for header name = \"*\").<br>",
"				<u>Note</u>: This parameter is not applicable for function names ending wiht <b>... subtract columns</b> and <b>... exclusive columns columns</b>.",
"",
"			<br><br>",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified.  This applies to both tables (i.e. they must have same header names)",
"			* Specifying no headers (i.e. softquoted empty string '' or empty set {}) will exclude all columns from active consolidation.  Contents in top row will apply.",
"			* Do not specify any columns already referenced in the previous function parameter (identifier columns)",
"			* Do not repeat the same column",
"			* Softquoted literal '*' in single quotation marks: Consolidate all columns in the table except the identifier columns",
""
 ]
			
		},
		{ "Number": "Opt. 5.",
		  "Name": "Consolidation actions",
		  "Direction": "input",
		  "Types": [ "parameter set or literal" ],
		  "Default value": "'overwrite' if preious parameter is specified, otherwise 'none'",
"Description" : [
"",
"				Specify one of the various __consolidation actions__.<br>",
"				The operation is applied with the data from the next lower applicable row and the destination data in the first applicable row (= target row).",
"				For example, <b>add</b> adds the value from the lower row to the target row.<br>",
"				<u>Note</u>: This parameter is not applicable for function names ending wiht <b>... subtract columns</b> and <b>... exclusive columns columns</b>.",
"",
"",
"				The number of operation identifiers is less than the number of columns specified in the 3rd (output columns) and 6th parameter (destination columns),",
"				then the default value 'overwrite' is assumed for the remaining columns.  If this parameter contains more elements than columns retrieved, then the exess ones will be ignored.",
"				* Use a literal to specify one value",
"				* Use parameter set to specify multiple values",
"				* Alternatively use a softquoted literal (using single quotation marks) to specify multiple values, separated by commas",
"				* No values can be provided by using empty set {} or blank softquoted literal ''.  'none' is assumed for all consolidating columns here.",
"				* Ideally, the number of consolidation actions shall equal to the number of columns to consolidate (previous function parameter).",
"				* If fewer consolidation actions are listed than number of columns to consolidate, then the last action will apply to all remaining columns.",
"				* If more consolidation actions are listed, then the excessive numbr of actions will be ignored.",
"				* If '*' (consolidate all columns) is specified in the 4th parameter, the the consolidation actions apply to the table columns from left to right, <u>skipping</u> the identifier columns and columns to be removed if using <b>table merge intersect columns</b>. "
 ]
				
		},
		{ "Number": "Opt. 6.",
		  "Name": "Separator string",
		  "Direction": "input",
		  "Types": [ "parameter set or literal" ],
		  "Default value": "'' (empty string)",
"Description" : [
"				For some __consolidation actions__ (e.g. <b>append, append once</b>), a separator string can be specified to separate the consolidated strings",
"				in a more visible way, for example using a comma or new line.<br>",
"				<u>Note</u>: This parameter is not applicable for function names ending wiht <b>... subtract columns</b> and <b>... exclusive columns columns</b>."
 ]
				
		}
	],
	"Return value":
	[
		{ "Name": "Number of rows removed by combining the tables and consolidating the overlapping rows",
		  "Types": [ "numeral" ],
"Description" : [
"			>=0 = Number of rows removed<br>",
"			-1 = Error identified."
 ]
		  
		}
	],
	"Details 01:Program Examples with 'table merge ...'": "",
"Examples 01:Merging tables into one without identifier columns specified" : [
"		include( Support Library );",
"",
"		echo(\"Loading farms in Hillboro and Hillville\");",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		echo(\"Farms in Hillboro:\");",
"		table list( hb );",
"",
"		echo(\"Farms in Hillville:\");",
"		table list( hv );",
"",
"		count[] = table merge( hv, hb );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 01:Output: Zero rows consolidated": "automatic",

"Examples 02:Declare 'Farmer' as unique identifier" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table merge( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 02:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Examples 03:Merge data in smart way and add 2 columns from source table:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table merge extend columns( hv, hb, Farmer, '*', { must match, append, 5:sum, append }, \", \" ); ",
"		// '*' corresponds to {Organic, Place, Wheat, Oat, Sheeps, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 03:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 04:Merge data in smart way and keep intersected columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table merge intersect columns( hv, hb, Farmer, '*', { must match, append, 3:sum, append }, \", \" );",
"		// '*' corresponds to {Organic, Place, Wheat, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 04:Output: 3 farmers with land in both towns have been consolidated.": "automatic",



"Examples 05:Merge data in smart way and subtract the columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table merge subtract columns( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 05:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 06:Merge data in smart way and show all columns except comomon ones:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table merge exclusive columns( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 06:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Details 07:Tables with multiple non-unique identifiers being merged:" : [
"		In case you plan to merge two tables with a one or a selection of column identifiers which cannot guarantee uniqueness, ",
"		e.g. a list of names identified by first name only, then this function will match first name pairs first, ",
"		then the next ones below, and so forth.  As a result, every row is considered only once.  Long story short:",
"		Every row in the destination table will be consolidated only once.",
"		The following code example demonstrates this:"
 ]
		,
"Examples 07:One Jill and tow Micheles will be consolidated:" : [
"		include( Support Library );",
"",
"		table load( h1, \"Examples/Table Merge Examples Hobbies 1.csv\");",
"		table load( h2, \"Examples/Table Merge Examples Hobbies 2.csv\");",
"",
"		echo(\"Hoobies 1:\");      table list( h1 );",
"		echo(\"Hoobies 2:\");      table list( h2 );",
"",
"		count[] = table merge( h2, h1, Name, '*', append, ', ' );",
"",
"		echo(\"Combined list of hobbies (\", count[], \" rows consolidated):\");",
"		table list( h1 );"
 ]
		,

	"Output 07:The outcome": "automatic",

	"See also": [ "table overlay", "table intersect", "table subtract", "table exclude", "table consolidate" ]
}

,

"table overlay/subtract ..." :
{
	"Function Names":	[ "table overlay", "table overlay extend columns", "table overlay intersect columns", "table overlay columns", "table overlay exclusive columns" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		The functions described here overlay the contents of the source table into the destination table.  Identifier columns can be defined for both tables in order to",
"		identify the overlapping table rows (e.g. same first and last names).",
"",
"		<br><br>",
"",
"		For the merging process, the principle of <i>union set</i> is applied.  Different from the __table merge(__) function family, all rows in the source tables which do not",
"		share the same identifier data as in the destination table will <u>not be added</u> to the end of the table.  This does also apply if no identifier columns ",
"		are specified (e.g. 3rd function parameter not used or {} or '' provided).",
"		In the other case, where rows in the source table share the same identifier data as in the destination table and are considered <i>overlapping</i>,",
"		the data from the source table row will be consolidated into the destination table row using available __consolidation actions__.  The consolidation actions",
"		work similarly like in the function __table consolidate(__) where exactly two rows are consolidated into one row.",
"",
"		<br><br>",
"",
"		In case the two tables contain multiple equal values in the identifier columns (for example if only the first name has been referred), then every affecting row in the",
"		source table will be consolidated in one row in the destination table and then checked off as 'done'.  If another row in the source table has the same value, then",
"		the next match further below in the destination table will be seeked.  If the source table contains more repeated contents in the identifier column than in the",
"		destination table, then the remaining rows will be added to the end of the destination table.",
"",
"		<br><br>",
"		The following functions use different approaches to combine the data columns:",
"		=== 250, 750, noframe_1stcolbold, noheader",
"		table overlay						| No further columns are added to the destination table",
"		table overlay extend columns		| Columns in the source table but not found in the destinationtable will be added to the target table (union set)",
"		table overlay intersect columns		| Removes columns from the destination table if they do not exist in the source table (intersection)",
"		table subtract columns				| removes columns from destination table if they are found in the source table, but keeps the identifier columns.<br><u>Note</u>: The function name does not contain the word <b>overlay</b> because it is meaningless here.",
"		table overlay exclusive columns		| Removes columns found in both source and destination table, but keeps the identifier columns (exclusive OR).",
"		===",
"",
"		<br/><img src=\"Images/Function_table_overlay.jpg\" alt=\"Function 'table overlay'\"><br/><br/>",
"",
"		<u>Note</u>: If the destination table does not yet exist, or if the table is entirely empty (i.e. no header inside), then the data in the source table will be copied into the destination table.",
"",
"		Typical applications:",
"		* Enriching tables with additional information from other sources",
"		* Keeping key performance figures (KPI's) in tables up-to-date",
"",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"2-6 (Max 3 for function names 'table overlay exclusive columns' and 'table subtract columns'). <br>See __table merge(__) for parameter and return value description",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Details 01:Program Examples with 'table overlay ...'": "",
"Examples 01:Merging tables into one without identifier columns specified" : [
"		include( Support Library );",
"",
"		echo(\"Loading farms in Hillboro and Hillville\");",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		echo(\"Farms in Hillboro:\");",
"		table list( hb );",
"",
"		echo(\"Farms in Hillville:\");",
"		table list( hv );",
"",
"		count[] = table overlay( hv, hb );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 01:Output: Zero rows consolidated": "automatic",

"Examples 02:Declare 'Farmer' as unique identifier" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table overlay( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 02:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Examples 03:Merge data in smart way and add 2 columns from source table:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table overlay extend columns( hv, hb, Farmer, '*', { must match, append, 5:sum, append }, \", \" );",
"		// '*' corresponds to {Organic, Place, Wheat, Oat, Sheeps, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 03:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 04:Merge data in smart way and keep intersected columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table overlay intersect columns( hv, hb, Farmer, '*', { must match, append, 3:sum, append }, \", \" );",
"		// '*' corresponds to {Organic, Place, Wheat, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 04:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Examples 05:Merge data in smart way and subtract the columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table subtract columns( hv, hb, Farmer ); // Note: 'overlay' is not part of function name.",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 05:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 06:Merge data in smart way and show all columns except comomon ones:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table overlay exclusive columns( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 06:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Details 07:Tables with multiple non-unique identifiers being merged:" : [
"		In case you plan to merge two tables with a one or a selection of column identifiers which cannot guarantee uniqueness,",
"		e.g. a list of names identified by first name only, then this function will match first name pairs first,",
"		then the next ones below, and so forth.  As a result, every row is considered only once.  Long story short:",
"		Every row in the destination table will be consolidated only once.",
"		The following code example demonstrates this:"
 ]
		,
"Examples 07:One Jill and tow Micheles will be consolidated:" : [
"		include( Support Library );",
"",
"		table load( h1, \"Examples/Table Merge Examples Hobbies 1.csv\");",
"		table load( h2, \"Examples/Table Merge Examples Hobbies 2.csv\");",
"",
"		echo(\"Hoobies 1:\");      table list( h1 );",
"		echo(\"Hoobies 2:\");      table list( h2 );",
"",
"		count[] = table overlay( h2, h1, Name, '*', append, ', ' );",
"",
"		echo(\"Combined list of hobbies (\", count[], \" rows consolidated):\");",
"		table list( h1 );"
 ]
		,

	"Output 07:The outcome": "automatic",

	"See also": [ "table merge", "table intersect", "table subtract", "table exclude", "table consolidate" ]
}

,

"table intersect ..." :
{
	"Function Names":	[ "table intersect", "table intersect extend columns", "table intersect intersect columns", "table intersect columns", "table intersect exclusive columns" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		The functions described here intersect the contents of the source table into the destination table.  Identifier columns can be defined for both tables in order to",
"		identify the overlapping table rows (e.g. same first and last names).",
"",
"		<br><br>",
"",
"		For the merging process, the principle of <i>intersection</i> is applied.  After the function call, the destination table will only contain those rows which",
"		share the same data in the identifier columns in both source and destination tables, where the data in the rows from the source table has been consolidated into",
"		the corresponding rows in the destination table using available __consolidation actions__.  The consolidation actions",
"		work similarly like in the function __table consolidate(__) where exactly two rows are consolidated into one row.",
"",
"		<br><br>",
"",
"		In case the two tables contain multiple equal values in the identifier columns (for example if only the first name has been referred), then every affecting row in the",
"		source table will be consolidated in one row in the destination table and then checked off as 'done'.  If another row in the source table has the same value, then",
"		the next match further below in the destination table will be seeked.  If the source table contains more repeated contents in the identifier column than in the",
"		destination table, then the remaining rows will be added to the end of the destination table.",
"",
"		<br><br>",
"		The following functions use different approaches to combine the data columns:",
"		=== 250, 750, noframe_1stcolbold, noheader",
"		table intersect						| No further columns are added to the destination table",
"		table intersect extend columns		| Columns in the source table but not found in the destinationtable will be added to the target table (union set)",
"		table intersect intersect columns	| Removes columns from the destination table if they do not exist in the source table (intersection)",
"		table intersect subtract columns	| removes columns from destination table if they are found in the source table, but keeps the identifier columns.",
"		table intersect exclusive columns	| Removes columns found in both source and destination table, but keeps the identifier columns (exclusive OR).",
"		===",
"",
"		<br/><img src=\"Images/Function_table_intersect.jpg\" alt=\"Function 'table intersect'\"><br/><br/>",
"",
"		<u>Note</u>: If the destination table does not yet exist, or if the table is entirely empty (i.e. no header inside), then the data in the source table will be copied into the destination table.",
"",
"		Typical applications:",
"		* Finding commonalities in mulitple tables",
"		* Helful to identify the degree of standardization of items (e.g. re-use of components listed in bills of materials)",
"",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"2-6 (Max 3 for function names 'table intersect subtract/exclusive columns').  <br>See __table merge(__) for parameter and return value description",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Details 01:Program Examples with 'table intersect ...'": "",
"Examples 01:Merging tables into one without identifier columns specified" : [
"		include( Support Library );",
"",
"		echo(\"Loading farms in Hillboro and Hillville\");",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		echo(\"Farms in Hillboro:\");",
"		table list( hb );",
"",
"		echo(\"Farms in Hillville:\");",
"		table list( hv );",
"",
"		count[] = table intersect( hv, hb );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 01:Output: Table will be empty because no identifier column is specified, so every column is unique": "automatic",

"Examples 02:Declare 'Farmer' as unique identifier" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table intersect( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 02:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Examples 03:Merge data in smart way and add 2 columns from source table:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table intersect extend columns( hv, hb, Farmer, '*', { must match, append, 5:sum, append }, \", \" );",
"		// '*' corresponds to {Organic, Place, Wheat, Oat, Sheeps, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 03:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 04:Merge data in smart way and keep intersected columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table intersect intersect columns( hv, hb, Farmer, '*', { must match, append, 3:sum, append }, \", \" );",
"		// '*' corresponds to {Organic, Place, Wheat, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 04:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Examples 05:Merge data in smart way and subtract the columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table intersect subtract columns( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 05:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 06:Merge data in smart way and show all columns except comomon ones:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table intersect exclusive columns( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 06:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Details 07:Tables with multiple non-unique identifiers being merged:" : [
"		In case you plan to merge two tables with a one or a selection of column identifiers which cannot guarantee uniqueness,",
"		e.g. a list of names identified by first name only, then this function will match first name pairs first,",
"		then the next ones below, and so forth.  As a result, every row is considered only once.  Long story short:",
"		Every row in the destination table will be consolidated only once.",
"		The following code example demonstrates this:"
 ]
		,
"Examples 07:One Jill and tow Micheles will be consolidated:" : [
"		include( Support Library );",
"",
"		table load( h1, \"Examples/Table Merge Examples Hobbies 1.csv\");",
"		table load( h2, \"Examples/Table Merge Examples Hobbies 2.csv\");",
"",
"		echo(\"Hoobies 1:\");      table list( h1 );",
"		echo(\"Hoobies 2:\");      table list( h2 );",
"",
"		count[] = table intersect( h2, h1, Name, '*', append, ', ' );",
"",
"		echo(\"Combined list of hobbies (\", count[], \" rows consolidated):\");",
"		table list( h1 );"
 ]
		,

	"Output 07:The outcome": "automatic",

	"See also": [ "table merge", "table overlay", "table subtract", "table exclude", "table consolidate" ]
}

,

"table subtract ..." :
{
	"Function Names":	[ "table subtract", "table subtract extend columns", "table subtract subtract columns", "table subtract columns", "table subtract exclusive columns" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		The functions described here subtract the contents of the source table from the destination table.  Identifier columns can be defined for both tables in order to",
"		identify the overlapping table rows (e.g. same first and last names).",
"",
"		<br><br>",
"",
"		For all rows which share the same information in the identifier columns in both source and target tables, the correponding row in the destination table will be",
"		deleted.  The destination table remains unchanged if there are no rows with common identifer data or if no identifer columns have been specified so every row is",
"		considered unique.  The principle of data consolidation does not apply for these functions and this explains the that tehse functions take max. 3 parameters, ",
"		excluding the remaining parameters otherwise needed for data consolidation.",
"",
"		<br><br>",
"",
"		In case the two tables contain multiple equal values in the identifier columns (for example if only the first name has been referred), then every affecting row in the",
"		source table will be consolidated in one row in the destination table and then checked off as 'done'.  If another row in the source table has the same value, then",
"		the next match further below in the destination table will be seeked.  If the source table contains more repeated contents in the identifier column than in the",
"		destination table, then the remaining rows will be added to the end of the destination table.",
"",
"		<br><br>",
"		The following functions use different approaches to combine the data columns:",
"		=== 250, 750, noframe_1stcolbold, noheader",
"		table subtract						| No further columns are added to the destination table",
"		table subtract extend columns		| Columns in the source table but not found in the destinationtable will be added to the target table (union set)",
"		table subtract intersect columns	| Removes columns from the destination table if they do not exist in the source table (intersection)",
"		table subtract subtract columns		| removes columns from destination table if they are found in the source table, but keeps the identifier columns.",
"		table subtract exclusive columns	| Removes columns found in both source and destination table, but keeps the identifier columns (exclusive OR).",
"		===",
"",
"		<br/><img src=\"Images/Function_table_subtract.jpg\" alt=\"Function 'table subtract'\"><br/><br/>",
"",
"		<u>Note</u>: In contrast to other functions like __table merge(__), the destination table must exist with header information inside.<br>",
"",
"		Typical applications:",
"		* Eliminating duplications",
"",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"2-3 (Note: Max 3 parameters for this function family, not 6).<br>See __table merge(__) for parameter and return value description",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Details 01:Program Examples with 'table subtract ...'": "",
"Examples 01:Merging tables into one without identifier columns specified" : [
"		include( Support Library );",
"",
"		echo(\"Loading farms in Hillboro and Hillville\");",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		echo(\"Farms in Hillboro:\");",
"		table list( hb );",
"",
"		echo(\"Farms in Hillville:\");",
"		table list( hv );",
"",
"		count[] = table subtract( hv, hb );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 01:Output: Table will be empty because no identifier column is specified, so every column is unique": "automatic",

"Examples 02:Declare 'Farmer' as unique identifier" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table subtract( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 02:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Examples 03:Merge data in smart way and add 2 columns from source table:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table subtract extend columns( hv, hb, Farmer );",
"		// '*' corresponds to {Organic, Place, Wheat, Oat, Sheeps, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 03:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 04:Merge data in smart way and keep subtracted columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table subtract intersect columns( hv, hb, Farmer );",
"		// '*' corresponds to {Organic, Place, Wheat, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 04:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Examples 05:Merge data in smart way and subtract the columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table subtract subtract columns( hv, hb, Farmer ); ",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 05:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 06:Merge data in smart way and show all columns except comomon ones:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table subtract exclusive columns( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 06:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Details 07:Tables with multiple non-unique identifiers being merged:" : [
"		In case you plan to merge two tables with a one or a selection of column identifiers which cannot guarantee uniqueness,",
"		e.g. a list of names identified by first name only, then this function will match first name pairs first,",
"		then the next ones below, and so forth.  As a result, every row is considered only once.  Long story short:",
"		Every row in the destination table will be consolidated only once.",
"		The following code example demonstrates this:"
 ]
		,
"Examples 07:One Jill and tow Micheles will be consolidated:" : [
"		include( Support Library );",
"",
"		table load( h1, \"Examples/Table Merge Examples Hobbies 1.csv\");",
"		table load( h2, \"Examples/Table Merge Examples Hobbies 2.csv\");",
"",
"		echo(\"Hoobies 1:\");      table list( h1 );",
"		echo(\"Hoobies 2:\");      table list( h2 );",
"",
"		count[] = table subtract( h2, h1, Name );",
"",
"		echo(\"Combined list of hobbies (\", count[], \" rows consolidated):\");",
"		table list( h1 );"
 ]
		,

	"Output 07:The outcome": "automatic",

	"See also": [ "table merge", "table overlay", "table intersect", "table exclude", "table consolidate" ]
}

,

"table exclude ..." :
{
	"Function Names":	[ "table exclude", "table exclude extend columns", "table exclude exclude columns", "table exclude columns", "table exclude exclusive columns" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		In the destination table, the functions described here will remove all rows which share the same contents in the identifier columns and include the rows from the",
"		source table whic do also not share the same identifier columns.  Briefly said, the principle of <i>exclusive or</i> or <i>disjoint union</i> is applied on the rows.",
"		If if no identifier columns have been specified, then all rows are considered unique and will be integrated into the target table.",
"",
"		<br><br>",
"	",
"		The principle of data consolidation does not apply for these functions and this explains the that tehse functions take max. 3 parameters,",
"		excluding the remaining parameters otherwise needed for data consolidation.",
"",
"		<br><br>",
"",
"		In case the two tables contain multiple equal values in the identifier columns (for example if only the first name has been referred), then every affecting row in the",
"		source table will be consolidated in one row in the destination table and then checked off as 'done'.  If another row in the source table has the same value, then",
"		the next match further below in the destination table will be seeked.  If the source table contains more repeated contents in the identifier column than in the",
"		destination table, then the remaining rows will be added to the end of the destination table.",
"",
"		<br><br>",
"		The following functions use different approaches to combine the data columns:",
"		=== 250, 750, noframe_1stcolbold, noheader",
"		table exclude						| No further columns are added to the destination table",
"		table exclude extend columns		| Columns in the source table but not found in the destinationtable will be added to the target table (union set)",
"		table exclude intersect columns	| Removes columns from the destination table if they do not exist in the source table (intersection)",
"		table exclude subtract columns	| removes columns from destination table if they are found in the source table, but keeps the identifier columns.",
"		table exclude exclusive columns	| Removes columns found in both source and destination table, but keeps the identifier columns (exclusive OR).",
"		===",
"",
"		<br/><img src=\"Images/Function_table_exclude.jpg\" alt=\"Function 'table exclude'\"><br/><br/>",
"",
"		<u>Note</u>: If the destination table does not yet exist, or if the table is entirely empty (i.e. no header inside), then the data in the source table will be copied into the destination table.",
"",
"		Typical applications:",
"		* Eliminating commonalities",
""
 ]
	,
	"Call as":			"procedure or function",
	"Parameter count":	"2-3 (Note: Max 3 parameters for this function family, not 6).<br>See __table merge(__) for parameter and return value description",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Details 01:Program Examples with 'table exclude ...'": "",
"Examples 01:Merging tables into one without identifier columns specified" : [
"		include( Support Library );",
"",
"		echo(\"Loading farms in Hillboro and Hillville\");",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		echo(\"Farms in Hillboro:\");",
"		table list( hb );",
"",
"		echo(\"Farms in Hillville:\");",
"		table list( hv );",
"",
"		count[] = table exclude( hv, hb );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 01:Output: Table will be empty because no identifier column is specified, so every column is unique": "automatic",

"Examples 02:Declare 'Farmer' as unique identifier" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table exclude( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 02:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Examples 03:Merge data in smart way and add 2 columns from source table:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table exclude extend columns( hv, hb, Farmer );",
"		// '*' corresponds to {Organic, Place, Wheat, Oat, Sheeps, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 03:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 04:Merge data in smart way and keep excludeed columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table exclude intersect columns( hv, hb, Farmer );",
"		// '*' corresponds to {Organic, Place, Wheat, Cows, Acres, Speciality}",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 04:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Examples 05:Merge data in smart way and exclude the columns:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table exclude subtract columns( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 05:Output: 3 farmers with land in both towns have been consolidated.": "automatic",


"Examples 06:Merge data in smart way and show all columns except comomon ones:" : [
"		include( Support Library );",
"		table load( hb, \"Examples/Table Merge Examples Hillboro.csv\");",
"		table load( hv, \"Examples/Table Merge Examples Hillville.csv\");",
"",
"		count[] = table exclude exclusive columns( hv, hb, Farmer );",
"",
"		echo(\"Hilltown is a merger of Hillboro and Hillville (\", count[], \" rows consolidated):\");",
"		table list( hb );"
 ]
		,
	"Output 06:Output: 3 farmers with land in both towns have been consolidated.": "automatic",

"Details 07:Tables with multiple non-unique identifiers being merged:" : [
"		In case you plan to merge two tables with a one or a selection of column identifiers which cannot guarantee uniqueness,",
"		e.g. a list of names identified by first name only, then this function will match first name pairs first,",
"		then the next ones below, and so forth.  As a result, every row is considered only once.  Long story short:",
"		Every row in the destination table will be consolidated only once.",
"		The following code example demonstrates this:"
 ]
		,
"Examples 07:One Jill and tow Micheles will be consolidated:" : [
"		include( Support Library );",
"",
"		table load( h1, \"Examples/Table Merge Examples Hobbies 1.csv\");",
"		table load( h2, \"Examples/Table Merge Examples Hobbies 2.csv\");",
"",
"		echo(\"Hoobies 1:\");      table list( h1 );",
"		echo(\"Hoobies 2:\");      table list( h2 );",
"",
"		count[] = table exclude( h2, h1, Name  );",
"",
"		echo(\"Combined list of hobbies (\", count[], \" rows consolidated):\");",
"		table list( h1 );"
 ]
		,

	"Output 07:The outcome": "automatic",

	"See also": [ "table merge", "table overlay", "table intersect", "table subtract", "table consolidate" ]
}

,

"table multiply ..." :
{
	"Function Names":	[ "table multiply", "table multiply selected rows" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"		A <i>cartesian multiplication</i> will be applied on the destination table using the data from the source table.  All (selected) rows in the destination table will be",
"		repeated by the number of rows in the source table and the additional columns be repeatedly appended.<br>",
"		<b>table multiply selected rows</b>takes an extra parameter to specify abBoolean expression to select rows to multiply and leave the remaining rows unchanged.<br>",
"		<u>Attention</u>: Multiplication by zero rows: If the source table contains zero rows below the headers, then a multiplication by zero will happen, which means",
"		that the rows in the destination will be removed.",
"",
"		<br/><img src=\"Images/Function_table_multiply.jpg\" alt=\"Function 'table multiply'\"><br/><br/>",
"",
""
 ]
	,
	"Call as":			"procedure",
	"Parameter count":	"2-4",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{ "Number": "1.",
		  "Name": "Name of existing source table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		},
		{ "Number": "2.",
		  "Name": "Name of destionation table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "" ]
		},
		{   "Number":		"Opt. 3.",
			"Name" :		"Expression to select rows",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
			"Default value": "true (all rows selected)",
"Description" : [
"				Applicable to function <b>table multiply selected rows</b> only, addressing the rows in the destination table.<br>",
"				Specify the conditions or rules to select the row.  See __expressions to select rows__.<br>",
"				__Partial table specification__ is supported here to reference table columns easily.  Example: <b>[Score]>=5</b>.<br>",
"				<u>Attention</u>: If you are using comparison operators = and <> (instead of == and !=) which allow more than 1 operand on the righ hand side, then make sure you put the entire expression into parentheses.  Otherwise the operators will hijack subsequent function parameters as part of their operands."
 ]
			
		},
		{ "Number": "Opt 3./4.",
		  "Name": "Destination columns",
		  "Direction": "input",
		  "Types": [ "table column" ],
		  "Default value": "-1 (behind last column)",
"Description" : [
"			Specify a header name or column number where to insert the new columns added. The specified column and further ones to the right will shift to the",
"			right accordingly.<br>",
"			Negative number are supported for indexing from right to left, however -1 refers to the end of the table, -2 to left of last column, etc.",
"			<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Only 1 header name or column number may be specified.",
""
 ]
			
		}
	],
"Examples" : [
"	include ( Support Library );",
"",
"	table initialize( colors,",
"		{ { Color,  Delight, Another Delight },",
"		  { red,    tomatoes,  strawberries },",
"		  { yellow, bananas,   lemons },",
"		  { green,  lettuce,   cucumbers },",
"		  { blue,   plums,     blueberries } } );",
"",
"	table initialize( shades,",
"		{ { Shade,   Example 2 }, { Dark, moonshine }, { Light, sunshine } } );",
"",
"	table multiply selected rows( shades, colors, ([Color]<>green), Another Delight );",
"",
"	// Why parentheses used in the 3rd parameter?",
"	// Comparison would otherwise hijack the 4th parameter.",
"	// Alternatively, use '!=' which expects only 1 comparison operand.",
"",
"	table list ( colors );"
 ]
	,
	"Output": "automatic"
}

,

"table divide ..." :
{
	"Function Names":	[ "table divide", "table divide selected rows" ],
	"Documentation":	"Function Description",
"Description" : [
"",
"	A relational division will be made from two tables referred as <i>dividend (numerator) </i> and <i>divisor (denominator)</i>.  A new table called <i>quotient</i> will be generated.",
"",
"	<br><br>",
"",
"		The dividend (numerator) table contains a set of headers <b>C = A + B</b> where<br>",
"		<b>A</b> refers to a set of headers which are not found in the divisor (denominator), and<br>",
"		<b>B</b> refers to a set of headers which are found in the divisor (<b>B'</b>).",
"",
"		The divisor table does not contain header names which are not found in the dividend table, meaning that both sets <b>B</b> and <b>B'</b> must contain the same headers.  ",
"		Ordering does not matter.",
"		",
"		The resulting quotient table will contain columns with headers <b>A'</b> which are the same headers as in set A in the dividend table.  ",
"		Briefly said: From the dividend table, pick all entries with common headers <b>A</b>, which match with all rows in the divisor table.",
"",
"		<br/><img src=\"Images/Function_table_divide.jpg\" alt=\"Function 'table divide'\"><br/><br/>",
""
 ]
	,
	"Call as":			"procedure",
	"Parameter count":	"4-6",
	"Restrictions":		"Indirect parameter passing is disabled",
	"Parameters":
	[
		{   "Number":		"Opt. 1.",
			"Name" :		"Expression to select rows",
			"Direction" :	"code",
			"Types" :		[ "expression", ":literal" ] ,
			"Default value": "true (all rows selected)",
"Description" : [
"				Applicable to function <b>table divide selected rows</b> only, affecting the numerator table.<br>",
"				Specify the conditions or rules to select the row.  See __expressions to select rows__.<br>",
"				__Partial table specification__ is supported here to reference table columns easily.  Example: <b>[Score]>=5</b>.<br>",
"				<u>Attention</u>: If you are using comparison operators = and <> (instead of == and !=) which allow more than 1 operand on the righ hand side, then make sure you put the entire expression into parentheses.  Otherwise the operators will hijack subsequent function parameters as part of their operands."
 ]
			
		},
		{ "Number": "1. / 2.",
		  "Name": "Name of existing numerand (dividend) table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "The table will not be modified by this function" ]
		},
		{ "Number": "2. / 3.",
		  "Name": "Name of existing denominator (divisor) table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "The table will not be modified by this function" ]
		},
		{ "Number": "3. / 4.",
		  "Name": "Name of quotient table",
		  "Direction": "input",
		  "Types": [ "literal" ],
		  "Description": [ "This table will be created." ]
		},
		{ "Number": "Opt 4. / 5.",
		  "Name": "Numerator columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"			Select the columns in the dividend (numerator) table to be used for the actual division process.  This feature drops the need for extracting a dedicated dividend",
"			table with the chosen columns to be used for division process.",
"			<br><br>		  ",
"		  ",
"		    See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified",
""
 ]
			
		},
		{ "Number": "Opt 5. / 6.",
		  "Name": "Categorization columns",
		  "Direction": "input",
		  "Types": [ "table columns" ],
"Description" : [
"				Specifing categorization columnns allows to do multiple division runs with different categories as specified as set of 1 or more headers this parameter.  ",
"				As an example if a country name is specified, then the division process will be repeated for all countries, and the quotient table contains an additional column",
"				at the left listing the country name in one of the examples shown below.<br><br>",
"",
"			See __table columns as function parameters__ for general ruling for this parameter.<br>",
"			Specific rules apply for this function:",
"			* Any number of header names and column numbers may be specified",
""
 ]
			
		}


	],
"Details 01:Simple example" : [
"		The following example does actually scan the numerator table for common parents of both children called Maria and Sabine (note: Age must also match).",
"		Actually, <b>function divide</b> answers the question on: \"Find all parents (father and mother) who have two children, one called Maria and 4 years old, and",
"		the other one called Sabine, 2 years old.  Two parents will be identified."
 ]
		,
"Examples 01:Code" : [
"	include ( Support Library );",
"",
"	table initialize( numerator,",
"		{ { Father,    Mother,   Child,   Age },",
"		  { Franz,     Helga,    Harald,    5 },",
"		  { Franz,     Helga,    Maria,     4 }, // No match - different parents",
"		  { Franz,     Ursula,   Sabine,    2 }, // \"",
"		  { Moritz,    Melanie,  Gertrud,   7 },",
"		  { Moritz,    Melanie,  Maria,     4 }, // Match",
"		  { Moritz,    Melanie,  Sabine,    2 }, // Match",
"		  { Peter,     Lisa,     Robert,    9 },",
"		  { Johann,    Lisa,     Maria,     4 }, // Match",
"		  { Johann,    Lisa,     Sabine,    2 }  // Match",
"		} );",
"",
"	table initialize( denominator,",
"		{ { Child,   Age },",
"		  { Maria,     4 },",
"		  { Sabine,    2 } } );",
"",
"	table divide( numerator, denominator, quotient );",
"",
"	table list( quotient );"
 ]
	,
	"Output 01: Two parent couples have been identified": "automatic",
"Details 02:Example with categorization by country" : [
"		The following example shows the categorization feature:"
 ]
		,
"Examples 02:Code" : [
"	include ( Support Library );",
"",
"	table initialize( numerator,",
"		{ { Father,    Mother,   Child,   Age },",
"		  { Franz,     Helga,    Harald,    5 },",
"		  { Franz,     Helga,    Maria,     4 }, // No match - different parents",
"		  { Franz,     Ursula,   Sabine,    2 }, // \"",
"		  { Moritz,    Melanie,  Gertrud,   7 },",
"		  { Moritz,    Melanie,  Maria,     4 }, // Match",
"		  { Moritz,    Melanie,  Sabine,    2 }, // Match",
"		  { Peter,     Lisa,     Robert,    9 },",
"		  { Johann,    Lisa,     Maria,     4 }, // Match",
"		  { Johann,    Lisa,     Sabine,    2 }  // Match",
"		} );",
"",
"	table initialize( 2 countries, { Country, Austria, Germany } ); // Add countries for each row",
"	table multiply( 2 countries, numerator, 0 );",
"	table sort rows ( numerator, Country );",
"	table list ( numerator );",
"",
"	table initialize( denominator,",
"		{ { Child,   Age },",
"		  { Maria,     4 },",
"		  { Sabine,    2 } } );",
"",
"	table divide( numerator, denominator, quotient, { Father, Mother, Child, Age }, Country );",
"",
"	table list( quotient );"
 ]
	,
	"Output 02: Two parent couples from each country have been identified": "automatic"
}	

}
