#!/usr/local/bin/b4p
runtime settings[verbose] = quiet;

//	A "Doxygen" like document compilation system for B4P.  Fits in less than 1000 lines of code.


//	Step 1: Load Catalogue of Books and let user choose a book to process
//	________________________________________________________________________________________________________________________

//	This file creates 2 global variables
//	1.  chosen book[title]: 	Title of the book chosen
//	1.  chosen book[abbr]: 		Abbreviation of the book chosen
//	2.  gathered input file names[]: All input files related to that book
//	3.  TOC file name[]: 		Beginning part of revolving TOC file name (without time stamp)
//	4.  destination path[]		Path to destnation directory


define procedure ( load catalogue of books )
{
	echo(new line, "Step 1: Load Catalogue of Books and let user choose a book to process", new line );

	table load excel file		( books, "Books.xlsx");
	table delete blank columns	( books );
	table delete blank rows		( books );
	table check headers		( books, {Book Title, Abbreviation, Files and Paths, Condition, Abstract } );
	table process selected rows	( books, [Condition]=="", [Condition] = true );

	table copy table		( books, menu );
	table insert columns		( menu, Choices, '', 0 );
	table keep selected rows	( menu, [Book Title] <> "",Destination );
	table process			( menu, [Choices] = chr( row() + code(A) - 1 ) ); 

	echo("Choose the book to process:");
	global() chosen book[title] 	= table menu quick ( menu, Choices, Book Title, Book Title );
	global() chosen book[abbr] 	= [books:Book Title, chosen book[title], Abbreviation ];

	table fill vertically		( books, {Book Title, Abbreviation} );
	global				{ gathered input file names[] = {}; }
	table process selected rows	( books, [Book Title]==chosen book[title] & expression( :[Condition] ) == true, 
						gathered input file names[] += search files( [Files and Paths] ) );

	table copy table		( books, dest );
	table keep selected rows	( dest, [Abbreviation]==Destination );
	global() destination path[]	= '';
	table process selected rows	( dest, destination path[] == '' & expression( :[Condition] ) == true, destination path[] = [Files and Paths] );
	if (destination path[]=='')	throw( "No destination path name found.");

	global() TOC file name[]	= "Revolving TOC " + chosen book[abbr];
	table delete			( menu, dest );
	table delete selected rows	( books, [Abbreviation]==Destination ); // Remove destination info.  Is distracting from now on
}


//	Step 2: Gather all input documents and put them into a common JSON file
//	________________________________________________________________________________________________________________________

	file[ collected contents json ] = "Master.json"; // All contents gathered in one JSON file and ready for further use


define procedure( gather input docu )
{
	echo(new line, "Step 2: Gather all input documents and put them into a common JSON file", new line );

	table initialize	( json extract, { "", "{" } ); // Blank header row is OK

	json active[]		= false;	// activated between B4PDOCU.START and B4PDOCU.STOP markers
	full line mode[] 	= 0;		// 0 = Not yet effective, >0 = effective with line counter

	for all parameters( gathered input file names[], file name[] ) // Capture all JSON codes
	{
	    echo		( "  Scan ", file name[] );
	    table load		( code, file name[], TEXT );
	    table process	( code, 
		if ( [0]='*B4PDOCU.STOP*' )
		{
		    json active[] = false;
		    table append ( json extract, {","} ); // Expect further items
		}
		else: if ( [0]='*B4PDOCU.START*')
		{
		    json active[] = true;
		}
		else: if (json active[])
		{
		    if ( [0]='*::' ) // Convenient descriptor detected
		    {
			if (full line mode[] > 0) table append on same field( json extract, " ]," ); // Mode already effective
			full line mode[] = 1;
			table append( json extract, { left(trim([0]),-2) + ' : [' } ); // Open array
			continue;
		    }

		    if (full line mode[] > 0)
		    {
			st[] = [0];
			if (trim(st[])='+++*') // Convenient description ends here (closing symbol at beginning of line )
			{
			    table append  ( json extract, { ' ]', st[] - '+++'} );
			    full line mode[] = 0;
			}
			else
			{
			    if (full line mode[]++ > 1) table append on same field ( json extract, ',' );
			    substitute all( st[], {'\', '"'}, {'\\', '\"' } );
			    table append( json extract, { '"' + st[] + '"' } );
			}
		    }
		    else
		    {
		        table append( json extract, {[0]} );
		    }

		} );
	}

	[ json extract : 0, -1 ] = "}"; // Last row: Replace final comma by closing braces
	table save( json extract, file[ collected contents json ], new line ); // Save the JSON code
}



//	Step 3: Ensure that all descriptions are inside, and pre-define the HTML file names
//	________________________________________________________________________________________________________________________



table initialize ( table of general descriptors,
	{ {	"Name",				"Required",	"Variable",	"Todo",		"Values"		},	
	//	-------------------		-------------	-------------	-------------   ----------------------------------	
	  {	"Documentation",		Yes,		simple,		"identify"},
// Hidden {	"Feature Names",		Yes,		"simple,array",	"list,comma break,monospace"},
	  {	"Feature Names",		Yes,		"simple,array",	""},
// Hidden {	"Keywords",			No,		"simple,array",	"list,comma break"},
	  {	"Keywords",			No,		"simple,array",	""},
	  {	"Library",			No,		simple,		"list,comma break"},
	  {	"Version",			No,		simple,		"append"} } );
for all parameters( { '01'..'50' }, i[] )
{
    table append ( table of general descriptors,
	{ {	"Description " + i[], 		No,		"simple,array",	"text,html,link embedded keywords"},
	  {	"Examples " + i[],		No,		"simple,array",	"list,line break,monospace,code"},
	  {	"Output " + i[],		No,		"simple,array",	"list,line break,monospace,output"} } );
}
table append ( table of general descriptors,
	{ {	"Restrictions",			No,		"simple,array",	"list,line break,html"},
	  {	"OS differences",		No,		"simple,array",	"text,html"},
	  {	"Exceptions",			No,		"simple,array",	"text,line break,html"},
	  {	"See also",			No,		"simple,array",	"list,line break,link keywords"},
	  {	"Notes",			No,		"simple,array",	"text,html"} } );

table initialize ( table of function descriptors,
	{ {	"Name",				"Required",	"Variable",	"Todo",		"Values"		},	
	//	-------------------		-------------	-------------	-------------   ----------------------------------	
	  {	"Documentation",		Yes,		simple,		"identify"},
	  {	"Function Names",		Yes,		"simple,array",	"list,comma break,monospace"},
	  {	"Keywords",			No,		"simple,array",	""},
	  {	"Library",			No,		simple,		"list,comma break"},
	  {	"Synopsis",			No,		"simple,array",	"list,line break,html,monospace"},
	  {	"Version",			No,		simple,		"append"},
	  {	"Description",			Yes,		"simple,array",	"text,html,link embedded keywords"},
	  {	"Call as",			Yes,		simple,		"append","procedure,function,procedure or function" },
	  {	"Restrictions",			No,		"simple,array",	"list,html,line break,link embedded keywords"},
	  {	"OS differences",		No,		"simple,array",	"text,html,link embedded keywords"},
	  {	"Parameter count",		Yes,		simple,		"text,html,link embedded keywords"},
	  {	"Parameters",			No,		array,		"parameters"},
	  {	"Return value",			No,		array,		"return values"},
	  {	"Exceptions",			No,		"simple,array",	"list,html,line break"},
	  {	"Examples",			No,		"simple,array",	"list,line break,monospace,code"},
	  {	"Output",			No,		"simple,array",	"list,line break,monospace,output"}} );

for all parameters( { '01'..'20' }, i[] )
{
    table append ( table of function descriptors,
	{ {	"Details " + i[], 		No,		"simple,array",	"text,html,link embedded keywords"},
	  {	"Examples " + i[],		No,		"simple,array",	"list,line break,monospace,code"},
	  {	"Output " + i[],		No,		"simple,array",	"list,line break,monospace,output"} } );
}

table append ( table of function descriptors,
	{ {	"See also",			No,		"simple,array",	"list,line break,link keywords"},
	  {	"Notes",			No,		"simple,array",	"text,html"} } );


supported types checked[] = 

	"all types," +
	"valid types," +
	"boolean," +
	"numeral," +
	"numeral or literal," +
	"numeral or literal or date," +
	"table column," +
	"table columns," +
	"date," +
	"literal," +
	"blank literal," +
	"parameter set," +
	"parameter set containing numerals," +
	"parameter set containing literals," +
	"parameter set containing dates," +
	"parameter set or literal," +
	"matrix,matrix of numerals," +
	"variable," +
	"comparison expression," +
	"expression," +
	"statements," +
	":literal," +
	"parameter set of numerals," +
	"numerals or literals," +
	"date or literal converted to date";


table initialize ( table of parameter descriptors,
	{ {	"Name",				"Required",	"Variable",	"Todo",		"Values"		},	
	//	-------------------		-------------	-------------	-------------   ----------------------------------	
	  {	"Number",			Yes,		simple,		"list" },
	  {	"Types",			Yes,		"simple,array",	"list,line break", supported types checked[] },
	  {	"Name",				Yes,		simple,		"list"	},
	  {	"Direction",			Yes,		simple,		"list", 	"input,output,io,reference,code" },
	  {	"Description",			Yes,		"simple,array",	"text,html,link embedded keywords"},
	  {	"Default value",		No,		"simple",	"list" } } );
	

// Derive the table for return values (subset of 'table of table descriptions'

table copy table 		( table of parameter descriptors, table of return value descriptors );
table keep selected rows	( table of return value descriptors, [Name] = Name, Types, Description );



define procedure( check descriptions, { {name, literal}, { item, all, reference }, {descriptor table, literal } } )
{
    echo("Check: ", name[] );
    descriptors[] = set names( item[], 1, all );

    for all parameters( descriptors[], descriptor[], index[]) descriptors[]{index[]} = left( descriptor[], ':' ); // Keep main descriptor only

    // Check for redundant invalid descriptors and missing descriptors

    redundant descriptors[] = descriptors[] - [descriptor table[]:Name,..];
    if (redundant descriptors[] <> {} ) 
	throw( "Entry '" + name[] + "'" + new line + "has following invalid (redundant) descriptors:" + new line + join( redundant descriptors[], "," ) );

    missing descriptors[] = [descriptor table[]:Required,:Yes,Name] - descriptors[];
    if (missing descriptors[] <> {})
	throw( "Entry '" + name[] + "'" + new line + "has missing following required descriptors:" + new line + join( missing descriptors[], "," ) );


   for all variables( item[], value[], counter[], full descriptor[] )
   {
	// full descriptor[] contains full descriptor name, e.g. "Description 01:Some Text".  
	//      descriptor[] contains "Description 01" only.

	echo( "   ",full descriptor[] );
	descriptor[] = left( full descriptor[], ':' );

	id[] = identify( item[counter[]] );

	if ( id[] <> softquoted literal([descriptor table[]: Name, descriptor[], Variable ]) )
	    throw( "Entry '" + name[] + "'" + new line + "Descriptor '" + full descriptor[] 
		+ "'" + new line + "is of type '" + id[] + "' while expecting one of: " + [descriptor table[]: Name, descriptor[], Variable ] );

	valid values[] = softquoted literal([descriptor table[]: Name, descriptor[], Values ]);
	if (valid values[] = '') valid values[] = '*';
	begin of message[] = "Entry '" + name[] + "'" + new line + "Descriptor '" + descriptor[] + "'" + new line;

	if (descriptor[] <> Parameters,Return value)
	{
	    if (id[] == simple) // Check that simple values are literals
	    {
		if (type(item[counter[]]) = void ) throw( begin of message[] + "contains no data.");

		item[counter[],Text] = item[counter[]]; // Move simple contents to member variables so all contents are in member variables
		item[counter[]] = 0;
	    }

	    for all variables ( item[counter[]], tmp[], index[] ) // Check that all array members are literals
	    {
		subitem[] =^ item[counter[], index[]];
		if (type( subitem[] ) != literal)
		    throw( begin of message[] + literal(index[]+1) + ". Value: '"  + literal(subitem[]) + "' is of data type '" + type(subitem[]) + "' while expecting 'literal'.");

		if (subitem[] <> valid values[])
		    throw( begin of message[] + literal(index[]+1) + ". Value: '" + subitem[]          + "' is not one of:  " + [descriptor table[]: Name, descriptor[], Values]);

	    }
	}
    }
}


define procedure( check all descriptions )
{
	echo(new line, "Step 3: Ensure that all descriptions are inside, and pre-define the HTML file names", new line );
	echo( "Identified following section names:", new line, join( set names( docu[], 1, all ), "    ", new line + "    "), new line  );

	for all variables( docu[], value[], counter[], name[] )
	{
	    // Check for tag name "Documentation", supposed to contain "General Description" or "Function Desccription"
	    if (identify( docu[ name[], Documentation ] ) <> simple) throw ( "Entry '" + name[] + "'" + new line + "Identifier 'Documentation' not defined. ");

	    item[] =^ docu[ name[] ]; // Refers to one function description

	    if ( item [ Documentation ] == "Function Description" )
	    {
		check descriptions( name[], item[], table of function descriptors );
		for all parameters( {Parameters, Return value}, keyword[] )
		{
		    for all variables if existing( item[keyword[]], value[], para_counter[] ) // Loop through parameters
		    {
		        parameter[] =^ item[keyword[], para_counter[]];
		        check descriptions( literal(para_counter[]+1) + ". " + keyword[], parameter[], select if ( keyword[]==Parameters, table of parameter descriptors, table of return value descriptors ) );
		    }
		}
		item[HTML File Name] = chosen book[abbr] + "_Function_" + replace all( item[Function Names,0], " ", "_" ) + ".html"; // Assign HTML file name
	    }
	    else: if ( item [ Documentation ] == "General Description" )
	    {
		check descriptions( name[], item[], table of general descriptors );
		item[HTML File Name] = chosen book[abbr] + "_Features_" + replace all( item[Feature Names,0], " ", "_" ) + ".html"; // Assign HTML file name
	    }
	    else: throw( "Docu title '" + name[] + "':" + new line + "Tag 'Documentation' is '" + item[Documentation] + "'. ('General Description' or 'Function Description' expected.)" );
	}
}



//	Step 4: Collect all keywords in a table
//	________________________________________________________________________________________________________________________


keyword index file[] = "New Keyword Index.csv";


define procedure( collect keywords )
{
	echo(new line, "Step 4: Collect all keywords in a table", new line );

	keyword index headers[] 		= { Abbreviation, Section Name, HTML File Name, Documentation Type, Feature Names, Keywords };

	if (file existing( keyword index file[] ))
	{
		table load			( keyword index, keyword index file[] );
		table check headers		( keyword index, keyword index headers[] );
		table delete selected rows	( keyword index, [Abbreviation]=chosen book[abbr] ); // Remove own former index entries
	}
	else:	table initialize		( keyword index, {keyword index headers[]} );

	for all variables( docu[], value[], counter[], name[] )
	{
	    item[] =^ docu[ name[] ];		// Refers to one function description

	    for all variables if existing	( item[ select if(item[Documentation,0]==Function Description,Function Names,Feature Names) ], value[] ) // Pick up all "Feature Names" / "Function Names"
	    {
		table append			( keyword index, {{ chosen book[abbr], name[], item[HTML File Name], item[Documentation,0], value[] }} );
	    }

	    for all variables if existing	( item[ Keywords ], value[] ) // Pick up all "Keywords"
	    {
		table append			( keyword index, {{ chosen book[abbr], name[], item[HTML File Name], item[Documentation,0], "", value[] }} );
	    }
	}

	table rearrange selected rows		( keyword index, ([Abbreviation]==chosen book[abbr]), top ); // Own book is privileged when searching for duplicate references.

	table save( keyword index, keyword index file[] );

	table process selected rows		( keyword index, [Keywords]=='', [Keywords] += [Feature Names] ); // Feature names are also to be listed under keywords.
						// Feature names are used in function references, etc.
}



//	Step 5: Load and update Revolving Table of Contents (TOC)
//	________________________________________________________________________________________________________________________


define procedure( load revolving TOC )
{
	echo(new line, "Step 5: Load and update Revolving Table of Contents (TOC)", new line );

	global() RTOC headers[] = { Status, Category, Level, Section Nr, Section Name, HTML File Name, Feature Names, Keywords, Remarks };
	file name[] = choose recent file( "", "", TOC file name[] + "*.csv", newest, 1 );

	if (file name[]='')
	{
		table initialize( RTOC, { RTOC headers[] } );					// Create a new table with the headers
	}
	else
	{
		table load			( RTOC, file name[] );
		table insert missing columns	( RTOC, RTOC headers[] );
		table keep columns		( RTOC, RTOC headers[] );			// Discard unnecessary columns, rearrange existing ones in right order
		[RTOC:{Section Nr, Feature Names, Keywords, Status},..] = {'X', '', '', Missing}; // Clear all output columns
		table process selected rows	( RTOC, [Category]!=Link, [HTML File Name] = '' );
	}

	// Use the keyword index, consolidated to 1-row-per-item, to update the revolving TOC.  All existing sections get status "OK".

	table copy table selected rows	( keyword index, temp, [Abbreviation] == chosen book[abbr] );
	table consolidate		( temp, Section Name, { HTML File Name, Feature Names, Keywords }, { overwrite if blank, append once, append once }, "," );
	table insert columns		( temp, Status, "OK" );
	table merge			( temp, RTOC, Section Name, { HTML File Name, Feature Names, Keywords, Status }, overwrite );
	table delete			( temp );
	table process selected rows	( RTOC, [Status]==OK & [Category]=='', [Status] = select if ([Section Nr]==X, Pending, New ) );

}


//	Step 6: Sequence the revolving TOC (Chapter and section numbering)
//	________________________________________________________________________________________________________________________


define procedure( sequence revolving TOC )
{
	echo(new line, "Step 6: Sequence the revolving TOC (Chapter and section numbering)", new line );

	counter[Intro] = {0};
	counter[Body] = {0};
	counter[Appendix] = {0};

	table process( RTOC ,
	{
		[Section Nr] = '';
		if ([Category]<>'Intro','Body','Appendix')
		{
		    [Status] += ", (Assign right Category)";
		    continue;
		}

		if ([Level]<>0..10)
		{
		    if ([Status] = OK,Pending,Missing) [Status] += ", (check Level (Must be 0..10))";
		    continue;
		}

		if ([Level]>=1) // 0 = Ignore, 1..10 = 10 hierarchical levels
		{
		    if (counter[[Category]]{} > [Level]) // Next upper level section
		    {
			counter[[Category]] = counter[[Category]]{0..[Level]-1};
		    }

		    if (counter[[Category]]{} == [Level]) // Next section at same level
		    {
			counter[[Category]]{-1}+= 1; // Increment
		    }
		    else
		    {
			counter[[Category]] += { [Level]-counter[[Category]]{} : 1 };
		    }
		}
		[Section Nr] = [Category]{0} + " " + join( counter[[Category]], "." );
	} );
}




//	Step 7: Create the navigator (to be integrated in HTML files) from revolving TOC
//	________________________________________________________________________________________________________________________


define procedure ( create navigator from revolving TOC )
{
	echo(new line, "Step 7: Create the navigator (to be integrated in HTML files) from revolving TOC", new line );

	head[] = '<div class="booktitle_field">' + chosen book[title] + '</div>'; // Book title on top left of navigator.
	table initialize( navigator, { { head[], Level, HTML File Name, Section Name}, { "<ul>" } } );
	level[] = 1; // Initial level

	table process selected rows ( RTOC, [Category] != Ignore,
		next level[] = select if( [Level]=='', 1, [Level] );
		while (next level[] < level[])  { table append( navigator, {{ "</ul></li>", level[]-- }} );  }
		while (next level[] > level[])  { table append( navigator, {{ '<li class="navi"><ul>',   ++level[] }} );  }
		if ([HTML File Name] != '')
		{
			table append( navigator, { { '<li class="navi">' + '<a href="' + [HTML File Name] + '"><div class="navi">' + right([Section Nr],' ') + " " + [Section Name] + " </div></a></li>", level[], [HTML File Name], [Section Name] } } );
		}
		else
		{
			table append( navigator, { { '<li class="navi"><div>' + right([Section Nr],' ') + " " + [Section Name] + " </div></li>", level[] } } );
		} );
	while (1 < level[])  { table append( navigator, { "</ul></li>" } ); level[]--; } // Close all nested itemizations

	table append( navigator, { "</ul>" } );
	table save ( navigator, "Navigator.csv"  );
}	




//	Step 8: Generate the contents
//	________________________________________________________________________________________________________________________




define procedure( save example program, { { program table, literal }, { b4p file name, literal } } )
{
	table insert rows ( program table[], 0, 1 ); // Insert row 0 as it needs to be processed, too.
	table delete selected rows( program table[], [0]=~ '*include*(*Support Library*)*;','*include*(*Office Library*)*;','*include*(*Utility Library*)*;' ); // Remove includes
	table process( program table[], [0] = [0] - "Examples/" - "examples/" - "Examples\" - "examples\" ); // Remove subdirectories
	[ program table[]: 0, 0 ] = "#!/usr/local/bin/b4p"; // Shebang for UNIX/LINUX/MacOS systems
	table save ( program table[], "Examples/" + b4p file name[], TEXT );
}


define function( run example program, { { program table, literal }, { b4p file name, literal } } )
{
	table save	( program table[], "Example_Program.b4p", new line );
	echo		( "    Run example program.  If dead, then look at Example_Program.b4p and run it. Here: Type 'exit' to continue");
	system		( quote path(system info[bin directory] + system info[directory separator] + B4P) + " -wx Example_Program.b4p > Example_Out.txt" );

	save example program( program table[], b4p file name[] );

	table load	( example output, Example_Out.txt, TEXT );
	return 		( join([example output:0,], new line) ); // Return output as one string.
}



define procedure( apply HTML links on keywords, { { text, all, reference } } )
{
	for all variables( text[], line[], i[] )
	{
		row[] = table search row ( keyword index, [Keywords]=+literal(line[]) );
		if (row[] >= 0) 
		{
		    text[i[]] = '<a class = "bold_text" href="' + [keyword index:HTML File Name,row[]] + '">' + line[] + '</a>';
		}
		else
		{
		    text[i[]] = '<span class="red_text">' + line[] + '</span>';
		}
	}
}


define procedure( apply HTML links on embedded keywords, { { text, all, reference } } )
{
	for all variables( text[], line[], i[] )
	{
		while ( text[i[]] = '*__*__*')
		{
		    item[] = middle ( text[i[]], '__', '__' );

		    is function[] = item[] = '*('; // If ending with open parentheses, then this one is a function name
		    pure item[] =   item[] -  '('; // Remove the open parentheses

		    if ( is function[] )
		    {
			row[] = table search row ( keyword index, ([Feature Names]=+literal(pure item[])) & ([Documentation Type]=Function Description) );
		    }
		    else
		    {
			row[] = table search row ( keyword index, ([Keywords]=+literal(pure item[]))  );
		    }

		    if (row[] >= 0)
		    {
//			new item[] = '<a ' + select if( is function[], 'class="bold_text"','')  + ' href="' + [keyword index:HTML File Name,row[]] + '">' + pure item[] + '</a>';
			new item[] = '<a class="bold_text" href="' + [keyword index:HTML File Name,row[]] + '">' + pure item[] + '</a>';
		    }
		    else
		    {
			new item[] = '<span class="red_text">' + pure item[] + '</span>';
		    }
		    if (is function[]) new item[] += '(';
		    substitute( text[i[]], "__" + item[] + "__", new item[] );
		}
	}
}


define procedure( convert manuscript itemizations into HTML, { { text, all, reference } } ) // Converts * xxx and ** xxx markdowns to 2-level bullet itemization
{
	level[] = 0; // 0 = No itemization
	prev[] = 0;
	for all variables( text[], line[], i[] )
	{
		line[] = trim(line[]);
		if (line[]{0..2} == "** ") level[]= 2;
		else: level[]= select if (line[]{0..1} == "* ", 1, 0);

		switch( level[] )
		{
		    case (0)
		    {
			prefix[] = select( prev[], "", 		"</ul><p>", 	"</ul></li></ul><p>" );
			text[i[]] = prefix[] + line[];
		    }
		    case (1)
		    {
			prefix[] = select( prev[], '</p><ul class="bullets">', 	"", 		"</ul></li>" );
			text[i[]]  = prefix[] + '<li class="bullets">' + (line[]-"* ") + "</li>";
		    }
		    case (2)
		    {
			prefix[] = select( prev[], '</p><ul class="bullets"><li class="bullets"><ul class="bullets">', '<li class="bullets"><ul class="bullets">', 	"" );
			text[i[]]  = prefix[] + '<li class="bullets">' + (line[]-"** ") + "</li>";
		    }
		}
		prev[] = level[];
	}
}




define procedure( convert manuscript tables into HTML, { { text, all, reference } } )
{
	table state[] = idle; // Shall take values idle, th, td  (th = table header, td = table details, bot used as HTML markups)
	for all variables( text[], line[], i[] )
	{
		if (line[]='*===*')
		{
		    if (table state[]=idle)
		    {
			widths[] = parameter set( right(line[],'===') ); // Pick up widths
			table id[] = '';
			table state[] = th;
			text[i[]] = '';
			table width[] = 0;
			for all parameters( widths[], w[] )
			{
			    if (numeral( w[] ) != 0)
			    {
				table width[] += w[];
				text[i[]] += '<col style = "width:' + literal(w[]) + 'px">';   
			    }
			    else: if (trim(w[]) == 'noheader')
			    {
				table state[] = td;
			    }
			    else
			    {
				table id[] = ' class="' + w[] + '"';
			    }
			}
			if (table width[]>0)
			{
				table id[] += ' style = "width:' + literal(table width[]) + 'px"';
				if (table width[] > 1000) pause("Attention: Summed width is ", table width[], " and greater than 1000 pixel");
			}
			text[i[]] = "</p><table" + table id[] + ">" + text[i[]];

//		        echo("    Did: ", text[i[]] );
		    }
		    else
		    {
			text[i[]] = "</table><p>";
			table state[] = idle;
//		        echo("    Did: ", text[i[]] );
		    }
		}
		else: if (table state[] <> idle)
		{
		    text[i[]] = "<tr>";
		    do
		    {
			segment[] 	= left	(line[],'|');
			next[] 		= find	(line[],'|');
			line[] 		= right	(line[],'|');
			text[i[]] += "<" + table state[] + ">" + segment[] + "</" + table state[] + ">";
		    }
		    while (next[] >= 0);
		    text[i[]] += "</tr>";
		    table state[]  = td;
//		    echo("    Did: ", text[i[]] );
		}
	}
}




define procedure ( create function description in HTML, { { item, all, reference }, { HTML out, literal }, { content type, literal } } )
{
    table name[] = select if ( content type[] == "Function Names", table of function descriptors, table of general descriptors );
    table create( example program ); // Make sure this table is empty
    example program counter[] = 0;

    all full descriptors[]	= set names( item[], 1, all );				// e.g. {"Descriptor 01:Intro", ...}
    all descriptors[]		= deep( left, { all full descriptors[], ':' } ); 	// e.g. {"Descriptor 01", ...}

    for all table rows(  table name[], Name, descriptor[] )
    {
	description title[] 	= '';
	pos[] 			= find( all descriptors[], descriptor[] );
	if (pos[]<0) 		continue loop; // Skip items not needed for output like "HTML File Name".

	full descriptor[]	= all full descriptors[]{pos[]};
	descriptor to show[] 	= right( full descriptor[], ':'  ); 			// Right side of colon if colon available, otherwise full text

	check( [Todo] )
	{
	    case ( '*append*' )
	    {
		apply HTML links on embedded keywords( item[full descriptor[]] );
		table append( HTML out[], { "<h4> " + descriptor to show[] + ": " + '<span class="black_text">' + join( set( item[full descriptor[]], 1 ),", ") + "</span></h4>" } );
	    }

	    case ( '*list*,*text*,*parameters*,*return values*' )
	    {
		if (full descriptor[]='Examples ##:*','Output ##:*')	table append( HTML out[], { "<h5> " + descriptor to show[] + "</h5>" } );
		else:							table append( HTML out[], { "<h4> " + descriptor to show[] + "</h4>" } );
	    }

	    case ( '*parameter*' )
	    {
		param list[] =^ item[[Name]];
		table append( HTML out[], { '<table class="simple"><col style = "width:80px"><col style = "width:120px"><col style = "width:800px"><tr><th>No.</th><th>Type</th><th>Description</th></tr>' } );
		for all variables( param list[], dummy value[], index[])
		{
			param[] =^ param list[index[]]; 
			convert manuscript itemizations into HTML( param[Description] );
			convert manuscript tables into HTML( param[Description] );
			apply HTML links on embedded keywords( param[Description] );

			table append( HTML out[], 
				{ "<tr><td>" + param[Number,0] + "<br/>" + param[Direction,0] + "</td>",
				  "<td>" + join( set( param[Types], 1 ),"<br/>") + "</td>",
				  "<td>" + "<b>" + param[Name,0] + "</b><br/><p>" + join( set( param[Description], 1 ),new line) + "</p>" } );
			if (existing( param[Default value]))
			    table append( HTML out[], { '<span class="black_text"><b> Default value: </b></span>' + param[Default value,0]  } );
			table append( HTML out[], { "</td></tr>" } );
		}

		table append( HTML out[], { "</table>" } );
	    }

	    case ( '*return values*' )
	    {
		param list[] =^ item[[Name]];
		table append( HTML out[], { '<table class="simple"><col style = "width:120px"><col style = "width:880px"><tr><th>Type</th><th>Description</th></tr>' } );
		for all variables( param list[], dummy value[], index[])
		{
			param[] =^ param list[index[]]; 
			convert manuscript tables into HTML( param[Description] );
			table append( HTML out[], 
				{ "<tr>", "<td>" + join( set( param[Types], 1 ),"<br/>") + "</td>",
			          "<td>" + "<b>" + param[Name,0] + "</b><br/><p>" + join( set( param[Description], 1 ),new line) + "</p></td></tr>" } );
		}

		table append( HTML out[], { "</table>" } );
	    }
	    case ('*code*')
	    {
		table create( example program );
	    }

	    case ( '*link keywords*' )		apply HTML links on keywords( item[full descriptor[]] );

	    case ( '*link embedded keywords*' )
	    {
		apply HTML links on embedded keywords( item[full descriptor[]] );
	    }

	    case ( '*list*' )
	    {
		if ([Todo]='*monospace*')
		{
		    example program file name[] = '';
		    payloads[] <== item[full descriptor[]]; // Pick up all values into variable payloads;
		    for all variables( payloads[], value[], index[] )
		    {
		        if ([Todo]='*code*') 
			{
			 	table append( example program, { payloads[index[]] } ); // Record the example program in case of running it
			}
		

		        if ([Todo]='*code*','*output*') // Output example
		        {
			    substitute all( payloads[index[]], {"&","<",">","\","  "}, {"&amp;", "&lt;", "&gt;", "&#92;", " &nbsp;" } );
			    if (value[] =~ '*include*(*Support Library*)*;','*include*(*Office Library*)*;','*include*(*Utility Library*)*;')
				payloads[index[]] = '$SKIP$'; // Skip marker, see 'filter' call further below.
		        }

			if ( ([Todo]='*output*') & (trim(value[])=automatic,savecode) )
			{
				if (example program counter[] == 0)
				{
				    example program file name[] = item[HTML File Name]-".html" + ".b4p";
				}
				else
				{
				    example program file name[] = item[HTML File Name]-".html"+"_"+literal(example program counter[], "00" ) + ".b4p";
				}
				example program counter[]++;
				if (trim(value[])=automatic)
				{
				    payloads[index[]] = run example program( example program, example program file name[] );
				}
				else
				{
				    save example program( example program, example program file name[] );
				    payloads[index[]] = '$SKIP$'; // Skip marker, see 'filter' call further below.
				}
			        substitute all( payloads[index[]], {"&","<",">","\","  ",new line}, {"&amp;", "&lt;", "&gt;", "&#92;", " &nbsp;","<br/>" + new line } );
			}
		    }	
		    
		    class[] = compare select( [Todo], white_background_color, ('*code*'), code_background_color, ('*output*'), output_background_color );
		    class[] = 'class="' + class[] + '"';

		    payloads as set[] = filter( set (payloads[] , 1), <>'$SKIP$' );

		    payload[] = join ( payloads as set[], "<div " + class[] + " ><code>", select if ( ([Todo]='*line break*'), "<br/>" + new line, ", " ), "</code></div>" );
		    if (example program file name[]<>'')
		    {
		        payload[] += "<u>Try it yourself:</u> Open <b>" + example program file name[] + "</b> in <a class="bold_text" href="B4P_Examples.zip">B4P_Examples.zip</a>. Decompress before use.";
		    }
		    table append( HTML out[], { payload[] } );
		}
		else
		{
		    table append( HTML out[], { join ( set (item[full descriptor[]] , 1), "<p>", select if ( ([Todo]='*line break*'), "<br/>" + new line, ", " ), "</p>" ) } );
		}
	    }

	    case( '*html*' )
	    {
		convert manuscript itemizations into HTML( item[full descriptor[]] );
		convert manuscript tables into HTML( item[full descriptor[]] );
	    }

	    case ( '*text*' )
	    {
		table append( HTML out[], { join ( set (item[full descriptor[]] , 1), "<p>", new line, "</p>" ) } );
	    }

	}
    }
}



define procedure ( create all general and function descriptions in HTML )
{
	for all variables( docu[], value[], counter[], name[] )
	{
	    // Identify a file name
	    echo(new line, "Generate HTML for: ", name[] );

	    item[] =^ docu[ name[] ]; // Refers to one function description

	    for all parameters( { Function Names, Feature Names }, content type[] )
	    {
		if (existing( item[content type[],0] )) break;
	    }		
	    if ( !existing(content type[]) ) throw ( "Identified neither function nore feature names" );

	    if (content type[] == Function Names)
	    {
		plain file name[]= chosen book[abbr] + "_Function_" + replace all( item[Function Names,0], " ", "_" ) + ".html";
	    }
	    else
	    {
		plain file name[]= chosen book[abbr] + "_Features_" + replace all( item[Feature Names,0], " ", "_" ) + ".html";
	    }
	    file name[] = destination path[] + plain file name[];


	    table create( HTML function description );
	    create function description in HTML( item[], HTML function description, content type[] );
	    table load ( HTML template, "HTML Template.txt", TEXT );
	    if (file existing("Navigator.csv"))	 
	    {
		   table load ( HTML navigator, "Navigator.csv" );
	    }
	    else:  	table initialize( HTML navigator, { { "<ul>", Level } } );

	    table insert columns( HTML navigator, "Action" );

		// ***************** SIMPLIFY ************************
	    applicable row[] = table search row( HTML navigator, [0] = '*"' + softquoted literal(plain file name[]) + '"*' );
	    applicable row 2[] = applicable row[];
	    if ( [HTML navigator:0,applicable row[] ] = '*Table of Contents*' ) applicable row[]= -1; // Skip on table of contents

	    if (applicable row[] > 0) // From applicable row to top: Mark all items at same level (local only) and superior levels visible
	    {
		level[] = [HTML navigator:Level,applicable row[]];
		prev action[] = '';
		for (i[] = applicable row[], i[]>0, i[]--) with table( HTML navigator, i[] )
		{
		    if (([Level] > level[]) & ([Level]>2)) // Identified deeper places. Hide them.  But show level 1 and level 2 sections
		    {
			[Action] = Hide; 
			prev action[] = Hide;
		    }  
		    else
		    {
			if (prev action[] == Hide)
			{
			    substitute( [0], "<span>", "<span>+ " ); // Add a plus sign
			}
			prev action[] = '';
			if ([Level] < level[]) level[] = [Level]; // Step up
		    }
		}

		level[] = [HTML navigator:Level,applicable row[]]+1;
		for (i[] = applicable row[]+1, i[]<table length(HTML navigator), i[]++) with table( HTML navigator, i[] )
		{
		    if (([Level] > level[]) & ([Level]>2)) // Identified deeper places. Hide them.  But show level 1 and level 2 sections
		    {
			if (prev action[] != Hide)
			{
			    substitute( [0,i[]-1], '<div class="navi">', '<div class="navi">+ ' ); // Add a plus sign in the row above
			}
			[Action] = Hide; 
			prev action[] = Hide;
		    }  
		    else
		    {
			prev action[] = '';
			if ([Level] < level[]) level[] = [Level]; // Step up
		    }
		}
	    }

	    table process	( HTML template,
		switch( [0] )
		{
		    case ('*$Header$*')
		    {
			[0] = "<h3>" + name[] + "</h3>";
		    }

		    case ('*$Body$*')
		    {
			[0..] = [HTML function description:0,];
		    }

		    case ('*$Navigation$*') // Shall be referenced only once and after $PrevNext$
		    {
			table delete selected rows( HTML navigator, [Action]==Hide );
			table process selected rows( HTML navigator, [Section Name]==name[], [0] = replace([0], 'div class="navi"', 'div class="navi navi-selected"') );
			[0..] = [HTML navigator:0,];
		    }

		    case ('*$PrevNext$*') // !!! See important note above	
		    {
			link text[] = '';

			i[] = applicable row 2[]; // Look upwards for previous entry
			while (--i[] >= 1) with table ( HTML navigator, i[] )
			{
			    if ( [HTML File Name] != '')
			    {
				link text[] += '<a accesskey="p" href="' + [HTML File Name] + '"><span>Prev</span></a> ';
				break;
			    }
			}

			i[] = applicable row 2[]; // Look upwards for previous entry
			while (++i[] < table length(HTML navigator)) with table ( HTML navigator, i[] )
			{
			    if ( [HTML File Name] != '')
			    {
				link text[] += '<a accesskey="n" href="' + [HTML File Name] + '"><span>Next</span></a> ';
				break;
			    }
			}
			[0] = link text[];

		    }

		} );

	    table save( HTML template, file name[], new line );
	}

}



{	// Main program part

	load catalogue of books();
	gather input docu;
	variable load( docu[], file[ collected contents json ], JSON ); // Load the JSON code into one variable (docu[])

	check all descriptions;

	collect keywords;
	load revolving TOC;
	sequence revolving TOC;

	create navigator from revolving TOC;

	create all general and function descriptions in HTML;

	table save( RTOC, TOC file name[] + literal( date(now), " YYYY-MM-DD HH.II.SS" ) + ".csv" );
	if (chosen book[abbr]=REF) table save( RTOC, destination path[] + "TOC.csv" ); // Applicable for reference manual only

	directory delete recursive all( destination path[] + Images );
	sleep(0.3); // OS works in background, need to wait a bit
	file copy recursive( ".\Images", destination path[]+"Images", "*.*" );
	file copy overwrite ( styles.css, destination path[] + styles.css ); // Style sheet

	if ( [RTOC:Category,Start] > 0 )
	{
		index html file name [] = [RTOC:Category,Start,HTML File Name];
		echo("Following HTML file name is duplicated to 'index.html': ", index html file name[] );
		file copy overwrite ( destination path[] + index html file name [], destination path[] + index.html );
	}

	// Put all the code examples into a ZIP file and stage it on the website, too.

	echo(new line, "Compress all code examples into B4P_Examples.zip" );
	working directory ( Examples );
	file delete silently( destination path[] + "B4P_Examples.zip" ); sleep( 0.3 ); // OS works in background, need to wait a bit
	zip compress( "*.*", destination path[] + "B4P_Examples.zip" );

}


catch ( msg[] ) // Exception handling
{
	substitute all ( msg[], new line, new line + "    ");
	echo( new line, "*** Error: ", msg[], new line );
	exit;

}

